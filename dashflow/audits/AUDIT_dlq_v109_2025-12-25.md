# Audit: dlq.rs v109 (2025-12-25)

**File:** `crates/dashflow-streaming/src/dlq.rs`
**Lines:** 1313 (post-fix)
**Auditor:** Worker #1810

## Summary

The Dead Letter Queue (DLQ) module provides centralized error handling for failed streaming messages. Overall code quality is **GOOD** with proper backpressure, retry logic, and forensic context.

**Status:** 0 P0 | 0 P1 | 0 P2 | 1 P3 FIXED | 1 P4 noted

---

## Issues Found

### M-1051 (P3): Blocking retry variant inconsistent with other retry methods - FIXED #1810

**Category:** Consistency/Reliability

**Problem:** `send_fire_and_forget_with_retry_blocking()` (lines 939-1001) had different retry logic compared to `send_with_retry()` and `send_fire_and_forget_with_retry()`:

1. Used `2u64.pow(attempt)` instead of `1u64.checked_shl(attempt).unwrap_or(u64::MAX)` - less safe overflow handling
2. Missing jitter (0-25%) - could cause thundering herd on concurrent retries
3. Missing "succeeded after retry" info log - reduced observability
4. Missing per-retry warning log with delay info

**Fix:** Updated blocking retry to match other methods:
- Use `checked_shl` with `saturating_mul` for safe overflow handling
- Add 0-25% jitter to prevent thundering herd
- Add success-after-retry info log
- Add per-retry warning log with delay details

**Files:** `crates/dashflow-streaming/src/dlq.rs:967-1022`

---

### M-1052 (P4): drain_in_flight truncation on u32 conversion - NOTED

**Category:** Correctness (theoretical)

**Location:** Line 476

**Observation:** `acquire_many(self.max_concurrent as u32)` truncates if `max_concurrent > u32::MAX`. In practice, `max_concurrent` defaults to 100 and is validated to be >= 1, so this is not a real issue.

**Action:** None required - theoretical edge case only.

---

## Positive Findings

1. **Payload truncation with forensics** (lines 144-170): Large payloads are truncated to 512KB with SHA256 hash stored for validation on replay. Includes `original_payload_size_bytes`, `original_payload_included_bytes`, and `original_payload_truncated` fields.

2. **Semaphore-based backpressure** (lines 464, 668-681): Fire-and-forget sends limited by configurable semaphore (default: 100 concurrent). Prevents unbounded task spawning under load.

3. **Blocking variants for critical messages** (lines 889-1023): `send_fire_and_forget_blocking` and `send_fire_and_forget_with_retry_blocking` wait for semaphore permits instead of dropping messages.

4. **Exponential backoff with jitter** (lines 613-630, 794-811, 991-1008): Retry methods use configurable exponential backoff with 0-25% jitter to prevent thundering herd.

5. **Comprehensive error context** (lines 52-123): `DlqMessage` includes source topic/partition/offset, consumer ID, thread/tenant IDs, trace context, and node ID for full forensic analysis.

6. **Good test coverage** (lines 1026-1313): 19 tests covering message creation, serialization, truncation, SHA256 validation, and configuration.

7. **Drain and flush support** (lines 470-522): `drain_in_flight()` and `flush()` methods for graceful shutdown.

---

## Verification

```bash
cargo check -p dashflow-streaming  # Zero warnings
```

---

## Conclusion

dlq.rs is well-designed with proper backpressure, retry logic, and forensic context. The one P3 issue (inconsistent blocking retry) has been fixed. No P0/P1/P2 issues found.
