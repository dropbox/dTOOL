# Audit: diff.rs + diff/protobuf.rs v109 (2025-12-25)

**Files:**
- `crates/dashflow-streaming/src/diff.rs` (571 lines)
- `crates/dashflow-streaming/src/diff/protobuf.rs` (765 lines)

**Total:** 1336 lines
**Auditor:** Worker #1810

## Summary

State diffing and patching module implementing JSON Patch (RFC 6902) with protobuf integration. Overall code quality is **EXCELLENT** with proper canonical hashing, integrity verification, size optimization, and browser encoding policy enforcement.

**Status:** 0 P0 | 0 P1 | 0 P2 | 0 P3 | 3 P4 noted (no fixes required)

---

## Issues Found (P4 Only)

### M-1055 (P4): Division by zero potential in Display - NOTED

**Category:** Edge case

**Location:** `diff.rs:106`

**Observation:** `(self.patch_size as f64 / self.full_state_size as f64)` could divide by zero if `full_state_size == 0`. However, even an empty JSON state `{}` serializes to 2 bytes, making this practically unreachable.

**Action:** None required - theoretical edge case only.

---

### M-1056 (P4): quickcheck seed parameter ignored - NOTED

**Category:** Test quality

**Location:** `diff.rs:514, 537, 550`

**Observation:** Property tests accept `_seed: u64` parameter but ignore it, using `Gen::new(20)` which creates a fresh generator. This means the seed doesn't control randomness.

**Action:** None required - test coverage is still valid, just not deterministically reproducible from seed.

---

### M-1057 (P4): optimal_payload silent fallback - NOTED

**Category:** Observability

**Location:** `diff.rs:89`

**Observation:** `serde_json::to_value(&self.patch).unwrap_or_else(|_| full_state.clone())` silently falls back to full state if patch serialization fails. This is defensive but loses information about the failure.

**Action:** None required - fallback is correct behavior for reliability; callers can check `use_full_state` flag if needed.

---

## Positive Findings

### diff.rs

1. **Canonical JSON for hashing** (lines 252-299): Keys are sorted alphabetically and values are serialized consistently for deterministic hashes.

2. **Golden vector test** (lines 407-422): Hash stability verified with known test vector `f35279c8aa6b00bc82d43a191596cc3b41b7de7899ee16e36a08efe3afc45103`.

3. **Size optimization with buffer** (line 156): Uses 10% buffer (`patch_size > full_state_size * 11 / 10`) to account for compression differences when deciding between patch and full state.

4. **SHA-256 integrity verification** (lines 211-245): Both state and patch hashes can be verified for data integrity.

5. **Property-based tests** (lines 473-569): Uses quickcheck for roundtrip verification, hash correctness, and size boundary testing.

### diff/protobuf.rs

1. **Encoding policy enforcement** (M-94, lines 78-118): Rejects MSGPACK and PROTOBUF encodings with clear error messages and metrics since browsers cannot decode them.

2. **Unsupported encoding metrics** (line 67-76): `dashstream_unsupported_encoding_total` counter tracks encoding policy violations.

3. **Error helpers** (CQ-9, lines 43-65): DRY error construction with `ser_err()`, `deser_err()`, `path_err()`, `from_path_err()`.

4. **Forward compatibility** (lines 108-117): Unknown encodings are allowed with warning for forward compatibility with future protocol versions.

5. **Comprehensive test coverage** (lines 326-763): 26 tests covering roundtrip, all RFC 6902 operations, null handling, invalid inputs, and encoding policy enforcement.

6. **Hash verification on apply** (lines 307-321): `apply_state_diff()` verifies state hash after reconstruction if provided.

---

## Verification

```bash
cargo check -p dashflow-streaming  # Zero warnings
```

---

## Conclusion

diff.rs and diff/protobuf.rs are well-designed with proper canonical hashing, integrity verification, and browser encoding policy. No P0-P3 issues found. Three P4 observations noted but no action required.
