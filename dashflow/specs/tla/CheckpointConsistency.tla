----------------------- MODULE CheckpointConsistency -----------------------
(***************************************************************************
 * TLA+ Specification for DashFlow Checkpoint Crash Consistency
 *
 * This specification models the FileCheckpointer crash-consistency contract:
 * - Checkpoints are written atomically (temp file + fsync + rename)
 * - The index file is updated atomically *after* the checkpoint file is durable
 * - A crash can occur at any time; on restart, the index never points to a
 *   missing checkpoint file
 *
 * This maps to:
 * - crates/dashflow/src/checkpoint.rs:
 *     - atomic_write_file_sync() (checkpoint file)
 *     - FileCheckpointer::save_index() (index.bin temp + rename)
 *
 * Phase: TLA-004 (Part 30: TLA+ Protocol Verification)
 * Author: Worker #2350
 * Date: 2026-01-03
 ***************************************************************************)

EXTENDS Integers, FiniteSets, TLC

(***************************************************************************
 * CONSTANTS
 ***************************************************************************)
CONSTANTS
    Threads,          \* Abstract thread identifiers (e.g., {t1, t2})
    MaxCheckpointId   \* Upper bound for tractable model checking

(***************************************************************************
 * VARIABLES
 ***************************************************************************)
VARIABLES
    status,    \* "running" | "crashed"
    diskFiles, \* [t \in Threads |-> SUBSET 1..MaxCheckpointId]  (checkpoint *.bin present)
    diskIndex, \* [t \in Threads |-> 0..MaxCheckpointId]         (index.bin latest pointer)
    saveThread, \* Thread currently saving (arbitrary when idle)
    saveId,     \* Checkpoint ID being saved (0 when idle)
    saveStage   \* "idle" | "temp_written" | "checkpoint_renamed" | "index_written"

vars == <<status, diskFiles, diskIndex, saveThread, saveId, saveStage>>

(***************************************************************************
 * TYPES
 ***************************************************************************)

Status == {"running", "crashed"}
Stage == {"idle", "temp_written", "checkpoint_renamed", "index_written"}

TypeInvariant ==
    /\ status \in Status
    /\ diskFiles \in [Threads -> SUBSET (1..MaxCheckpointId)]
    /\ diskIndex \in [Threads -> (0..MaxCheckpointId)]
    /\ saveThread \in Threads
    /\ saveId \in (0..MaxCheckpointId)
    /\ saveStage \in Stage
    /\ (saveStage = "idle") <=> (saveId = 0)

(***************************************************************************
 * HELPERS
 ***************************************************************************)

\* Maximum element of a non-empty finite set of naturals.
MaxSet(S) ==
    CHOOSE m \in S : \A x \in S : x <= m

\* Next checkpoint ID is computed from visible committed files (unique IDs).
\* (In DashFlow this is generated by a monotonic counter embedded in the ID.)
NextId(t) ==
    IF diskFiles[t] = {} THEN 1 ELSE MaxSet(diskFiles[t]) + 1

\* Disk-level safety: index never points at a missing checkpoint file.
IndexReferencesExistingCheckpoint ==
    \A t \in Threads : diskIndex[t] = 0 \/ diskIndex[t] \in diskFiles[t]

\* Crash-safety contract: a crash may leave extra files, but cannot invalidate
\* the last committed pointer (index) or make it reference a non-existent file.
Safety ==
    /\ TypeInvariant
    /\ IndexReferencesExistingCheckpoint

\* TLC state space constraint (keeps checking tractable)
StateConstraint ==
    \A t \in Threads : Cardinality(diskFiles[t]) <= MaxCheckpointId

(***************************************************************************
 * INITIAL STATE
 ***************************************************************************)
Init ==
    /\ status = "running"
    /\ diskFiles = [t \in Threads |-> {}]
    /\ diskIndex = [t \in Threads |-> 0]
    /\ saveThread \in Threads
    /\ saveId = 0
    /\ saveStage = "idle"

(***************************************************************************
 * TRANSITIONS
 ***************************************************************************)

\* Begin a save operation for some thread.
StartSave ==
    /\ status = "running"
    /\ saveStage = "idle"
    /\ \E t \in Threads :
        LET id == NextId(t)
        IN  /\ id <= MaxCheckpointId
            /\ saveThread' = t
            /\ saveId' = id
            /\ saveStage' = "temp_written"
    /\ UNCHANGED <<status, diskFiles, diskIndex>>

\* Atomic rename commits the checkpoint file to its final *.bin path.
CommitCheckpointFile ==
    /\ status = "running"
    /\ saveStage = "temp_written"
    /\ saveId # 0
    /\ diskFiles' =
        [diskFiles EXCEPT ![saveThread] = @ \cup {saveId}]
    /\ saveStage' = "checkpoint_renamed"
    /\ UNCHANGED <<status, diskIndex, saveThread, saveId>>

\* Index update is committed only after checkpoint file is committed.
CommitIndex ==
    /\ status = "running"
    /\ saveStage = "checkpoint_renamed"
    /\ saveId \in diskFiles[saveThread]
    /\ diskIndex' = [diskIndex EXCEPT ![saveThread] = saveId]
    /\ saveStage' = "index_written"
    /\ UNCHANGED <<status, diskFiles, saveThread, saveId>>

\* Save completes; in-flight state clears.
FinishSave ==
    /\ status = "running"
    /\ saveStage = "index_written"
    /\ saveId # 0
    /\ saveId = diskIndex[saveThread]
    /\ saveId' = 0
    /\ saveStage' = "idle"
    /\ UNCHANGED <<status, diskFiles, diskIndex, saveThread>>

\* Crash can happen at any point during execution; in-flight state is lost.
Crash ==
    /\ status = "running"
    /\ status' = "crashed"
    /\ saveId' = 0
    /\ saveStage' = "idle"
    /\ UNCHANGED <<diskFiles, diskIndex, saveThread>>

\* Restart loads persistent state (diskFiles, diskIndex) and resumes running.
Restart ==
    /\ status = "crashed"
    /\ status' = "running"
    /\ saveId' = 0
    /\ saveStage' = "idle"
    /\ UNCHANGED <<diskFiles, diskIndex, saveThread>>

Next ==
    \/ StartSave
    \/ CommitCheckpointFile
    \/ CommitIndex
    \/ FinishSave
    \/ Crash
    \/ Restart

Spec ==
    Init /\ [][Next]_vars

(***************************************************************************
 * PROPERTIES
 ***************************************************************************)

\* The key crash-consistency guarantee from the FileCheckpointer implementation:
\* the durable index pointer never references a missing checkpoint file.
THEOREM Spec => []IndexReferencesExistingCheckpoint

=============================================================================
