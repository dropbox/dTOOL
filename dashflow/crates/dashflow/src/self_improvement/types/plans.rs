// Copyright 2026 Dropbox (created by Andrew Yates <ayates@dropbox.com>)

//! Execution plan types for validated improvement plans.
//!
//! This module provides types for execution plans that have been validated
//! through multi-model consensus and are ready for implementation.

use chrono::{DateTime, Utc};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use super::citations::Citation;
use super::gaps::ImprovementProposal;

// =============================================================================
// ExecutionPlan - Validated Plan Ready for Implementation
// =============================================================================

/// A validated plan ready for implementation.
///
/// Execution plans are the actionable outputs of the self-improvement system.
/// Each plan has been validated through multi-model consensus and includes
/// detailed implementation steps, success criteria, and rollback procedures.
///
/// # Example
///
/// ```rust,ignore
/// use dashflow::self_improvement::{
///     ExecutionPlan, PlanCategory, ImplementationStep, PlanStatus,
///     IntrospectionStorage,
/// };
///
/// // Create an improvement plan
/// let plan = ExecutionPlan::new("Add sentiment analysis", PlanCategory::ApplicationImprovement)
///     .with_description("Add sentiment analysis to reduce prompt workarounds")
///     .with_priority(1)
///     .with_estimated_commits(2)
///     .with_steps(vec![
///         ImplementationStep::new(1, "Create sentiment module")
///             .with_files(vec!["src/tools/sentiment.rs".to_string()])
///             .with_verification("cargo test sentiment"),
///         ImplementationStep::new(2, "Integrate into graph")
///             .with_files(vec!["src/graph.rs".to_string()])
///             .with_verification("integration tests"),
///     ])
///     .with_success_criteria(vec![
///         "Sentiment accuracy >= 90%".to_string(),
///         "Latency < 100ms".to_string(),
///     ])
///     .with_rollback_plan("Remove sentiment node, revert to prompts")
///     .validated(0.85);
///
/// // Save for approval
/// let storage = IntrospectionStorage::default();
/// storage.save_plan(&plan)?;
///
/// // Later: approve and track implementation
/// storage.update_plan_status(&plan.id, PlanStatus::Approved)?;
/// ```
///
/// # Plan Lifecycle
///
/// 1. **Proposed** - Generated by analyzers, awaiting validation
/// 2. **Validated** - Passed multi-model consensus, awaiting approval
/// 3. **Approved** - Human or system approved, ready for implementation
/// 4. **Implementing** - Currently being implemented
/// 5. **Implemented** - Successfully completed
/// 6. **Failed** - Implementation failed, may need rollback
/// 7. **Superseded** - Replaced by a newer plan
///
/// # See Also
///
/// - [`PlanCategory`] - Types of improvements (application, framework, config)
/// - [`ImplementationStep`] - Individual implementation steps
/// - [`PlanStatus`] - Lifecycle states
/// - [`crate::self_improvement::IntrospectionStorage`] - Save and load plans
/// - [`crate::self_improvement::IntrospectionReport`] - Reports containing validated plans
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct ExecutionPlan {
    /// Unique identifier
    pub id: Uuid,

    /// Human-readable title
    pub title: String,

    /// Detailed description
    pub description: String,

    /// Category of improvement
    pub category: PlanCategory,

    /// Priority (1 = highest)
    pub priority: u8,

    /// Estimated effort in AI commits
    pub estimated_commits: u8,

    /// Steps to implement
    pub steps: Vec<ImplementationStep>,

    /// Success criteria
    pub success_criteria: Vec<String>,

    /// Rollback plan if it fails
    pub rollback_plan: String,

    /// Dependencies on other plans
    pub dependencies: Vec<Uuid>,

    /// Citations to supporting evidence
    pub citations: Vec<Citation>,

    /// Consensus validation score
    pub validation_score: f64,

    /// Status tracking
    pub status: PlanStatus,

    /// Actions to apply to graph configs (for auto-apply)
    #[serde(default)]
    pub actions: Vec<PlanAction>,
}

impl ExecutionPlan {
    /// Create a new execution plan
    #[must_use]
    pub fn new(title: impl Into<String>, category: PlanCategory) -> Self {
        Self {
            id: Uuid::new_v4(),
            title: title.into(),
            description: String::new(),
            category,
            priority: 3,
            estimated_commits: 1,
            steps: Vec::new(),
            success_criteria: Vec::new(),
            rollback_plan: String::new(),
            dependencies: Vec::new(),
            citations: Vec::new(),
            validation_score: 0.0,
            status: PlanStatus::Proposed,
            actions: Vec::new(),
        }
    }

    /// Set description
    #[must_use]
    pub fn with_description(mut self, desc: impl Into<String>) -> Self {
        self.description = desc.into();
        self
    }

    /// Set priority
    #[must_use]
    pub fn with_priority(mut self, priority: u8) -> Self {
        self.priority = priority;
        self
    }

    /// Set estimated commits
    #[must_use]
    pub fn with_estimated_commits(mut self, commits: u8) -> Self {
        self.estimated_commits = commits;
        self
    }

    /// Add implementation steps
    #[must_use]
    pub fn with_steps(mut self, steps: Vec<ImplementationStep>) -> Self {
        self.steps = steps;
        self
    }

    /// Add success criteria
    #[must_use]
    pub fn with_success_criteria(mut self, criteria: Vec<String>) -> Self {
        self.success_criteria = criteria;
        self
    }

    /// Set rollback plan
    #[must_use]
    pub fn with_rollback_plan(mut self, plan: impl Into<String>) -> Self {
        self.rollback_plan = plan.into();
        self
    }

    /// Add actions to apply to graph configs
    #[must_use]
    pub fn with_actions(mut self, actions: Vec<PlanAction>) -> Self {
        self.actions = actions;
        self
    }

    /// Add a single action to the plan
    #[must_use]
    pub fn add_action(mut self, action: PlanAction) -> Self {
        self.actions.push(action);
        self
    }

    /// Mark as validated
    #[must_use]
    pub fn validated(mut self, score: f64) -> Self {
        self.validation_score = score;
        self.status = PlanStatus::Validated;
        self
    }

    /// Convert to markdown
    #[must_use]
    pub fn to_markdown(&self) -> String {
        let mut md = String::new();
        md.push_str(&format!("**Category:** {:?}\n", self.category));
        md.push_str(&format!("**Priority:** {}\n", self.priority));
        md.push_str(&format!(
            "**Estimated Effort:** {} AI commits\n",
            self.estimated_commits
        ));
        md.push_str(&format!(
            "**Validation Score:** {:.2}\n\n",
            self.validation_score
        ));

        md.push_str(&format!("**Description:** {}\n\n", self.description));

        if !self.steps.is_empty() {
            md.push_str("**Steps:**\n");
            for step in &self.steps {
                md.push_str(&format!("{}. {}\n", step.order, step.action));
                if !step.files.is_empty() {
                    md.push_str(&format!("   Files: {}\n", step.files.join(", ")));
                }
                md.push_str(&format!("   Verification: {}\n", step.verification));
            }
            md.push('\n');
        }

        if !self.success_criteria.is_empty() {
            md.push_str("**Success Criteria:**\n");
            for c in &self.success_criteria {
                md.push_str(&format!("- [ ] {c}\n"));
            }
            md.push('\n');
        }

        if !self.rollback_plan.is_empty() {
            md.push_str(&format!("**Rollback Plan:** {}\n\n", self.rollback_plan));
        }

        md.push_str(&format!(
            "**Citations:** {}\n",
            self.citations
                .iter()
                .map(|c| format!("[{}]", c.id))
                .collect::<Vec<_>>()
                .join(", ")
        ));

        md
    }
}

// =============================================================================
// PlanCategory - Category of Execution Plan
// =============================================================================

/// Category of execution plan.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, JsonSchema)]
pub enum PlanCategory {
    /// DashOpt optimization (prompts, demos, model selection)
    Optimization,
    /// Application-level code changes
    ApplicationImprovement,
    /// DashFlow platform improvements
    PlatformImprovement,
    /// Documentation or process improvements
    ProcessImprovement,
}

impl From<&str> for PlanCategory {
    fn from(s: &str) -> Self {
        match s.to_lowercase().as_str() {
            "opt" | "optimization" | "prompt" => PlanCategory::Optimization,
            "platform" | "dashflow" | "infrastructure" => PlanCategory::PlatformImprovement,
            "process" | "doc" | "documentation" => PlanCategory::ProcessImprovement,
            _ => PlanCategory::ApplicationImprovement,
        }
    }
}

impl From<String> for PlanCategory {
    fn from(s: String) -> Self {
        PlanCategory::from(s.as_str())
    }
}

// =============================================================================
// ImplementationStep - Single Implementation Step
// =============================================================================

/// A single implementation step.
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct ImplementationStep {
    /// Step number
    pub order: u8,

    /// What to do
    pub action: String,

    /// Files to modify
    pub files: Vec<String>,

    /// Verification method
    pub verification: String,
}

impl ImplementationStep {
    /// Create a new implementation step
    #[must_use]
    pub fn new(order: u8, action: impl Into<String>) -> Self {
        Self {
            order,
            action: action.into(),
            files: Vec::new(),
            verification: String::new(),
        }
    }

    /// Add files to modify
    #[must_use]
    pub fn with_files(mut self, files: Vec<String>) -> Self {
        self.files = files;
        self
    }

    /// Set verification method
    #[must_use]
    pub fn with_verification(mut self, verification: impl Into<String>) -> Self {
        self.verification = verification.into();
        self
    }
}

// =============================================================================
// PlanStatus - Status of Execution Plan
// =============================================================================

/// Status of an execution plan.
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub enum PlanStatus {
    /// Plan has been proposed but not yet validated through consensus.
    Proposed,
    /// Plan has been validated through multi-model consensus.
    Validated,
    /// Plan is currently being implemented.
    InProgress {
        /// When implementation started.
        started: DateTime<Utc>,
        /// Who or what is implementing the plan.
        assignee: String,
    },
    /// Plan has been successfully implemented.
    Implemented {
        /// When implementation completed.
        completed: DateTime<Utc>,
        /// Git commit hash of the implementation.
        commit_hash: String,
    },
    /// Plan implementation failed.
    Failed {
        /// Why the implementation failed.
        reason: String,
    },
    /// Plan has been replaced by a newer plan.
    Superseded {
        /// ID of the plan that supersedes this one.
        by: Uuid,
    },
}

// =============================================================================
// ActionType - Type of Config Action
// =============================================================================

/// Type of action to apply from an execution plan.
///
/// Actions describe what configuration changes should be made to a graph
/// to implement an improvement plan.
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub enum ActionType {
    /// Update the system prompt for a node
    UpdatePrompt {
        /// Target node name
        node: String,
        /// New prompt content
        new_prompt: String,
    },

    /// Update a specific parameter in a node's config
    UpdateParameter {
        /// Target node name
        node: String,
        /// Parameter name (e.g., "temperature", "max_tokens")
        param: String,
        /// New parameter value
        value: serde_json::Value,
    },

    /// Replace the entire configuration for a node
    ReplaceConfig {
        /// Target node name
        node: String,
        /// New configuration object
        new_config: serde_json::Value,
    },

    /// Add a new node configuration
    AddConfig {
        /// Node name
        node: String,
        /// Node type (e.g., "llm.chat", "tool.search")
        node_type: String,
        /// Initial configuration
        config: serde_json::Value,
    },

    /// Remove a node configuration
    RemoveConfig {
        /// Node name to remove
        node: String,
    },
}

impl ActionType {
    /// Get the target node name for this action
    #[must_use]
    pub fn target_node(&self) -> &str {
        match self {
            Self::UpdatePrompt { node, .. }
            | Self::UpdateParameter { node, .. }
            | Self::ReplaceConfig { node, .. }
            | Self::AddConfig { node, .. }
            | Self::RemoveConfig { node } => node,
        }
    }

    /// Create an UpdatePrompt action
    #[must_use]
    pub fn update_prompt(node: impl Into<String>, new_prompt: impl Into<String>) -> Self {
        Self::UpdatePrompt {
            node: node.into(),
            new_prompt: new_prompt.into(),
        }
    }

    /// Create an UpdateParameter action
    #[must_use]
    pub fn update_parameter(
        node: impl Into<String>,
        param: impl Into<String>,
        value: serde_json::Value,
    ) -> Self {
        Self::UpdateParameter {
            node: node.into(),
            param: param.into(),
            value,
        }
    }
}

// =============================================================================
// PlanAction - Action to Apply
// =============================================================================

/// An action to be applied as part of an execution plan.
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct PlanAction {
    /// The type of action to perform
    pub action_type: ActionType,
    /// Human-readable description of why this action is being taken
    pub rationale: String,
    /// Expected impact of this action
    pub expected_impact: Option<String>,
}

impl PlanAction {
    /// Create a new plan action
    #[must_use]
    pub fn new(action_type: ActionType) -> Self {
        Self {
            action_type,
            rationale: String::new(),
            expected_impact: None,
        }
    }

    /// Add a rationale for this action
    #[must_use]
    pub fn with_rationale(mut self, rationale: impl Into<String>) -> Self {
        self.rationale = rationale.into();
        self
    }

    /// Add expected impact
    #[must_use]
    pub fn with_expected_impact(mut self, impact: impl Into<String>) -> Self {
        self.expected_impact = Some(impact.into());
        self
    }
}

// =============================================================================
// ConfigChange - Record of Configuration Change
// =============================================================================

/// Record of a configuration change for rollback support.
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct ConfigChange {
    /// Node that was modified
    pub node: String,
    /// Type of change that was made
    pub change_type: ConfigChangeType,
    /// Previous configuration (for rollback)
    pub previous_config: Option<serde_json::Value>,
    /// New configuration (after change)
    pub new_config: serde_json::Value,
    /// Timestamp of the change
    pub timestamp: DateTime<Utc>,
}

impl ConfigChange {
    /// Create a new config change record
    #[must_use]
    pub fn new(
        node: impl Into<String>,
        change_type: ConfigChangeType,
        previous: Option<serde_json::Value>,
        new_config: serde_json::Value,
    ) -> Self {
        Self {
            node: node.into(),
            change_type,
            previous_config: previous,
            new_config,
            timestamp: Utc::now(),
        }
    }
}

// =============================================================================
// ConfigChangeType - Type of Configuration Change
// =============================================================================

/// Type of configuration change.
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub enum ConfigChangeType {
    /// Prompt was updated
    PromptUpdate,
    /// A specific parameter was updated.
    ParameterUpdate {
        /// Name of the parameter that was updated.
        param: String,
    },
    /// Entire config was replaced
    ConfigReplace,
    /// New config was added
    ConfigAdd,
    /// Config was removed
    ConfigRemove,
}

// =============================================================================
// ApplyResult - Result of Applying Plan
// =============================================================================

/// Result of applying an execution plan to a graph.
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct ApplyResult {
    /// ID of the plan that was applied
    pub plan_id: Uuid,
    /// List of changes that were made
    pub applied_changes: Vec<ConfigChange>,
    /// Nodes that were skipped (e.g., not found)
    pub skipped_nodes: Vec<String>,
    /// Warnings encountered during application
    pub warnings: Vec<String>,
    /// Whether the application was successful
    pub success: bool,
    /// Timestamp of application
    pub applied_at: DateTime<Utc>,
}

impl ApplyResult {
    /// Create a new successful apply result
    #[must_use]
    pub fn success(plan_id: Uuid, changes: Vec<ConfigChange>) -> Self {
        Self {
            plan_id,
            applied_changes: changes,
            skipped_nodes: Vec::new(),
            warnings: Vec::new(),
            success: true,
            applied_at: Utc::now(),
        }
    }

    /// Create a failed apply result
    #[must_use]
    pub fn failure(plan_id: Uuid, reason: impl Into<String>) -> Self {
        Self {
            plan_id,
            applied_changes: Vec::new(),
            skipped_nodes: Vec::new(),
            warnings: vec![reason.into()],
            success: false,
            applied_at: Utc::now(),
        }
    }

    /// Add a warning
    pub fn add_warning(&mut self, warning: impl Into<String>) {
        self.warnings.push(warning.into());
    }

    /// Add a skipped node
    pub fn add_skipped(&mut self, node: impl Into<String>) {
        self.skipped_nodes.push(node.into());
    }

    /// Get the number of changes applied
    #[must_use]
    pub fn change_count(&self) -> usize {
        self.applied_changes.len()
    }
}

// =============================================================================
// From Implementations
// =============================================================================

/// Convert an ImprovementProposal into an ExecutionPlan.
impl From<&ImprovementProposal> for ExecutionPlan {
    fn from(proposal: &ImprovementProposal) -> Self {
        let mut plan = ExecutionPlan::new(&proposal.title, PlanCategory::ApplicationImprovement);
        plan.description = proposal.description.clone();
        plan.citations = proposal.evidence.clone();
        plan.validation_score = proposal.initial_confidence;
        plan
    }
}

impl From<ImprovementProposal> for ExecutionPlan {
    fn from(proposal: ImprovementProposal) -> Self {
        ExecutionPlan::from(&proposal)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_execution_plan_creation() {
        let plan = ExecutionPlan::new("Add sentiment tool", PlanCategory::ApplicationImprovement)
            .with_description("Add a sentiment analysis tool")
            .with_priority(1)
            .with_estimated_commits(2)
            .with_steps(vec![
                ImplementationStep::new(1, "Create tool module")
                    .with_files(vec!["src/tools/sentiment.rs".to_string()])
                    .with_verification("cargo test"),
                ImplementationStep::new(2, "Add to graph")
                    .with_files(vec!["src/graph.rs".to_string()])
                    .with_verification("integration tests"),
            ])
            .with_success_criteria(vec![
                "Sentiment accuracy >= 90%".to_string(),
                "Latency < 100ms".to_string(),
            ])
            .validated(0.85);

        assert_eq!(plan.priority, 1);
        assert_eq!(plan.steps.len(), 2);
        assert_eq!(plan.validation_score, 0.85);
        assert!(matches!(plan.status, PlanStatus::Validated));
    }

    #[test]
    fn test_plan_category_from_str() {
        assert_eq!(
            PlanCategory::from("optimization"),
            PlanCategory::Optimization
        );
        assert_eq!(PlanCategory::from("prompt"), PlanCategory::Optimization);
        assert_eq!(
            PlanCategory::from("platform"),
            PlanCategory::PlatformImprovement
        );
        assert_eq!(PlanCategory::from("doc"), PlanCategory::ProcessImprovement);
        assert_eq!(
            PlanCategory::from("unknown"),
            PlanCategory::ApplicationImprovement
        );
    }

    #[test]
    fn test_action_type_target_node() {
        let action = ActionType::update_prompt("test_node", "new prompt");
        assert_eq!(action.target_node(), "test_node");
    }

    #[test]
    fn test_apply_result_success() {
        let plan_id = Uuid::new_v4();
        let result = ApplyResult::success(plan_id, vec![]);
        assert!(result.success);
        assert_eq!(result.plan_id, plan_id);
    }

    #[test]
    fn test_apply_result_failure() {
        let plan_id = Uuid::new_v4();
        let result = ApplyResult::failure(plan_id, "Node not found");
        assert!(!result.success);
        assert_eq!(result.warnings.len(), 1);
    }
}
