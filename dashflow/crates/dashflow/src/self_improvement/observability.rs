// Copyright 2026 Dropbox (created by Andrew Yates <ayates@dropbox.com>)

// Allow clippy warnings for observability module
// - expect_used/unwrap_used: Lock operations for global event bus
// - clone_on_ref_ptr/redundant_clone: Event handlers use Arc cloning
#![allow(clippy::expect_used, clippy::unwrap_used, clippy::clone_on_ref_ptr)]
#![allow(clippy::needless_pass_by_value, clippy::redundant_clone)]

//! Observability Module for Self-Improvement System.
//!
//! This module consolidates observability functionality:
//! - **Alerts**: Anomaly alert system with multiple handlers (console, file, webhook)
//! - **Events**: Event pub/sub system for component communication
//! - **Logging**: Structured tracing-based logging with debug mode support
//!
//! ## Quick Start
//!
//! ```rust,ignore
//! use dashflow::self_improvement::observability::{
//!     // Alerts
//!     Alert, AlertSeverity, AlertDispatcher, ConsoleAlertHandler,
//!     // Events
//!     Event, EventBus, EventType, global_event_bus,
//!     // Logging
//!     Component, log_operation_start, log_operation_success,
//! };
//!
//! // Create and dispatch an alert
//! let alert = Alert::new("High error rate", AlertSeverity::Warning);
//! let dispatcher = AlertDispatcher::new()
//!     .with_handler(Box::new(ConsoleAlertHandler::new()));
//! dispatcher.dispatch(&alert).await?;
//!
//! // Publish an event
//! global_event_bus().publish(Event::plan_created("plan-123", "Fix bug"));
//!
//! // Log with component context
//! log_operation_start(Component::Daemon, "analyze_traces");
//! ```

// =============================================================================
// Alerts Module (from alerts.rs)
// =============================================================================

pub mod alerts {
    //! Anomaly Alert System for Self-Improvement.
    //!
    //! This module provides an alert system for significant issues detected by the
    //! background analysis daemon. Alerts are generated from fired triggers and can
    //! be delivered through multiple handlers.

    use crate::self_improvement::daemon::{AnalysisTriggerType, FiredTrigger};
    use chrono::{DateTime, Utc};
    use serde::{Deserialize, Serialize};
    use std::collections::HashMap;
    use std::io::Write;
    use std::path::PathBuf;
    use std::sync::Arc;
    use tokio::sync::RwLock;
    use uuid::Uuid;

    /// Create a shared HTTP client for webhook requests with the specified timeout.
    #[must_use]
    fn create_webhook_client(timeout_secs: u64) -> reqwest::Client {
        reqwest::Client::builder()
            .timeout(std::time::Duration::from_secs(timeout_secs))
            .connect_timeout(std::time::Duration::from_secs(10))
            .pool_max_idle_per_host(5)
            .build()
            .unwrap_or_else(|_| reqwest::Client::new())
    }

    /// Severity level for alerts.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
    #[serde(rename_all = "lowercase")]
    pub enum AlertSeverity {
        /// Informational alert - no action required
        Info,
        /// Warning - potential issue that may need attention
        Warning,
        /// Error - significant issue requiring attention
        Error,
        /// Critical - severe issue requiring immediate action
        Critical,
    }

    impl AlertSeverity {
        /// Get the severity level as a string for display.
        #[must_use]
        pub fn as_str(&self) -> &'static str {
            match self {
                Self::Info => "INFO",
                Self::Warning => "WARNING",
                Self::Error => "ERROR",
                Self::Critical => "CRITICAL",
            }
        }

        /// Get ANSI color code for terminal display.
        #[must_use]
        pub fn color_code(&self) -> &'static str {
            match self {
                Self::Info => "\x1b[34m",     // Blue
                Self::Warning => "\x1b[33m",  // Yellow
                Self::Error => "\x1b[31m",    // Red
                Self::Critical => "\x1b[35m", // Magenta
            }
        }

        /// ANSI reset code.
        pub const RESET: &'static str = "\x1b[0m";
    }

    impl std::fmt::Display for AlertSeverity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.as_str())
        }
    }

    /// An anomaly alert generated by the self-improvement system.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Alert {
        /// Unique identifier for this alert
        pub id: Uuid,
        /// When the alert was created
        pub created_at: DateTime<Utc>,
        /// Alert severity level
        pub severity: AlertSeverity,
        /// Short summary of the alert
        pub title: String,
        /// Detailed description (optional)
        pub description: Option<String>,
        /// Source of the alert (e.g., "daemon:slow_node_trigger")
        pub source: Option<String>,
        /// Related trigger that caused this alert
        pub trigger_id: Option<Uuid>,
        /// Related trace IDs
        pub trace_ids: Vec<String>,
        /// Additional context as key-value pairs
        pub context: HashMap<String, String>,
        /// Suggested action to resolve the alert
        pub suggested_action: Option<String>,
        /// Whether this alert has been acknowledged
        pub acknowledged: bool,
        /// When the alert was acknowledged
        pub acknowledged_at: Option<DateTime<Utc>>,
    }

    impl Alert {
        /// Create a new alert with the given title and severity.
        #[must_use]
        pub fn new(title: impl Into<String>, severity: AlertSeverity) -> Self {
            Self {
                id: Uuid::new_v4(),
                created_at: Utc::now(),
                severity,
                title: title.into(),
                description: None,
                source: None,
                trigger_id: None,
                trace_ids: Vec::new(),
                context: HashMap::new(),
                suggested_action: None,
                acknowledged: false,
                acknowledged_at: None,
            }
        }

        /// Create an alert from a fired trigger.
        #[must_use]
        pub fn from_trigger(trigger: &FiredTrigger) -> Self {
            let (severity, title, description, suggested_action) = match &trigger.trigger_type {
                AnalysisTriggerType::SlowNode {
                    node_name,
                    duration_ms,
                    threshold_ms,
                } => {
                    // M-942 fix: Guard against division by zero for threshold_ms
                    let slowdown_ratio = if *threshold_ms > 0 {
                        *duration_ms as f64 / *threshold_ms as f64
                    } else {
                        f64::INFINITY // Threshold of 0 means any duration is infinitely slow
                    };
                    (
                        if *duration_ms > threshold_ms.saturating_mul(3) {
                            AlertSeverity::Error
                        } else {
                            AlertSeverity::Warning
                        },
                        format!("Slow node detected: '{}'", node_name),
                        Some(format!(
                            "Node '{}' took {}ms (threshold: {}ms). This is {:.1}x slower than expected.",
                            node_name, duration_ms, threshold_ms, slowdown_ratio
                        )),
                        Some(format!(
                            "Consider caching, parallelization, or breaking down '{}'",
                            node_name
                        )),
                    )
                }
                AnalysisTriggerType::HighErrorRate {
                    error_rate,
                    threshold,
                    sample_count,
                } => (
                    if *error_rate > threshold * 3.0 {
                        AlertSeverity::Critical
                    } else {
                        AlertSeverity::Error
                    },
                    format!("High error rate: {:.1}%", error_rate * 100.0),
                    Some(format!(
                        "Error rate of {:.1}% detected over {} executions (threshold: {:.1}%)",
                        error_rate * 100.0,
                        sample_count,
                        threshold * 100.0
                    )),
                    Some("Review recent errors, check for failing dependencies".to_string()),
                ),
                AnalysisTriggerType::RepeatedRetry {
                    operation,
                    retry_count,
                    threshold,
                } => (
                    AlertSeverity::Warning,
                    format!("Repeated retries: '{}'", operation),
                    Some(format!(
                        "Operation '{}' has failed {} times (threshold: {})",
                        operation, retry_count, threshold
                    )),
                    Some(format!(
                        "Investigate root cause of failures in '{}'",
                        operation
                    )),
                ),
                AnalysisTriggerType::UnusedCapability {
                    capability,
                    executions_since,
                    ..
                } => (
                    AlertSeverity::Info,
                    format!("Unused capability: '{}'", capability),
                    Some(format!(
                        "Capability '{}' has not been used in {} recent executions",
                        capability, executions_since
                    )),
                    Some(format!(
                        "Consider removing '{}' or documenting its purpose",
                        capability
                    )),
                ),
            };

            let mut alert = Self::new(title, severity);
            alert.description = description;
            alert.trigger_id = Some(trigger.id);
            alert.trace_ids = trigger.trace_ids.clone();
            alert.suggested_action = suggested_action;
            alert.source = Some(format!(
                "daemon:{}",
                match &trigger.trigger_type {
                    AnalysisTriggerType::SlowNode { .. } => "slow_node_trigger",
                    AnalysisTriggerType::HighErrorRate { .. } => "high_error_rate_trigger",
                    AnalysisTriggerType::RepeatedRetry { .. } => "repeated_retry_trigger",
                    AnalysisTriggerType::UnusedCapability { .. } => "unused_capability_trigger",
                }
            ));

            // Add trigger-specific context
            match &trigger.trigger_type {
                AnalysisTriggerType::SlowNode {
                    node_name,
                    duration_ms,
                    threshold_ms,
                } => {
                    alert
                        .context
                        .insert("node_name".to_string(), node_name.clone());
                    alert
                        .context
                        .insert("duration_ms".to_string(), duration_ms.to_string());
                    alert
                        .context
                        .insert("threshold_ms".to_string(), threshold_ms.to_string());
                }
                AnalysisTriggerType::HighErrorRate {
                    error_rate,
                    threshold,
                    sample_count,
                } => {
                    alert
                        .context
                        .insert("error_rate".to_string(), format!("{:.4}", error_rate));
                    alert
                        .context
                        .insert("threshold".to_string(), format!("{:.4}", threshold));
                    alert
                        .context
                        .insert("sample_count".to_string(), sample_count.to_string());
                }
                AnalysisTriggerType::RepeatedRetry {
                    operation,
                    retry_count,
                    threshold,
                } => {
                    alert
                        .context
                        .insert("operation".to_string(), operation.clone());
                    alert
                        .context
                        .insert("retry_count".to_string(), retry_count.to_string());
                    alert
                        .context
                        .insert("threshold".to_string(), threshold.to_string());
                }
                AnalysisTriggerType::UnusedCapability {
                    capability,
                    available_since,
                    executions_since,
                } => {
                    alert
                        .context
                        .insert("capability".to_string(), capability.clone());
                    alert
                        .context
                        .insert("available_since".to_string(), available_since.to_rfc3339());
                    alert
                        .context
                        .insert("executions_since".to_string(), executions_since.to_string());
                }
            }

            alert
        }

        /// Add a description to the alert.
        #[must_use]
        pub fn with_description(mut self, description: impl Into<String>) -> Self {
            self.description = Some(description.into());
            self
        }

        /// Set the source of the alert.
        #[must_use]
        pub fn with_source(mut self, source: impl Into<String>) -> Self {
            self.source = Some(source.into());
            self
        }

        /// Add a context key-value pair.
        #[must_use]
        pub fn with_context(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
            self.context.insert(key.into(), value.into());
            self
        }

        /// Set the suggested action.
        #[must_use]
        pub fn with_suggested_action(mut self, action: impl Into<String>) -> Self {
            self.suggested_action = Some(action.into());
            self
        }

        /// Add related trace IDs.
        #[must_use]
        pub fn with_traces(mut self, trace_ids: Vec<String>) -> Self {
            self.trace_ids = trace_ids;
            self
        }

        /// Acknowledge the alert.
        pub fn acknowledge(&mut self) {
            self.acknowledged = true;
            self.acknowledged_at = Some(Utc::now());
        }

        /// Format the alert for console display.
        #[must_use]
        pub fn format_console(&self) -> String {
            let mut output = String::new();

            output.push_str(&format!(
                "{}[{}]{} {}\n",
                self.severity.color_code(),
                self.severity.as_str(),
                AlertSeverity::RESET,
                self.title
            ));

            output.push_str(&format!(
                "  ID: {}  Time: {}\n",
                self.id,
                self.created_at.format("%Y-%m-%d %H:%M:%S UTC")
            ));

            if let Some(ref desc) = self.description {
                output.push_str(&format!("  {}\n", desc));
            }

            if let Some(ref source) = self.source {
                output.push_str(&format!("  Source: {}\n", source));
            }

            if let Some(ref action) = self.suggested_action {
                output.push_str(&format!("  Action: {}\n", action));
            }

            if !self.trace_ids.is_empty() {
                output.push_str(&format!("  Traces: {}\n", self.trace_ids.join(", ")));
            }

            output
        }

        /// Format the alert as a JSON string.
        pub fn to_json(&self) -> Result<String, serde_json::Error> {
            serde_json::to_string(self)
        }

        /// Format the alert as pretty JSON.
        pub fn to_json_pretty(&self) -> Result<String, serde_json::Error> {
            serde_json::to_string_pretty(self)
        }
    }

    /// Trait for handling alerts.
    #[async_trait::async_trait]
    pub trait AlertHandler: Send + Sync {
        /// Handle an alert.
        async fn handle(&self, alert: &Alert) -> Result<(), AlertError>;

        /// Get the handler name for logging.
        fn name(&self) -> &str;

        /// Check if the handler is enabled.
        fn is_enabled(&self) -> bool {
            true
        }
    }

    /// Error type for alert operations.
    #[derive(Debug)]
    pub struct AlertError {
        /// Error message
        pub message: String,
        /// Handler name that produced the error
        pub handler: Option<String>,
        /// Underlying cause (if any)
        pub cause: Option<Box<dyn std::error::Error + Send + Sync>>,
    }

    impl AlertError {
        /// Create a new alert error.
        #[must_use]
        pub fn new(message: impl Into<String>) -> Self {
            Self {
                message: message.into(),
                handler: None,
                cause: None,
            }
        }

        /// Create an error with handler context.
        #[must_use]
        pub fn from_handler(handler: &str, message: impl Into<String>) -> Self {
            Self {
                message: message.into(),
                handler: Some(handler.to_string()),
                cause: None,
            }
        }

        /// Add a cause to the error.
        #[must_use]
        pub fn with_cause<E: std::error::Error + Send + Sync + 'static>(
            mut self,
            cause: E,
        ) -> Self {
            self.cause = Some(Box::new(cause));
            self
        }
    }

    impl std::fmt::Display for AlertError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            if let Some(ref handler) = self.handler {
                write!(f, "[{}] {}", handler, self.message)?;
            } else {
                write!(f, "{}", self.message)?;
            }
            if let Some(ref cause) = self.cause {
                write!(f, ": {}", cause)?;
            }
            Ok(())
        }
    }

    impl std::error::Error for AlertError {
        fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
            self.cause
                .as_ref()
                .map(|e| e.as_ref() as &(dyn std::error::Error + 'static))
        }
    }

    /// Console alert handler that prints alerts to stdout.
    pub struct ConsoleAlertHandler {
        /// Whether to use ANSI color codes in output.
        use_colors: bool,
        /// Minimum severity level to display (alerts below this are filtered).
        min_severity: AlertSeverity,
    }

    impl ConsoleAlertHandler {
        /// Create a new console handler with default settings.
        #[must_use]
        pub fn new() -> Self {
            Self {
                use_colors: true,
                min_severity: AlertSeverity::Info,
            }
        }

        /// Disable colors in output.
        #[must_use]
        pub fn without_colors(mut self) -> Self {
            self.use_colors = false;
            self
        }

        /// Set minimum severity to display.
        #[must_use]
        pub fn with_min_severity(mut self, severity: AlertSeverity) -> Self {
            self.min_severity = severity;
            self
        }
    }

    impl Default for ConsoleAlertHandler {
        fn default() -> Self {
            Self::new()
        }
    }

    #[async_trait::async_trait]
    impl AlertHandler for ConsoleAlertHandler {
        async fn handle(&self, alert: &Alert) -> Result<(), AlertError> {
            if alert.severity < self.min_severity {
                return Ok(());
            }

            if self.use_colors {
                println!("{}", alert.format_console());
            } else {
                println!(
                    "[{}] {}\n  ID: {}  Time: {}",
                    alert.severity.as_str(),
                    alert.title,
                    alert.id,
                    alert.created_at.format("%Y-%m-%d %H:%M:%S UTC")
                );
                if let Some(ref desc) = alert.description {
                    println!("  {}", desc);
                }
                if let Some(ref action) = alert.suggested_action {
                    println!("  Action: {}", action);
                }
                println!();
            }
            Ok(())
        }

        fn name(&self) -> &str {
            "console"
        }
    }

    /// File alert handler that appends alerts to a file.
    pub struct FileAlertHandler {
        /// Path to the log file where alerts are appended.
        path: PathBuf,
        /// Whether to format alerts as JSON (true) or plain text (false).
        json_format: bool,
        /// Minimum severity level to log (alerts below this are filtered).
        min_severity: AlertSeverity,
    }

    impl FileAlertHandler {
        /// Create a new file handler.
        #[must_use]
        pub fn new(path: impl Into<PathBuf>) -> Self {
            Self {
                path: path.into(),
                json_format: true,
                min_severity: AlertSeverity::Info,
            }
        }

        /// Use plain text format instead of JSON.
        #[must_use]
        pub fn with_text_format(mut self) -> Self {
            self.json_format = false;
            self
        }

        /// Set minimum severity to log.
        #[must_use]
        pub fn with_min_severity(mut self, severity: AlertSeverity) -> Self {
            self.min_severity = severity;
            self
        }
    }

    #[async_trait::async_trait]
    impl AlertHandler for FileAlertHandler {
        async fn handle(&self, alert: &Alert) -> Result<(), AlertError> {
            if alert.severity < self.min_severity {
                return Ok(());
            }

            // Extract data for spawn_blocking (avoid blocking async runtime with std::fs)
            let path = self.path.clone();
            let json_format = self.json_format;

            // Prepare content before spawn_blocking
            let content = if json_format {
                let json = alert.to_json().map_err(|e| {
                    AlertError::from_handler(self.name(), "Failed to serialize").with_cause(e)
                })?;
                format!("{}\n", json)
            } else {
                format!(
                    "[{}] {} - {} - {}\n",
                    alert.created_at.format("%Y-%m-%d %H:%M:%S"),
                    alert.severity.as_str(),
                    alert.title,
                    alert.description.as_deref().unwrap_or("")
                )
            };

            // Perform all filesystem I/O in spawn_blocking to avoid blocking async runtime
            tokio::task::spawn_blocking(move || {
                if let Some(parent) = path.parent() {
                    std::fs::create_dir_all(parent).map_err(|e| {
                        AlertError::from_handler("file", "Failed to create directory").with_cause(e)
                    })?;
                }

                let mut file = std::fs::OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(&path)
                    .map_err(|e| {
                        AlertError::from_handler("file", "Failed to open file").with_cause(e)
                    })?;

                file.write_all(content.as_bytes()).map_err(|e| {
                    AlertError::from_handler("file", "Failed to write").with_cause(e)
                })?;

                Ok::<(), AlertError>(())
            })
            .await
            .map_err(|e| {
                AlertError::from_handler(self.name(), "Task join failed").with_cause(e)
            })??;

            Ok(())
        }

        fn name(&self) -> &str {
            "file"
        }
    }

    /// Webhook alert handler that POSTs alerts to a URL.
    pub struct WebhookAlertHandler {
        /// The webhook URL to POST alerts to.
        url: String,
        /// Optional Authorization header value.
        auth_header: Option<String>,
        /// Additional custom headers to include in requests.
        headers: HashMap<String, String>,
        /// Minimum severity level to send (alerts below this are filtered).
        min_severity: AlertSeverity,
        /// Request timeout in seconds.
        timeout_secs: u64,
        /// HTTP client for making requests.
        client: reqwest::Client,
    }

    impl WebhookAlertHandler {
        /// Create a new webhook handler.
        #[must_use]
        pub fn new(url: impl Into<String>) -> Self {
            Self {
                url: url.into(),
                auth_header: None,
                headers: HashMap::new(),
                min_severity: AlertSeverity::Warning,
                timeout_secs: 30,
                client: create_webhook_client(30),
            }
        }

        /// Create a new webhook handler with a shared HTTP client.
        ///
        /// Note: When using a shared client, the `with_timeout` method will rebuild
        /// the client with the new timeout, replacing the shared client.
        #[must_use]
        pub fn with_client(url: impl Into<String>, client: reqwest::Client) -> Self {
            Self {
                url: url.into(),
                auth_header: None,
                headers: HashMap::new(),
                min_severity: AlertSeverity::Warning,
                timeout_secs: 30,
                client,
            }
        }

        /// Set authorization header.
        #[must_use]
        pub fn with_auth(mut self, auth: impl Into<String>) -> Self {
            self.auth_header = Some(auth.into());
            self
        }

        /// Add a custom header.
        #[must_use]
        pub fn with_header(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
            self.headers.insert(key.into(), value.into());
            self
        }

        /// Set minimum severity to send.
        #[must_use]
        pub fn with_min_severity(mut self, severity: AlertSeverity) -> Self {
            self.min_severity = severity;
            self
        }

        /// Set request timeout in seconds.
        ///
        /// This rebuilds the internal HTTP client with the new timeout configuration.
        #[must_use]
        pub fn with_timeout(mut self, seconds: u64) -> Self {
            self.timeout_secs = seconds;
            // M-941 fix: Rebuild the client to apply the new timeout
            self.client = create_webhook_client(seconds);
            self
        }
    }

    #[async_trait::async_trait]
    impl AlertHandler for WebhookAlertHandler {
        async fn handle(&self, alert: &Alert) -> Result<(), AlertError> {
            if alert.severity < self.min_severity {
                return Ok(());
            }

            let mut request = self
                .client
                .post(&self.url)
                .header("Content-Type", "application/json");

            if let Some(ref auth) = self.auth_header {
                request = request.header("Authorization", auth);
            }

            for (key, value) in &self.headers {
                request = request.header(key, value);
            }

            let body = alert.to_json().map_err(|e| {
                AlertError::from_handler(self.name(), "Failed to serialize").with_cause(e)
            })?;

            let response = request.body(body).send().await.map_err(|e| {
                AlertError::from_handler(self.name(), "Failed to send request").with_cause(e)
            })?;

            if !response.status().is_success() {
                return Err(AlertError::from_handler(
                    self.name(),
                    format!("Webhook returned status {}", response.status()),
                ));
            }

            Ok(())
        }

        fn name(&self) -> &str {
            "webhook"
        }
    }

    /// Dispatches alerts to multiple handlers.
    pub struct AlertDispatcher {
        /// Registered alert handlers to dispatch to.
        handlers: Vec<Box<dyn AlertHandler>>,
        /// Whether to continue dispatching to remaining handlers after an error.
        continue_on_error: bool,
        /// Cache of recently dispatched alerts for deduplication (key -> timestamp).
        recent_alerts: Arc<RwLock<HashMap<String, DateTime<Utc>>>>,
        /// Time window in seconds for deduplicating identical alerts.
        dedup_window_secs: u64,
    }

    impl AlertDispatcher {
        /// Create a new dispatcher.
        #[must_use]
        pub fn new() -> Self {
            Self {
                handlers: Vec::new(),
                continue_on_error: true,
                recent_alerts: Arc::new(RwLock::new(HashMap::new())),
                dedup_window_secs: 300,
            }
        }

        /// Add a handler.
        #[must_use]
        pub fn with_handler(mut self, handler: Box<dyn AlertHandler>) -> Self {
            self.handlers.push(handler);
            self
        }

        /// Add a handler (mutable version).
        pub fn add_handler(&mut self, handler: Box<dyn AlertHandler>) {
            self.handlers.push(handler);
        }

        /// Stop on first handler error.
        #[must_use]
        pub fn fail_fast(mut self) -> Self {
            self.continue_on_error = false;
            self
        }

        /// Set deduplication window in seconds.
        #[must_use]
        pub fn with_dedup_window(mut self, seconds: u64) -> Self {
            self.dedup_window_secs = seconds;
            self
        }

        /// Dispatch an alert to all handlers.
        pub async fn dispatch(&self, alert: &Alert) -> Result<(), AlertError> {
            if self.is_duplicate(alert).await {
                return Ok(());
            }

            let mut errors = Vec::new();

            for handler in &self.handlers {
                if !handler.is_enabled() {
                    continue;
                }

                if let Err(e) = handler.handle(alert).await {
                    if self.continue_on_error {
                        errors.push(e);
                    } else {
                        return Err(e);
                    }
                }
            }

            self.mark_dispatched(alert).await;

            if errors.is_empty() {
                Ok(())
            } else {
                Err(AlertError::new(format!(
                    "{} handler(s) failed: {}",
                    errors.len(),
                    errors
                        .iter()
                        .map(|e| e.to_string())
                        .collect::<Vec<_>>()
                        .join("; ")
                )))
            }
        }

        /// Dispatch multiple alerts.
        pub async fn dispatch_all(&self, alerts: &[Alert]) -> Result<usize, AlertError> {
            let mut dispatched = 0;
            for alert in alerts {
                self.dispatch(alert).await?;
                dispatched += 1;
            }
            Ok(dispatched)
        }

        async fn is_duplicate(&self, alert: &Alert) -> bool {
            let key = format!(
                "{}:{}",
                alert.title,
                alert.source.as_deref().unwrap_or("unknown")
            );

            let recent = self.recent_alerts.read().await;
            if let Some(last_seen) = recent.get(&key) {
                let age = Utc::now().signed_duration_since(*last_seen);
                // M-944 fix: Safe u64->i64 conversion with saturation
                let window_secs = i64::try_from(self.dedup_window_secs).unwrap_or(i64::MAX);
                return age.num_seconds() < window_secs;
            }
            false
        }

        async fn mark_dispatched(&self, alert: &Alert) {
            let key = format!(
                "{}:{}",
                alert.title,
                alert.source.as_deref().unwrap_or("unknown")
            );

            let mut recent = self.recent_alerts.write().await;
            recent.insert(key, Utc::now());

            // M-944 fix: Safe u64->i64 conversion with saturation to prevent overflow
            let window_secs = i64::try_from(self.dedup_window_secs).unwrap_or(i64::MAX / 2);
            let cutoff_secs = window_secs.saturating_mul(2);
            let cutoff = Utc::now() - chrono::Duration::seconds(cutoff_secs);
            recent.retain(|_, v| *v > cutoff);
        }

        /// Get handler count.
        #[must_use]
        pub fn handler_count(&self) -> usize {
            self.handlers.len()
        }
    }

    impl Default for AlertDispatcher {
        fn default() -> Self {
            Self::new()
        }
    }

    /// Run alert-enabled daemon from CLI.
    pub async fn run_alerts_daemon_cli(
        interval_seconds: Option<u64>,
        storage_path: Option<&str>,
        alert_file: Option<&str>,
        alert_webhook: Option<&str>,
        once: bool,
        json_output: bool,
    ) -> Result<(), AlertError> {
        use crate::self_improvement::daemon::run_daemon_cli;

        let mut dispatcher = AlertDispatcher::new();

        if !json_output {
            dispatcher.add_handler(Box::new(ConsoleAlertHandler::new()));
        }

        if let Some(path) = alert_file {
            dispatcher.add_handler(Box::new(FileAlertHandler::new(path)));
        }

        if let Some(url) = alert_webhook {
            dispatcher.add_handler(Box::new(WebhookAlertHandler::new(url)));
        }

        if once {
            let result =
                run_daemon_cli(interval_seconds, storage_path, true).map_err(AlertError::new)?;

            for trigger in &result.triggers_fired {
                let alert = Alert::from_trigger(trigger);
                dispatcher.dispatch(&alert).await?;
            }

            if json_output {
                let output = DaemonCycleJson {
                    traces_analyzed: result.traces_analyzed,
                    triggers_fired: result.triggers_fired.len(),
                    plans_generated: result.plans_generated.len(),
                    errors: result.errors,
                };
                println!(
                    "{}",
                    serde_json::to_string_pretty(&output)
                        .map_err(|e| AlertError::new(format!("Failed to serialize: {}", e)))?
                );
            }
        } else {
            println!("Starting alert-enabled daemon...");
            println!("Press Ctrl+C to stop.");
            println!();

            loop {
                let result = run_daemon_cli(interval_seconds, storage_path, true)
                    .map_err(AlertError::new)?;

                for trigger in &result.triggers_fired {
                    let alert = Alert::from_trigger(trigger);
                    dispatcher.dispatch(&alert).await?;
                }

                let interval = interval_seconds.unwrap_or(60);
                tokio::time::sleep(std::time::Duration::from_secs(interval)).await;
            }
        }

        Ok(())
    }

    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    struct DaemonCycleJson {
        traces_analyzed: usize,
        triggers_fired: usize,
        plans_generated: usize,
        errors: Vec<String>,
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::self_improvement::daemon::{AnalysisTriggerType, FiredTrigger};

        #[test]
        fn test_alert_creation() {
            let alert = Alert::new("Test alert", AlertSeverity::Warning)
                .with_description("This is a test")
                .with_source("test")
                .with_context("key", "value")
                .with_suggested_action("Do something");

            assert_eq!(alert.title, "Test alert");
            assert_eq!(alert.severity, AlertSeverity::Warning);
            assert_eq!(alert.description, Some("This is a test".to_string()));
            assert_eq!(alert.source, Some("test".to_string()));
            assert_eq!(alert.context.get("key"), Some(&"value".to_string()));
            assert_eq!(alert.suggested_action, Some("Do something".to_string()));
        }

        #[test]
        fn test_alert_from_slow_node_trigger() {
            let trigger = FiredTrigger::new(AnalysisTriggerType::SlowNode {
                node_name: "llm_call".to_string(),
                duration_ms: 15000,
                threshold_ms: 10000,
            });

            let alert = Alert::from_trigger(&trigger);

            assert!(alert.title.contains("llm_call"));
            assert_eq!(alert.severity, AlertSeverity::Warning);
            assert!(alert.description.is_some());
            assert!(alert.suggested_action.is_some());
            assert_eq!(
                alert.context.get("node_name"),
                Some(&"llm_call".to_string())
            );
        }

        #[test]
        fn test_alert_severity_ordering() {
            assert!(AlertSeverity::Info < AlertSeverity::Warning);
            assert!(AlertSeverity::Warning < AlertSeverity::Error);
            assert!(AlertSeverity::Error < AlertSeverity::Critical);
        }

        /// M-942: Test that zero threshold doesn't cause division by zero panic
        #[test]
        fn test_alert_from_slow_node_zero_threshold() {
            let trigger = FiredTrigger::new(AnalysisTriggerType::SlowNode {
                node_name: "test_node".to_string(),
                duration_ms: 1000,
                threshold_ms: 0, // Zero threshold
            });

            // Should not panic - uses f64::INFINITY for ratio
            let alert = Alert::from_trigger(&trigger);

            assert!(alert.title.contains("test_node"));
            // With threshold 0, any duration > 0*3 = 0 triggers Error severity
            assert_eq!(alert.severity, AlertSeverity::Error);
            // Description should contain "inf" for infinity ratio
            assert!(alert.description.as_ref().unwrap().contains("inf"));
        }

        #[tokio::test]
        async fn test_console_handler() {
            let handler = ConsoleAlertHandler::new().without_colors();
            let alert = Alert::new("Test", AlertSeverity::Warning);
            handler.handle(&alert).await.unwrap();
        }

        #[tokio::test]
        async fn test_file_handler() {
            let temp_dir = tempfile::tempdir().unwrap();
            let file_path = temp_dir.path().join("alerts.log");

            let handler = FileAlertHandler::new(&file_path);
            let alert = Alert::new("Test", AlertSeverity::Warning);

            handler.handle(&alert).await.unwrap();

            let content = tokio::fs::read_to_string(&file_path).await.unwrap();
            assert!(content.contains("Test"));
        }

        #[tokio::test]
        async fn test_dispatcher() {
            let temp_dir = tempfile::tempdir().unwrap();
            let file_path = temp_dir.path().join("alerts.log");

            let dispatcher =
                AlertDispatcher::new().with_handler(Box::new(FileAlertHandler::new(&file_path)));

            let alert = Alert::new("Test", AlertSeverity::Warning);
            dispatcher.dispatch(&alert).await.unwrap();

            assert_eq!(dispatcher.handler_count(), 1);
        }

        // =========================================================================
        // Additional Tests for M-60 Coverage (Worker #1872)
        // =========================================================================

        #[test]
        fn test_alert_severity_as_str() {
            assert_eq!(AlertSeverity::Info.as_str(), "INFO");
            assert_eq!(AlertSeverity::Warning.as_str(), "WARNING");
            assert_eq!(AlertSeverity::Error.as_str(), "ERROR");
            assert_eq!(AlertSeverity::Critical.as_str(), "CRITICAL");
        }

        #[test]
        fn test_alert_severity_color_code() {
            // Verify each severity has a distinct ANSI color code
            let info_color = AlertSeverity::Info.color_code();
            let warning_color = AlertSeverity::Warning.color_code();
            let error_color = AlertSeverity::Error.color_code();
            let critical_color = AlertSeverity::Critical.color_code();

            // Colors should start with ANSI escape sequence
            assert!(info_color.starts_with("\x1b["));
            assert!(warning_color.starts_with("\x1b["));
            assert!(error_color.starts_with("\x1b["));
            assert!(critical_color.starts_with("\x1b["));
        }

        #[test]
        fn test_alert_from_high_error_rate_trigger() {
            let trigger = FiredTrigger::new(AnalysisTriggerType::HighErrorRate {
                error_rate: 0.25,
                threshold: 0.1,
                sample_count: 100,
            });

            let alert = Alert::from_trigger(&trigger);

            assert!(alert.title.contains("error rate"));
            assert_eq!(alert.severity, AlertSeverity::Error);
            assert!(alert.description.is_some());
        }

        #[test]
        fn test_alert_from_repeated_retry_trigger() {
            let trigger = FiredTrigger::new(AnalysisTriggerType::RepeatedRetry {
                operation: "api_call".to_string(),
                retry_count: 5,
                threshold: 3,
            });

            let alert = Alert::from_trigger(&trigger);

            assert!(alert.title.contains("api_call") || alert.title.contains("Repeated"));
            assert!(alert.description.is_some());
        }

        #[test]
        fn test_alert_builder_chain() {
            let alert = Alert::new("Test", AlertSeverity::Info)
                .with_description("desc1")
                .with_source("src1")
                .with_suggested_action("action1")
                .with_context("key1", "val1")
                .with_context("key2", "val2");

            assert_eq!(alert.title, "Test");
            assert_eq!(alert.severity, AlertSeverity::Info);
            assert_eq!(alert.description.as_deref(), Some("desc1"));
            assert_eq!(alert.source.as_deref(), Some("src1"));
            assert_eq!(alert.suggested_action.as_deref(), Some("action1"));
            assert_eq!(alert.context.len(), 2);
            assert_eq!(alert.context.get("key1"), Some(&"val1".to_string()));
            assert_eq!(alert.context.get("key2"), Some(&"val2".to_string()));
        }

        #[test]
        fn test_alert_has_unique_id() {
            let alert1 = Alert::new("Test1", AlertSeverity::Info);
            let alert2 = Alert::new("Test2", AlertSeverity::Info);

            // Each alert should have a unique ID (UUIDs)
            assert_ne!(alert1.id, alert2.id);
            // Verify UUIDs are not nil
            assert!(!alert1.id.is_nil());
            assert!(!alert2.id.is_nil());
        }

        #[tokio::test]
        async fn test_dispatcher_multiple_handlers() {
            let temp_dir = tempfile::tempdir().unwrap();
            let file_path1 = temp_dir.path().join("alerts1.log");
            let file_path2 = temp_dir.path().join("alerts2.log");

            let dispatcher = AlertDispatcher::new()
                .with_handler(Box::new(FileAlertHandler::new(&file_path1)))
                .with_handler(Box::new(FileAlertHandler::new(&file_path2)));

            assert_eq!(dispatcher.handler_count(), 2);

            let alert = Alert::new("Test Multi", AlertSeverity::Warning);
            dispatcher.dispatch(&alert).await.unwrap();

            // Both files should have content
            let content1 = tokio::fs::read_to_string(&file_path1).await.unwrap();
            let content2 = tokio::fs::read_to_string(&file_path2).await.unwrap();
            assert!(content1.contains("Test Multi"));
            assert!(content2.contains("Test Multi"));
        }

        #[test]
        fn test_console_handler_colors_toggle() {
            let handler_with_colors = ConsoleAlertHandler::new();
            let handler_without_colors = ConsoleAlertHandler::new().without_colors();

            // Can't easily assert on colors, but at least verify it compiles
            // and the handler can be created in both modes
            assert!(std::mem::size_of_val(&handler_with_colors) > 0);
            assert!(std::mem::size_of_val(&handler_without_colors) > 0);
        }

        #[test]
        fn test_alert_serialization_roundtrip() {
            let alert = Alert::new("Serialization Test", AlertSeverity::Warning)
                .with_description("Testing serde")
                .with_source("test")
                .with_context("key", "value");

            let json = serde_json::to_string(&alert).unwrap();
            let deserialized: Alert = serde_json::from_str(&json).unwrap();

            assert_eq!(deserialized.id, alert.id);
            assert_eq!(deserialized.title, alert.title);
            assert_eq!(deserialized.severity, alert.severity);
            assert_eq!(deserialized.description, alert.description);
            assert_eq!(deserialized.source, alert.source);
            assert_eq!(deserialized.context, alert.context);
        }

        #[test]
        fn test_alert_severity_serde_lowercase() {
            // Verify that serde uses lowercase for AlertSeverity
            let severity = AlertSeverity::Warning;
            let json = serde_json::to_string(&severity).unwrap();
            assert_eq!(json, "\"warning\"");

            let parsed: AlertSeverity = serde_json::from_str("\"critical\"").unwrap();
            assert_eq!(parsed, AlertSeverity::Critical);
        }
    }
}

// =============================================================================
// Events Module (from events.rs)
// =============================================================================

pub mod events {
    //! Event pub/sub system for the Self-Improvement module.

    use chrono::{DateTime, Utc};
    use serde::{Deserialize, Serialize};
    use std::collections::{HashMap, VecDeque};
    use std::fmt;
    use std::sync::RwLock;

    use crate::self_improvement::types::{ExecutionPlan, Hypothesis, PlanStatus};

    /// Types of events that can be published.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum EventType {
        /// A new improvement plan was created.
        PlanCreated,
        /// An improvement plan was approved for implementation.
        PlanApproved,
        /// Implementation of an approved plan has started.
        PlanImplementationStarted,
        /// An improvement plan was successfully implemented.
        PlanImplemented,
        /// An improvement plan failed during implementation.
        PlanFailed,
        /// A plan was replaced by a newer, better plan.
        PlanSuperseded,
        /// A new hypothesis was created for evaluation.
        HypothesisCreated,
        /// Evaluation of a hypothesis has started.
        HypothesisEvaluationStarted,
        /// A hypothesis was evaluated with a result.
        HypothesisEvaluated,
        /// Trace analysis has started.
        AnalysisStarted,
        /// Trace analysis has completed.
        AnalysisCompleted,
        /// An analysis trigger condition was met.
        TriggerFired,
        /// Storage cleanup operation completed.
        StorageCleanup,
        /// Database schema migration occurred.
        SchemaMigration,
        /// Storage health status changed.
        StorageHealthChanged,
        /// An alert was fired.
        AlertFired,
        /// An alert was acknowledged by a user/system.
        AlertAcknowledged,
        /// The background daemon started.
        DaemonStarted,
        /// The background daemon stopped.
        DaemonStopped,
        /// A daemon analysis cycle completed.
        DaemonCycleCompleted,
        /// Multi-agent consensus process started.
        ConsensusStarted,
        /// Multi-agent consensus process completed.
        ConsensusCompleted,
        /// A custom event type.
        Custom,
    }

    impl fmt::Display for EventType {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let name = match self {
                Self::PlanCreated => "plan.created",
                Self::PlanApproved => "plan.approved",
                Self::PlanImplementationStarted => "plan.implementation_started",
                Self::PlanImplemented => "plan.implemented",
                Self::PlanFailed => "plan.failed",
                Self::PlanSuperseded => "plan.superseded",
                Self::HypothesisCreated => "hypothesis.created",
                Self::HypothesisEvaluationStarted => "hypothesis.evaluation_started",
                Self::HypothesisEvaluated => "hypothesis.evaluated",
                Self::AnalysisStarted => "analysis.started",
                Self::AnalysisCompleted => "analysis.completed",
                Self::TriggerFired => "trigger.fired",
                Self::StorageCleanup => "storage.cleanup",
                Self::SchemaMigration => "storage.migration",
                Self::StorageHealthChanged => "storage.health_changed",
                Self::AlertFired => "alert.fired",
                Self::AlertAcknowledged => "alert.acknowledged",
                Self::DaemonStarted => "daemon.started",
                Self::DaemonStopped => "daemon.stopped",
                Self::DaemonCycleCompleted => "daemon.cycle_completed",
                Self::ConsensusStarted => "consensus.started",
                Self::ConsensusCompleted => "consensus.completed",
                Self::Custom => "custom",
            };
            write!(f, "{}", name)
        }
    }

    /// Data associated with an event.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum EventData {
        /// Data for plan-related events.
        Plan {
            /// Unique identifier of the plan.
            plan_id: String,
            /// Title/summary of the plan.
            title: String,
            /// Current status of the plan.
            #[serde(skip_serializing_if = "Option::is_none")]
            status: Option<PlanStatus>,
            /// Reason for status change (e.g., failure reason).
            #[serde(skip_serializing_if = "Option::is_none")]
            reason: Option<String>,
        },
        /// Data for hypothesis-related events.
        Hypothesis {
            /// Unique identifier of the hypothesis.
            hypothesis_id: String,
            /// The hypothesis statement being tested.
            statement: String,
            /// Evaluation outcome (if evaluated).
            #[serde(skip_serializing_if = "Option::is_none")]
            outcome: Option<String>,
        },
        /// Data for analysis-related events.
        Analysis {
            /// Number of traces analyzed.
            #[serde(skip_serializing_if = "Option::is_none")]
            trace_count: Option<usize>,
            /// Duration of analysis in milliseconds.
            #[serde(skip_serializing_if = "Option::is_none")]
            duration_ms: Option<u64>,
            /// Number of capability gaps found.
            #[serde(skip_serializing_if = "Option::is_none")]
            gaps_found: Option<usize>,
            /// Number of improvement plans generated.
            #[serde(skip_serializing_if = "Option::is_none")]
            plans_generated: Option<usize>,
        },
        /// Data for trigger-related events.
        Trigger {
            /// Type of trigger that fired.
            trigger_type: String,
            /// Node name (for node-specific triggers).
            node: Option<String>,
            /// Observed value that triggered the alert.
            value: Option<f64>,
            /// Threshold that was exceeded.
            threshold: Option<f64>,
        },
        /// Data for storage-related events.
        Storage {
            /// Storage operation performed.
            operation: String,
            /// Number of items affected by the operation.
            #[serde(skip_serializing_if = "Option::is_none")]
            items_affected: Option<usize>,
            /// Bytes freed by cleanup operations.
            #[serde(skip_serializing_if = "Option::is_none")]
            bytes_freed: Option<u64>,
        },
        /// Data for alert-related events.
        Alert {
            /// Unique identifier of the alert.
            alert_id: String,
            /// Severity level of the alert.
            severity: String,
            /// Alert message content.
            message: String,
        },
        /// Data for daemon-related events.
        Daemon {
            /// Current cycle number of the daemon.
            #[serde(skip_serializing_if = "Option::is_none")]
            cycle_number: Option<u64>,
            /// Number of triggers fired in this cycle.
            #[serde(skip_serializing_if = "Option::is_none")]
            triggers_fired: Option<usize>,
        },
        /// Data for consensus-related events.
        Consensus {
            /// Plan being reviewed for consensus.
            #[serde(skip_serializing_if = "Option::is_none")]
            plan_id: Option<String>,
            /// Number of reviewers participating.
            #[serde(skip_serializing_if = "Option::is_none")]
            reviewers: Option<usize>,
            /// Whether consensus was reached.
            #[serde(skip_serializing_if = "Option::is_none")]
            agreed: Option<bool>,
        },
        /// Data for custom events.
        Custom {
            /// Type name for the custom event.
            type_name: String,
            /// JSON-serialized custom data.
            data: String,
        },
        /// No event data.
        None,
    }

    /// An event that can be published and subscribed to.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Event {
        /// Unique identifier for this event.
        pub id: String,
        /// The type/category of this event.
        pub event_type: EventType,
        /// When this event was created.
        pub timestamp: DateTime<Utc>,
        /// Event-specific data payload.
        pub data: EventData,
        /// Component that generated this event.
        pub source: String,
        /// Optional ID to correlate related events.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub correlation_id: Option<String>,
    }

    impl Event {
        /// Creates a new event.
        #[must_use]
        pub fn new(event_type: EventType, data: EventData) -> Self {
            Self {
                id: uuid::Uuid::new_v4().to_string(),
                event_type,
                timestamp: Utc::now(),
                data,
                source: "self_improvement".to_string(),
                correlation_id: None,
            }
        }

        /// Sets the source component.
        #[must_use]
        pub fn with_source(mut self, source: impl Into<String>) -> Self {
            self.source = source.into();
            self
        }

        /// Sets the correlation ID.
        #[must_use]
        pub fn with_correlation_id(mut self, id: impl Into<String>) -> Self {
            self.correlation_id = Some(id.into());
            self
        }

        /// Creates a plan created event.
        #[must_use]
        pub fn plan_created(plan_id: impl Into<String>, title: impl Into<String>) -> Self {
            Self::new(
                EventType::PlanCreated,
                EventData::Plan {
                    plan_id: plan_id.into(),
                    title: title.into(),
                    status: Some(PlanStatus::Proposed),
                    reason: None,
                },
            )
        }

        /// Creates a plan created event from an ExecutionPlan.
        #[must_use]
        pub fn plan_created_from(plan: &ExecutionPlan) -> Self {
            Self::new(
                EventType::PlanCreated,
                EventData::Plan {
                    plan_id: plan.id.to_string(),
                    title: plan.title.clone(),
                    status: Some(plan.status.clone()),
                    reason: None,
                },
            )
        }

        /// Creates a plan approved event.
        #[must_use]
        pub fn plan_approved(plan_id: impl Into<String>, title: impl Into<String>) -> Self {
            Self::new(
                EventType::PlanApproved,
                EventData::Plan {
                    plan_id: plan_id.into(),
                    title: title.into(),
                    status: Some(PlanStatus::Validated),
                    reason: None,
                },
            )
        }

        /// Creates a plan implemented event.
        #[must_use]
        pub fn plan_implemented(plan_id: impl Into<String>, title: impl Into<String>) -> Self {
            Self::new(
                EventType::PlanImplemented,
                EventData::Plan {
                    plan_id: plan_id.into(),
                    title: title.into(),
                    status: Some(PlanStatus::Implemented {
                        completed: Utc::now(),
                        commit_hash: String::new(),
                    }),
                    reason: None,
                },
            )
        }

        /// Creates a plan failed event.
        #[must_use]
        pub fn plan_failed(
            plan_id: impl Into<String>,
            title: impl Into<String>,
            reason: impl Into<String>,
        ) -> Self {
            let reason_str = reason.into();
            Self::new(
                EventType::PlanFailed,
                EventData::Plan {
                    plan_id: plan_id.into(),
                    title: title.into(),
                    status: Some(PlanStatus::Failed {
                        reason: reason_str.clone(),
                    }),
                    reason: Some(reason_str),
                },
            )
        }

        /// Creates a hypothesis created event.
        #[must_use]
        pub fn hypothesis_created(
            hypothesis_id: impl Into<String>,
            statement: impl Into<String>,
        ) -> Self {
            Self::new(
                EventType::HypothesisCreated,
                EventData::Hypothesis {
                    hypothesis_id: hypothesis_id.into(),
                    statement: statement.into(),
                    outcome: None,
                },
            )
        }

        /// Creates a hypothesis created event from a Hypothesis.
        #[must_use]
        pub fn hypothesis_created_from(hypothesis: &Hypothesis) -> Self {
            Self::new(
                EventType::HypothesisCreated,
                EventData::Hypothesis {
                    hypothesis_id: hypothesis.id.to_string(),
                    statement: hypothesis.statement.clone(),
                    outcome: None,
                },
            )
        }

        /// Creates a hypothesis evaluated event.
        #[must_use]
        pub fn hypothesis_evaluated(
            hypothesis_id: impl Into<String>,
            statement: impl Into<String>,
            outcome: impl Into<String>,
        ) -> Self {
            Self::new(
                EventType::HypothesisEvaluated,
                EventData::Hypothesis {
                    hypothesis_id: hypothesis_id.into(),
                    statement: statement.into(),
                    outcome: Some(outcome.into()),
                },
            )
        }

        /// Creates an analysis started event.
        #[must_use]
        pub fn analysis_started(trace_count: usize) -> Self {
            Self::new(
                EventType::AnalysisStarted,
                EventData::Analysis {
                    trace_count: Some(trace_count),
                    duration_ms: None,
                    gaps_found: None,
                    plans_generated: None,
                },
            )
        }

        /// Creates an analysis completed event.
        #[must_use]
        pub fn analysis_completed(
            trace_count: usize,
            duration_ms: u64,
            gaps_found: usize,
            plans_generated: usize,
        ) -> Self {
            Self::new(
                EventType::AnalysisCompleted,
                EventData::Analysis {
                    trace_count: Some(trace_count),
                    duration_ms: Some(duration_ms),
                    gaps_found: Some(gaps_found),
                    plans_generated: Some(plans_generated),
                },
            )
        }

        /// Creates a trigger fired event.
        #[must_use]
        pub fn trigger_fired(
            trigger_type: impl Into<String>,
            node: Option<String>,
            value: Option<f64>,
            threshold: Option<f64>,
        ) -> Self {
            Self::new(
                EventType::TriggerFired,
                EventData::Trigger {
                    trigger_type: trigger_type.into(),
                    node,
                    value,
                    threshold,
                },
            )
        }

        /// Creates a storage cleanup event.
        #[must_use]
        pub fn storage_cleanup(items_affected: usize, bytes_freed: u64) -> Self {
            Self::new(
                EventType::StorageCleanup,
                EventData::Storage {
                    operation: "cleanup".to_string(),
                    items_affected: Some(items_affected),
                    bytes_freed: Some(bytes_freed),
                },
            )
        }

        /// Creates a schema migration event.
        #[must_use]
        pub fn schema_migration(from_version: u32, to_version: u32) -> Self {
            Self::new(
                EventType::SchemaMigration,
                EventData::Storage {
                    operation: format!("migrate_{}_{}", from_version, to_version),
                    items_affected: None,
                    bytes_freed: None,
                },
            )
        }

        /// Creates an alert fired event.
        #[must_use]
        pub fn alert_fired(
            alert_id: impl Into<String>,
            severity: impl Into<String>,
            message: impl Into<String>,
        ) -> Self {
            Self::new(
                EventType::AlertFired,
                EventData::Alert {
                    alert_id: alert_id.into(),
                    severity: severity.into(),
                    message: message.into(),
                },
            )
        }

        /// Creates a daemon started event.
        #[must_use]
        pub fn daemon_started() -> Self {
            Self::new(
                EventType::DaemonStarted,
                EventData::Daemon {
                    cycle_number: None,
                    triggers_fired: None,
                },
            )
        }

        /// Creates a daemon stopped event.
        #[must_use]
        pub fn daemon_stopped() -> Self {
            Self::new(
                EventType::DaemonStopped,
                EventData::Daemon {
                    cycle_number: None,
                    triggers_fired: None,
                },
            )
        }

        /// Creates a daemon cycle completed event.
        #[must_use]
        pub fn daemon_cycle_completed(cycle_number: u64, triggers_fired: usize) -> Self {
            Self::new(
                EventType::DaemonCycleCompleted,
                EventData::Daemon {
                    cycle_number: Some(cycle_number),
                    triggers_fired: Some(triggers_fired),
                },
            )
        }

        /// Creates a consensus started event.
        #[must_use]
        pub fn consensus_started(plan_id: impl Into<String>, reviewers: usize) -> Self {
            Self::new(
                EventType::ConsensusStarted,
                EventData::Consensus {
                    plan_id: Some(plan_id.into()),
                    reviewers: Some(reviewers),
                    agreed: None,
                },
            )
        }

        /// Creates a consensus completed event.
        #[must_use]
        pub fn consensus_completed(plan_id: impl Into<String>, agreed: bool) -> Self {
            Self::new(
                EventType::ConsensusCompleted,
                EventData::Consensus {
                    plan_id: Some(plan_id.into()),
                    reviewers: None,
                    agreed: Some(agreed),
                },
            )
        }

        /// Creates a custom event.
        pub fn custom<T: serde::Serialize>(
            type_name: impl Into<String>,
            value: &T,
        ) -> Result<Self, serde_json::Error> {
            let data = serde_json::to_string(value)?;
            Ok(Self::new(
                EventType::Custom,
                EventData::Custom {
                    type_name: type_name.into(),
                    data,
                },
            ))
        }
    }

    /// Trait for event handlers.
    pub trait EventHandler: Send + Sync {
        /// Handle an incoming event.
        fn handle(&self, event: &Event);
        /// Get the name of this handler for logging and identification.
        fn name(&self) -> &str;
    }

    type BoxedHandler = Box<dyn Fn(&Event) + Send + Sync>;

    struct NamedHandler {
        name: String,
        handler: BoxedHandler,
    }

    impl fmt::Debug for NamedHandler {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("NamedHandler")
                .field("name", &self.name)
                .finish()
        }
    }

    /// An event bus for publishing and subscribing to events.
    #[derive(Default)]
    pub struct EventBus {
        handlers: RwLock<HashMap<EventType, Vec<NamedHandler>>>,
        global_handlers: RwLock<Vec<NamedHandler>>,
        // M-943 fix: Use VecDeque for O(1) eviction from front instead of O(n) Vec::remove(0)
        history: RwLock<VecDeque<Event>>,
        max_history: usize,
    }

    impl fmt::Debug for EventBus {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            // SAFETY: Use poison-safe pattern - if a thread panicked while holding the lock,
            // we still want to be able to debug-print rather than crash
            let handlers = self.handlers.read().unwrap_or_else(|e| e.into_inner());
            let global = self
                .global_handlers
                .read()
                .unwrap_or_else(|e| e.into_inner());
            let history = self.history.read().unwrap_or_else(|e| e.into_inner());

            f.debug_struct("EventBus")
                .field("event_types", &handlers.len())
                .field("global_handlers", &global.len())
                .field("history_size", &history.len())
                .field("max_history", &self.max_history)
                .finish()
        }
    }

    impl EventBus {
        /// Creates a new event bus.
        #[must_use]
        pub fn new() -> Self {
            Self {
                handlers: RwLock::new(HashMap::new()),
                global_handlers: RwLock::new(Vec::new()),
                history: RwLock::new(VecDeque::new()),
                max_history: 1000,
            }
        }

        /// Creates a new event bus with custom history size.
        #[must_use]
        pub fn with_history_size(max_history: usize) -> Self {
            Self {
                handlers: RwLock::new(HashMap::new()),
                global_handlers: RwLock::new(Vec::new()),
                history: RwLock::new(VecDeque::new()),
                max_history,
            }
        }

        /// Subscribes to a specific event type.
        pub fn subscribe<F>(&self, event_type: EventType, name: impl Into<String>, handler: F)
        where
            F: Fn(&Event) + Send + Sync + 'static,
        {
            // SAFETY: Use poison-safe pattern
            let mut handlers = self.handlers.write().unwrap_or_else(|e| e.into_inner());
            handlers.entry(event_type).or_default().push(NamedHandler {
                name: name.into(),
                handler: Box::new(handler),
            });
        }

        /// Subscribes to all events.
        pub fn subscribe_all<F>(&self, name: impl Into<String>, handler: F)
        where
            F: Fn(&Event) + Send + Sync + 'static,
        {
            // SAFETY: Use poison-safe pattern
            let mut global = self
                .global_handlers
                .write()
                .unwrap_or_else(|e| e.into_inner());
            global.push(NamedHandler {
                name: name.into(),
                handler: Box::new(handler),
            });
        }

        /// Unsubscribes a handler by name from a specific event type.
        pub fn unsubscribe(&self, event_type: EventType, handler_name: &str) -> bool {
            // SAFETY: Use poison-safe pattern
            let mut handlers = self.handlers.write().unwrap_or_else(|e| e.into_inner());
            if let Some(type_handlers) = handlers.get_mut(&event_type) {
                let len_before = type_handlers.len();
                type_handlers.retain(|h| h.name != handler_name);
                return type_handlers.len() < len_before;
            }
            false
        }

        /// Unsubscribes a global handler by name.
        pub fn unsubscribe_all(&self, handler_name: &str) -> bool {
            // SAFETY: Use poison-safe pattern
            let mut global = self
                .global_handlers
                .write()
                .unwrap_or_else(|e| e.into_inner());
            let len_before = global.len();
            global.retain(|h| h.name != handler_name);
            global.len() < len_before
        }

        /// Publishes an event to all subscribers.
        pub fn publish(&self, event: Event) {
            {
                // SAFETY: Use poison-safe pattern
                let mut history = self.history.write().unwrap_or_else(|e| e.into_inner());
                history.push_back(event.clone());
                if history.len() > self.max_history {
                    // M-943: VecDeque::pop_front is O(1) vs Vec::remove(0) which is O(n)
                    history.pop_front();
                }
            }

            {
                // SAFETY: Use poison-safe pattern
                let handlers = self.handlers.read().unwrap_or_else(|e| e.into_inner());
                if let Some(type_handlers) = handlers.get(&event.event_type) {
                    for handler in type_handlers {
                        (handler.handler)(&event);
                    }
                }
            }

            {
                // SAFETY: Use poison-safe pattern
                let global = self
                    .global_handlers
                    .read()
                    .unwrap_or_else(|e| e.into_inner());
                for handler in global.iter() {
                    (handler.handler)(&event);
                }
            }
        }

        /// Returns the number of handlers for a specific event type.
        #[must_use]
        pub fn handler_count(&self, event_type: EventType) -> usize {
            // SAFETY: Use poison-safe pattern
            let handlers = self.handlers.read().unwrap_or_else(|e| e.into_inner());
            handlers.get(&event_type).map_or(0, |h| h.len())
        }

        /// Returns the total number of handlers (type-specific + global).
        #[must_use]
        pub fn total_handler_count(&self) -> usize {
            // SAFETY: Use poison-safe pattern
            let handlers = self.handlers.read().unwrap_or_else(|e| e.into_inner());
            let global = self
                .global_handlers
                .read()
                .unwrap_or_else(|e| e.into_inner());
            handlers.values().map(|h| h.len()).sum::<usize>() + global.len()
        }

        /// Returns recent events from history.
        #[must_use]
        pub fn recent_events(&self, limit: usize) -> Vec<Event> {
            // SAFETY: Use poison-safe pattern
            let history = self.history.read().unwrap_or_else(|e| e.into_inner());
            history.iter().rev().take(limit).cloned().collect()
        }

        /// Returns events of a specific type from history.
        #[must_use]
        pub fn events_by_type(&self, event_type: EventType, limit: usize) -> Vec<Event> {
            // SAFETY: Use poison-safe pattern
            let history = self.history.read().unwrap_or_else(|e| e.into_inner());
            history
                .iter()
                .rev()
                .filter(|e| e.event_type == event_type)
                .take(limit)
                .cloned()
                .collect()
        }

        /// Clears the event history.
        pub fn clear_history(&self) {
            // SAFETY: Use poison-safe pattern
            let mut history = self.history.write().unwrap_or_else(|e| e.into_inner());
            history.clear();
        }

        /// Returns the current history size.
        #[must_use]
        pub fn history_size(&self) -> usize {
            // SAFETY: Use poison-safe pattern
            let history = self.history.read().unwrap_or_else(|e| e.into_inner());
            history.len()
        }
    }

    /// Returns the global event bus instance.
    pub fn global_event_bus() -> &'static EventBus {
        static EVENT_BUS: std::sync::OnceLock<EventBus> = std::sync::OnceLock::new();
        EVENT_BUS.get_or_init(EventBus::new)
    }

    /// Publishes an event to the global event bus.
    pub fn publish(event: Event) {
        global_event_bus().publish(event);
    }

    /// Subscribes to a specific event type on the global event bus.
    pub fn subscribe<F>(event_type: EventType, name: impl Into<String>, handler: F)
    where
        F: Fn(&Event) + Send + Sync + 'static,
    {
        global_event_bus().subscribe(event_type, name, handler);
    }

    /// Subscribes to all events on the global event bus.
    pub fn subscribe_all<F>(name: impl Into<String>, handler: F)
    where
        F: Fn(&Event) + Send + Sync + 'static,
    {
        global_event_bus().subscribe_all(name, handler);
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::sync::atomic::{AtomicUsize, Ordering};
        use std::sync::Arc;

        #[test]
        fn test_event_creation() {
            let event = Event::plan_created("plan-123", "Fix bug");
            assert_eq!(event.event_type, EventType::PlanCreated);
            assert!(!event.id.is_empty());
        }

        #[test]
        fn test_event_bus_subscribe_publish() {
            let bus = EventBus::new();
            let counter = Arc::new(AtomicUsize::new(0));
            let counter_clone = counter.clone();

            bus.subscribe(EventType::PlanCreated, "test-handler", move |_event| {
                counter_clone.fetch_add(1, Ordering::SeqCst);
            });

            assert_eq!(bus.handler_count(EventType::PlanCreated), 1);

            bus.publish(Event::plan_created("plan-1", "Test Plan"));
            assert_eq!(counter.load(Ordering::SeqCst), 1);

            bus.publish(Event::plan_created("plan-2", "Test Plan 2"));
            assert_eq!(counter.load(Ordering::SeqCst), 2);

            bus.publish(Event::analysis_started(10));
            assert_eq!(counter.load(Ordering::SeqCst), 2);
        }

        #[test]
        fn test_event_type_display() {
            assert_eq!(EventType::PlanCreated.to_string(), "plan.created");
            assert_eq!(EventType::AnalysisStarted.to_string(), "analysis.started");
        }

        // =========================================================================
        // Additional Tests for M-60 Coverage (Worker #1872)
        // =========================================================================

        #[test]
        fn test_event_type_display_all_variants() {
            // Test all EventType variants have correct string representation
            assert_eq!(EventType::PlanApproved.to_string(), "plan.approved");
            assert_eq!(
                EventType::PlanImplementationStarted.to_string(),
                "plan.implementation_started"
            );
            assert_eq!(EventType::PlanImplemented.to_string(), "plan.implemented");
            assert_eq!(EventType::PlanFailed.to_string(), "plan.failed");
            assert_eq!(EventType::PlanSuperseded.to_string(), "plan.superseded");
            assert_eq!(EventType::HypothesisCreated.to_string(), "hypothesis.created");
            assert_eq!(
                EventType::HypothesisEvaluationStarted.to_string(),
                "hypothesis.evaluation_started"
            );
            assert_eq!(EventType::HypothesisEvaluated.to_string(), "hypothesis.evaluated");
            assert_eq!(EventType::AnalysisCompleted.to_string(), "analysis.completed");
            assert_eq!(EventType::TriggerFired.to_string(), "trigger.fired");
            assert_eq!(EventType::StorageCleanup.to_string(), "storage.cleanup");
            assert_eq!(EventType::SchemaMigration.to_string(), "storage.migration");
            assert_eq!(
                EventType::StorageHealthChanged.to_string(),
                "storage.health_changed"
            );
            assert_eq!(EventType::AlertFired.to_string(), "alert.fired");
            assert_eq!(EventType::AlertAcknowledged.to_string(), "alert.acknowledged");
            assert_eq!(EventType::DaemonStarted.to_string(), "daemon.started");
            assert_eq!(EventType::DaemonStopped.to_string(), "daemon.stopped");
            assert_eq!(
                EventType::DaemonCycleCompleted.to_string(),
                "daemon.cycle_completed"
            );
            assert_eq!(EventType::ConsensusStarted.to_string(), "consensus.started");
            assert_eq!(EventType::ConsensusCompleted.to_string(), "consensus.completed");
            assert_eq!(EventType::Custom.to_string(), "custom");
        }

        #[test]
        fn test_event_with_source_and_correlation_id() {
            let event = Event::plan_created("plan-1", "Test Plan")
                .with_source("test_source")
                .with_correlation_id("correlation-123");

            assert_eq!(event.source, "test_source");
            assert_eq!(event.correlation_id, Some("correlation-123".to_string()));
        }

        #[test]
        fn test_event_plan_convenience_methods() {
            // Test plan_approved
            let event = Event::plan_approved("plan-1", "Fix bug");
            assert_eq!(event.event_type, EventType::PlanApproved);

            // Test plan_failed
            let event = Event::plan_failed("plan-2", "Fix bug", "Test failed");
            assert_eq!(event.event_type, EventType::PlanFailed);
            if let EventData::Plan { reason, .. } = &event.data {
                assert_eq!(reason, &Some("Test failed".to_string()));
            } else {
                panic!("Expected Plan event data");
            }
        }

        #[test]
        fn test_event_hypothesis_created() {
            let event = Event::hypothesis_created("hyp-1", "Cache will improve latency");
            assert_eq!(event.event_type, EventType::HypothesisCreated);
            if let EventData::Hypothesis {
                hypothesis_id,
                statement,
                ..
            } = &event.data
            {
                assert_eq!(hypothesis_id, "hyp-1");
                assert_eq!(statement, "Cache will improve latency");
            } else {
                panic!("Expected Hypothesis event data");
            }
        }

        #[test]
        fn test_event_analysis_started_and_completed() {
            let start_event = Event::analysis_started(100);
            assert_eq!(start_event.event_type, EventType::AnalysisStarted);

            let complete_event = Event::analysis_completed(100, 5000, 3, 2);
            assert_eq!(complete_event.event_type, EventType::AnalysisCompleted);

            if let EventData::Analysis {
                trace_count,
                duration_ms,
                gaps_found,
                plans_generated,
            } = &complete_event.data
            {
                assert_eq!(trace_count, &Some(100));
                assert_eq!(duration_ms, &Some(5000));
                assert_eq!(gaps_found, &Some(3));
                assert_eq!(plans_generated, &Some(2));
            } else {
                panic!("Expected Analysis event data");
            }
        }

        #[test]
        fn test_event_daemon_events() {
            let start = Event::daemon_started();
            assert_eq!(start.event_type, EventType::DaemonStarted);

            let stop = Event::daemon_stopped();
            assert_eq!(stop.event_type, EventType::DaemonStopped);

            let cycle = Event::daemon_cycle_completed(5, 3);
            assert_eq!(cycle.event_type, EventType::DaemonCycleCompleted);

            if let EventData::Daemon {
                cycle_number,
                triggers_fired,
            } = &cycle.data
            {
                assert_eq!(cycle_number, &Some(5));
                assert_eq!(triggers_fired, &Some(3));
            } else {
                panic!("Expected Daemon event data");
            }
        }

        #[test]
        fn test_event_bus_subscribe_all() {
            let bus = EventBus::new();
            let counter = Arc::new(AtomicUsize::new(0));
            let counter_clone = counter.clone();

            bus.subscribe_all("all-events-handler", move |_event| {
                counter_clone.fetch_add(1, Ordering::SeqCst);
            });

            // Should receive all event types
            bus.publish(Event::plan_created("p1", "Plan"));
            bus.publish(Event::analysis_started(10));
            bus.publish(Event::daemon_started());

            assert_eq!(counter.load(Ordering::SeqCst), 3);
        }

        #[test]
        fn test_event_bus_recent_events() {
            let bus = EventBus::new();

            bus.publish(Event::plan_created("p1", "Plan 1"));
            bus.publish(Event::plan_created("p2", "Plan 2"));
            bus.publish(Event::plan_created("p3", "Plan 3"));

            let recent = bus.recent_events(2);
            assert_eq!(recent.len(), 2);
            // Returns most recent events (p2 and p3), order may vary
            // Just verify we got the 2 most recent events
            let ids: Vec<_> = recent
                .iter()
                .filter_map(|e| {
                    if let EventData::Plan { plan_id, .. } = &e.data {
                        Some(plan_id.clone())
                    } else {
                        None
                    }
                })
                .collect();
            assert!(ids.contains(&"p2".to_string()) || ids.contains(&"p3".to_string()));
            assert!(!ids.contains(&"p1".to_string())); // p1 should not be in recent 2
        }

        #[test]
        fn test_event_bus_unsubscribe() {
            let bus = EventBus::new();
            let counter = Arc::new(AtomicUsize::new(0));
            let counter_clone = counter.clone();

            bus.subscribe(EventType::PlanCreated, "removable", move |_event| {
                counter_clone.fetch_add(1, Ordering::SeqCst);
            });

            assert_eq!(bus.handler_count(EventType::PlanCreated), 1);

            bus.publish(Event::plan_created("p1", "Plan"));
            assert_eq!(counter.load(Ordering::SeqCst), 1);

            bus.unsubscribe(EventType::PlanCreated, "removable");
            assert_eq!(bus.handler_count(EventType::PlanCreated), 0);

            bus.publish(Event::plan_created("p2", "Plan 2"));
            assert_eq!(counter.load(Ordering::SeqCst), 1); // Should not increment
        }

        #[test]
        fn test_event_serialization_roundtrip() {
            let event = Event::plan_created("plan-123", "Fix bug")
                .with_source("test_source")
                .with_correlation_id("corr-456");

            let json = serde_json::to_string(&event).unwrap();
            let deserialized: Event = serde_json::from_str(&json).unwrap();

            assert_eq!(deserialized.id, event.id);
            assert_eq!(deserialized.event_type, event.event_type);
            assert_eq!(deserialized.source, event.source);
            assert_eq!(deserialized.correlation_id, event.correlation_id);
        }

        #[test]
        fn test_event_data_variants() {
            // Test Trigger data
            let event = Event::trigger_fired(
                "slow_node",
                Some("api_call".to_string()),
                Some(150.0),
                Some(100.0),
            );
            assert_eq!(event.event_type, EventType::TriggerFired);

            // Test Storage data
            let event = Event::storage_cleanup(100, 5000);
            assert_eq!(event.event_type, EventType::StorageCleanup);

            // Test Alert data
            let event = Event::alert_fired("alert-1", "warning", "High latency detected");
            assert_eq!(event.event_type, EventType::AlertFired);

            // Test Custom data
            let custom_value = "custom_data";
            let event = Event::custom("my_type", &custom_value).unwrap();
            assert_eq!(event.event_type, EventType::Custom);
        }

        #[test]
        fn test_event_type_equality_and_hash() {
            use std::collections::HashSet;

            let mut set = HashSet::new();
            set.insert(EventType::PlanCreated);
            set.insert(EventType::PlanApproved);
            set.insert(EventType::PlanCreated); // Duplicate

            assert_eq!(set.len(), 2);
            assert!(set.contains(&EventType::PlanCreated));
            assert!(set.contains(&EventType::PlanApproved));
        }
    }
}

// =============================================================================
// Logging Module (from logging.rs)
// =============================================================================

pub mod logging {
    //! Structured Logging for Self-Improvement System.

    use crate::core::config_loader::env_vars::{env_string, DASHFLOW_DEBUG};
    use tracing::{debug, error, info, trace, warn, Span};

    /// Components of the self-improvement system for logging context.
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum Component {
        /// Background analysis daemon that monitors traces.
        Daemon,
        /// Persistent storage for plans, hypotheses, and traces.
        Storage,
        /// Trace analysis and gap detection.
        Analyzer,
        /// Multi-agent consensus for plan approval.
        Consensus,
        /// Improvement plan generation.
        Planner,
        /// Meta-analysis of self-improvement effectiveness.
        MetaAnalysis,
        /// Alert generation and dispatch.
        Alerts,
        /// Automated test generation.
        TestGeneration,
        /// Audit logging and compliance.
        Audit,
        /// PII redaction and data sanitization.
        Redaction,
        /// Circuit breaker for fault tolerance.
        CircuitBreaker,
        /// Real-time event streaming.
        Streaming,
        /// In-memory caching layer.
        Cache,
    }

    impl Component {
        /// Get the string name for this component.
        #[must_use]
        pub const fn as_str(&self) -> &'static str {
            match self {
                Self::Daemon => "daemon",
                Self::Storage => "storage",
                Self::Analyzer => "analyzer",
                Self::Consensus => "consensus",
                Self::Planner => "planner",
                Self::MetaAnalysis => "meta_analysis",
                Self::Alerts => "alerts",
                Self::TestGeneration => "test_generation",
                Self::Audit => "audit",
                Self::Redaction => "redaction",
                Self::CircuitBreaker => "circuit_breaker",
                Self::Streaming => "streaming",
                Self::Cache => "cache",
            }
        }
    }

    impl std::fmt::Display for Component {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.as_str())
        }
    }

    /// Log an error with component context.
    #[macro_export]
    macro_rules! log_si_error {
        ($component:expr, $msg:expr $(, $($key:tt = $value:expr),* $(,)?)?) => {
            tracing::error!(
                component = $component.as_str(),
                $($($key = $value,)*)?
                $msg
            )
        };
    }

    /// Log a warning with component context.
    #[macro_export]
    macro_rules! log_si_warn {
        ($component:expr, $msg:expr $(, $($key:tt = $value:expr),* $(,)?)?) => {
            tracing::warn!(
                component = $component.as_str(),
                $($($key = $value,)*)?
                $msg
            )
        };
    }

    /// Log info with component context.
    #[macro_export]
    macro_rules! log_si_info {
        ($component:expr, $msg:expr $(, $($key:tt = $value:expr),* $(,)?)?) => {
            tracing::info!(
                component = $component.as_str(),
                $($($key = $value,)*)?
                $msg
            )
        };
    }

    /// Log debug with component context.
    #[macro_export]
    macro_rules! log_si_debug {
        ($component:expr, $msg:expr $(, $($key:tt = $value:expr),* $(,)?)?) => {
            tracing::debug!(
                component = $component.as_str(),
                $($($key = $value,)*)?
                $msg
            )
        };
    }

    /// Log trace with component context.
    #[macro_export]
    macro_rules! log_si_trace {
        ($component:expr, $msg:expr $(, $($key:tt = $value:expr),* $(,)?)?) => {
            tracing::trace!(
                component = $component.as_str(),
                $($($key = $value,)*)?
                $msg
            )
        };
    }

    pub use log_si_debug;
    pub use log_si_error;
    pub use log_si_info;
    pub use log_si_trace;
    pub use log_si_warn;

    /// Create a span for a self-improvement operation.
    #[must_use]
    pub fn create_span(component: Component, operation: &str) -> Span {
        tracing::info_span!(
            "self_improvement",
            component = component.as_str(),
            operation = operation
        )
    }

    /// Log the start of an operation.
    pub fn log_operation_start(component: Component, operation: &str) {
        info!(
            component = component.as_str(),
            operation = operation,
            "Starting operation"
        );
    }

    /// Log the successful completion of an operation.
    pub fn log_operation_success(component: Component, operation: &str, details: Option<&str>) {
        if let Some(details) = details {
            info!(
                component = component.as_str(),
                operation = operation,
                details = details,
                "Operation completed successfully"
            );
        } else {
            info!(
                component = component.as_str(),
                operation = operation,
                "Operation completed successfully"
            );
        }
    }

    /// Log an operation failure.
    pub fn log_operation_failure(component: Component, operation: &str, error: &str) {
        error!(
            component = component.as_str(),
            operation = operation,
            error = error,
            "Operation failed"
        );
    }

    /// Log a trace loading warning.
    pub fn log_trace_load_warning(path: &std::path::Path, error: &str) {
        warn!(
            component = Component::Daemon.as_str(),
            path = %path.display(),
            error = error,
            "Failed to load trace"
        );
    }

    /// Log a trace parsing warning.
    pub fn log_trace_parse_warning(path: &std::path::Path, error: &str) {
        warn!(
            component = Component::Daemon.as_str(),
            path = %path.display(),
            error = error,
            "Failed to parse trace"
        );
    }

    /// Log alert dispatch failure.
    pub fn log_alert_dispatch_failure(error: &str) {
        warn!(
            component = Component::Alerts.as_str(),
            error = error,
            "Failed to dispatch alert"
        );
    }

    /// Log daemon cycle result.
    pub fn log_daemon_cycle(
        traces_analyzed: usize,
        triggers_fired: usize,
        plans_generated: usize,
        errors: &[String],
    ) {
        if errors.is_empty() {
            info!(
                component = Component::Daemon.as_str(),
                traces_analyzed = traces_analyzed,
                triggers_fired = triggers_fired,
                plans_generated = plans_generated,
                "Daemon cycle completed"
            );
        } else {
            warn!(
                component = Component::Daemon.as_str(),
                traces_analyzed = traces_analyzed,
                triggers_fired = triggers_fired,
                plans_generated = plans_generated,
                error_count = errors.len(),
                "Daemon cycle completed with errors"
            );
            for e in errors {
                warn!(
                    component = Component::Daemon.as_str(),
                    error = e,
                    "Cycle error"
                );
            }
        }
    }

    /// Log storage operation.
    pub fn log_storage_operation(operation: &str, item_type: &str, item_id: &str) {
        debug!(
            component = Component::Storage.as_str(),
            operation = operation,
            item_type = item_type,
            item_id = item_id,
            "Storage operation"
        );
    }

    /// Log cache hit/miss.
    pub fn log_cache_access(hit: bool, key: &str) {
        trace!(
            component = Component::Cache.as_str(),
            hit = hit,
            key = key,
            "Cache access"
        );
    }

    /// Log analysis trigger fired.
    pub fn log_trigger_fired(trigger_type: &str, details: &str) {
        info!(
            component = Component::Daemon.as_str(),
            trigger_type = trigger_type,
            details = details,
            "Analysis trigger fired"
        );
    }

    /// Log consensus review.
    pub fn log_consensus_review(model: &str, approved: bool, confidence: f64) {
        debug!(
            component = Component::Consensus.as_str(),
            model = model,
            approved = approved,
            confidence = confidence,
            "Model review completed"
        );
    }

    /// Log plan status change.
    pub fn log_plan_status_change(plan_id: &str, from: &str, to: &str) {
        info!(
            component = Component::Planner.as_str(),
            plan_id = plan_id,
            from_status = from,
            to_status = to,
            "Plan status changed"
        );
    }

    /// Environment variable name for debug mode.
    /// Re-exported from centralized env_vars module for backward compatibility.
    pub const DEBUG_ENV_VAR: &str = DASHFLOW_DEBUG;

    /// Check if debug mode is enabled via environment variable.
    #[must_use]
    pub fn is_debug_mode() -> bool {
        env_string(DASHFLOW_DEBUG)
            .map(|v| v == "1" || v.to_lowercase() == "true" || v.to_lowercase() == "yes")
            .unwrap_or(false)
    }

    /// Log a debug message only when debug mode is enabled.
    pub fn debug_log(component: Component, message: &str) {
        if is_debug_mode() {
            debug!(component = component.as_str(), debug_mode = true, message);
        }
    }

    /// Log detailed information about a decision being made.
    pub fn debug_decision(component: Component, decision: &str, reason: &str) {
        if is_debug_mode() {
            debug!(
                component = component.as_str(),
                decision = decision,
                reason = reason,
                "Internal decision"
            );
        }
    }

    /// Log verbose details about data being processed.
    pub fn debug_data<T: std::fmt::Debug>(component: Component, operation: &str, data: &T) {
        if is_debug_mode() {
            trace!(
                component = component.as_str(),
                operation = operation,
                data = ?data,
                "Data processing"
            );
        }
    }

    /// Log timing information for performance analysis.
    pub fn debug_timing(component: Component, operation: &str, duration_ms: u64) {
        if is_debug_mode() {
            debug!(
                component = component.as_str(),
                operation = operation,
                duration_ms = duration_ms,
                "Operation timing"
            );
        }
    }

    /// Log detailed trigger evaluation information.
    pub fn debug_trigger_evaluation(trigger_name: &str, value: f64, threshold: f64, fired: bool) {
        if is_debug_mode() {
            debug!(
                component = Component::Daemon.as_str(),
                trigger = trigger_name,
                value = value,
                threshold = threshold,
                fired = fired,
                "Trigger evaluation"
            );
        }
    }

    /// Log detailed plan processing information.
    pub fn debug_plan_processing(plan_id: &str, step: &str, details: &str) {
        if is_debug_mode() {
            debug!(
                component = Component::Planner.as_str(),
                plan_id = plan_id,
                step = step,
                details = details,
                "Plan processing"
            );
        }
    }

    /// Log detailed storage operation information.
    pub fn debug_storage_details(operation: &str, path: &str, size_bytes: Option<u64>) {
        if is_debug_mode() {
            if let Some(size) = size_bytes {
                trace!(
                    component = Component::Storage.as_str(),
                    operation = operation,
                    path = path,
                    size_bytes = size,
                    "Storage details"
                );
            } else {
                trace!(
                    component = Component::Storage.as_str(),
                    operation = operation,
                    path = path,
                    "Storage details"
                );
            }
        }
    }

    /// Print a debug banner to stderr when debug mode is enabled.
    pub fn print_debug_banner() {
        if is_debug_mode() {
            eprintln!("");
            eprintln!("  DASHFLOW DEBUG MODE ENABLED                                 ");
            eprintln!("  Set DASHFLOW_DEBUG=0 to disable verbose output              ");
            eprintln!("");
        }
    }

    /// Get the recommended tracing level based on debug mode.
    #[must_use]
    pub fn recommended_log_level() -> tracing::Level {
        if is_debug_mode() {
            tracing::Level::DEBUG
        } else {
            tracing::Level::INFO
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn test_component_as_str() {
            assert_eq!(Component::Daemon.as_str(), "daemon");
            assert_eq!(Component::Storage.as_str(), "storage");
            assert_eq!(Component::CircuitBreaker.as_str(), "circuit_breaker");
        }

        #[test]
        fn test_component_display() {
            assert_eq!(format!("{}", Component::Daemon), "daemon");
            assert_eq!(format!("{}", Component::Storage), "storage");
        }

        #[test]
        fn test_create_span() {
            let span = create_span(Component::Daemon, "test_operation");
            let _entered = span.enter();
        }

        #[test]
        fn test_debug_env_var_name() {
            assert_eq!(DEBUG_ENV_VAR, "DASHFLOW_DEBUG");
        }

        // =========================================================================
        // Additional Tests for M-60 Coverage (Worker #1872)
        // =========================================================================

        #[test]
        fn test_component_as_str_all_variants() {
            assert_eq!(Component::Daemon.as_str(), "daemon");
            assert_eq!(Component::Storage.as_str(), "storage");
            assert_eq!(Component::Analyzer.as_str(), "analyzer");
            assert_eq!(Component::Consensus.as_str(), "consensus");
            assert_eq!(Component::Planner.as_str(), "planner");
            assert_eq!(Component::MetaAnalysis.as_str(), "meta_analysis");
            assert_eq!(Component::Alerts.as_str(), "alerts");
            assert_eq!(Component::TestGeneration.as_str(), "test_generation");
            assert_eq!(Component::Audit.as_str(), "audit");
            assert_eq!(Component::Redaction.as_str(), "redaction");
            assert_eq!(Component::CircuitBreaker.as_str(), "circuit_breaker");
            assert_eq!(Component::Streaming.as_str(), "streaming");
            assert_eq!(Component::Cache.as_str(), "cache");
        }

        #[test]
        fn test_component_display_all_variants() {
            // Verify Display matches as_str for all variants
            assert_eq!(format!("{}", Component::Analyzer), "analyzer");
            assert_eq!(format!("{}", Component::Consensus), "consensus");
            assert_eq!(format!("{}", Component::Planner), "planner");
            assert_eq!(format!("{}", Component::MetaAnalysis), "meta_analysis");
            assert_eq!(format!("{}", Component::Alerts), "alerts");
            assert_eq!(format!("{}", Component::TestGeneration), "test_generation");
            assert_eq!(format!("{}", Component::Audit), "audit");
            assert_eq!(format!("{}", Component::Redaction), "redaction");
            assert_eq!(format!("{}", Component::Streaming), "streaming");
            assert_eq!(format!("{}", Component::Cache), "cache");
        }

        #[test]
        fn test_component_equality() {
            assert_eq!(Component::Daemon, Component::Daemon);
            assert_ne!(Component::Daemon, Component::Storage);
        }

        #[test]
        fn test_component_clone() {
            let original = Component::Analyzer;
            let cloned = original;
            assert_eq!(original, cloned);
        }

        #[test]
        fn test_component_debug_format() {
            let debug_str = format!("{:?}", Component::Daemon);
            assert_eq!(debug_str, "Daemon");

            let debug_str = format!("{:?}", Component::CircuitBreaker);
            assert_eq!(debug_str, "CircuitBreaker");
        }

        #[test]
        fn test_create_span_with_different_components() {
            // Create spans for various components to ensure all work
            let _ = create_span(Component::Storage, "save_data");
            let _ = create_span(Component::Analyzer, "analyze_traces");
            let _ = create_span(Component::Consensus, "review_plan");
            let _ = create_span(Component::Planner, "generate_plan");
        }

        #[test]
        fn test_log_functions_dont_panic() {
            // These functions just log, they shouldn't panic
            // We can't easily verify the log output, but we can verify they don't crash
            log_operation_start(Component::Daemon, "test_op");
            log_operation_success(Component::Daemon, "test_op", Some("details here"));
            log_operation_success(Component::Storage, "save", None);
            log_operation_failure(Component::Analyzer, "analyze", "error message");
            log_storage_operation("save", "plan", "plan-123");
            log_cache_access(true, "cache-key-1");
            log_cache_access(false, "cache-key-2");
            log_trigger_fired("slow_node", "latency > 1000ms");
            log_consensus_review("gpt-4", true, 0.95);
            log_plan_status_change("plan-1", "proposed", "approved");
        }

        #[test]
        fn test_log_daemon_cycle_no_errors() {
            // Should not panic with empty error vec
            let errors: Vec<String> = vec![];
            log_daemon_cycle(100, 5, 2, &errors);
        }

        #[test]
        fn test_log_daemon_cycle_with_errors() {
            // Should not panic with errors
            let errors = vec!["Error 1".to_string(), "Error 2".to_string()];
            log_daemon_cycle(100, 5, 2, &errors);
        }

        #[test]
        fn test_recommended_log_level_without_debug() {
            // When debug mode is not set, should return INFO
            // Note: This may depend on environment state
            let level = recommended_log_level();
            // Level should be either INFO or DEBUG depending on environment
            assert!(level == tracing::Level::INFO || level == tracing::Level::DEBUG);
        }

    }
}

// =============================================================================
// Re-exports for convenience
// =============================================================================

pub use alerts::*;
pub use events::*;
pub use logging::*;
