// Copyright 2026 Dropbox (created by Andrew Yates <ayates@dropbox.com>)

//! @cli dashflow train synthetic
//! @cli-status wired
//!
//! Synthetic data generation using teacher models

use crate::error::Error;
use crate::node::Node;
use std::sync::Arc;

/// Configuration for synthetic data generation
#[derive(Debug, Clone)]
pub struct SyntheticDataConfig {
    /// Batch size for processing
    pub batch_size: usize,

    /// Temperature for diversity (if applicable to node)
    pub temperature: f32,

    /// Whether to validate generated examples
    pub validate: bool,
}

impl Default for SyntheticDataConfig {
    fn default() -> Self {
        Self {
            batch_size: 10,
            temperature: 0.7,
            validate: true,
        }
    }
}

/// Generates synthetic training data using a teacher node
///
/// The teacher node processes unlabeled inputs and generates labeled outputs,
/// creating synthetic training examples that a student node can learn from.
pub struct SyntheticDataGenerator<S> {
    teacher_node: Arc<dyn Node<S>>,
    config: SyntheticDataConfig,
}

impl<S> SyntheticDataGenerator<S>
where
    S: Clone + Send + Sync + 'static,
{
    /// Create a new synthetic data generator
    pub fn new(teacher_node: Arc<dyn Node<S>>, config: SyntheticDataConfig) -> Self {
        Self {
            teacher_node,
            config,
        }
    }

    /// Generate synthetic examples from unlabeled inputs
    ///
    /// The teacher node processes each input state and generates a labeled output state,
    /// creating synthetic training examples. This allows the student to learn
    /// from high-quality teacher responses.
    ///
    /// # Arguments
    /// * `unlabeled_inputs` - Input states without complete labels/outputs
    ///
    /// # Returns
    /// Vector of labeled state examples generated by the teacher
    pub async fn generate(&self, unlabeled_inputs: Vec<S>) -> Result<Vec<S>, Error> {
        let mut synthetic_examples = Vec::new();

        tracing::info!(
            "Generating {} synthetic examples with teacher node",
            unlabeled_inputs.len()
        );

        // Process in batches to avoid overwhelming the API
        for (batch_idx, chunk) in unlabeled_inputs.chunks(self.config.batch_size).enumerate() {
            tracing::debug!(
                "Processing batch {}/{} ({} examples)",
                batch_idx + 1,
                unlabeled_inputs.len().div_ceil(self.config.batch_size),
                chunk.len()
            );

            for input in chunk {
                // Teacher generates output for this input
                match self.teacher_node.execute(input.clone()).await {
                    Ok(output) => {
                        // Validate if configured
                        if self.config.validate && !self.is_valid_output(&output) {
                            tracing::warn!("Teacher generated invalid output, skipping");
                            continue;
                        }
                        synthetic_examples.push(output);
                    }
                    Err(e) => {
                        tracing::warn!("Teacher failed to generate output: {}", e);
                        // Continue with other examples
                    }
                }
            }
        }

        tracing::info!(
            "Generated {} valid synthetic examples",
            synthetic_examples.len()
        );

        Ok(synthetic_examples)
    }

    /// Validate that a teacher output is usable for training
    ///
    /// This is a basic validation. Subclasses or users can override
    /// this logic for domain-specific validation.
    fn is_valid_output(&self, _example: &S) -> bool {
        // Basic validation: assume output is valid if teacher succeeded
        // Users can add custom validation logic based on state fields
        true
    }

    /// Get estimated cost for generating synthetic data
    ///
    /// # Arguments
    /// * `num_examples` - Number of examples to generate
    /// * `cost_per_request` - Cost per teacher API call
    ///
    /// # Returns
    /// Estimated total cost
    pub fn estimate_cost(&self, num_examples: usize, cost_per_request: f64) -> f64 {
        num_examples as f64 * cost_per_request
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::state::MergeableState;
    use async_trait::async_trait;
    use serde::{Deserialize, Serialize};

    #[derive(Clone, Debug, Serialize, Deserialize)]
    struct TestState {
        question: String,
        answer: Option<String>,
    }

    impl MergeableState for TestState {
        fn merge(&mut self, other: &Self) {
            if let Some(answer) = &other.answer {
                self.answer = Some(answer.clone());
            }
        }
    }

    #[tokio::test]
    async fn test_synthetic_data_generation() {
        let teacher = Arc::new(MockTeacher);
        let config = SyntheticDataConfig::default();
        let generator = SyntheticDataGenerator::new(teacher, config);

        // Create unlabeled inputs
        let mut unlabeled = Vec::new();
        for i in 0..5 {
            unlabeled.push(TestState {
                question: format!("Question {}", i),
                answer: None,
            });
        }

        let synthetic = generator.generate(unlabeled).await.unwrap();

        assert_eq!(synthetic.len(), 5);
        for ex in &synthetic {
            assert!(ex.answer.is_some());
        }
    }

    #[test]
    fn test_cost_estimation() {
        let teacher = Arc::new(MockTeacher);
        let config = SyntheticDataConfig::default();
        let generator = SyntheticDataGenerator::new(teacher, config);

        let cost = generator.estimate_cost(500, 0.0045);
        assert_eq!(cost, 2.25); // 500 * 0.0045
    }

    #[test]
    fn test_validation() {
        let teacher = Arc::new(MockTeacher);
        let config = SyntheticDataConfig::default();
        let generator = SyntheticDataGenerator::new(teacher, config);

        let valid_ex = TestState {
            question: "test".to_string(),
            answer: Some("answer".to_string()),
        };
        assert!(generator.is_valid_output(&valid_ex));

        let empty_ex = TestState {
            question: "test".to_string(),
            answer: None,
        };
        // Basic validation always returns true - users can override
        assert!(generator.is_valid_output(&empty_ex));
    }

    // Mock teacher for testing
    struct MockTeacher;

    #[async_trait]
    impl Node<TestState> for MockTeacher {
        async fn execute(&self, mut state: TestState) -> Result<TestState, Error> {
            // Add a mock answer
            state.answer = Some("Mock teacher answer".to_string());
            Ok(state)
        }

        fn as_any(&self) -> &dyn std::any::Any {
            self
        }

        fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
            self
        }
    }

    // Mock teacher that fails
    struct FailingTeacher;

    #[async_trait]
    impl Node<TestState> for FailingTeacher {
        async fn execute(&self, _state: TestState) -> Result<TestState, Error> {
            Err(Error::Validation("Teacher failed".to_string()))
        }

        fn as_any(&self) -> &dyn std::any::Any {
            self
        }

        fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
            self
        }
    }

    #[test]
    fn test_synthetic_data_config_default() {
        let config = SyntheticDataConfig::default();
        assert_eq!(config.batch_size, 10);
        assert_eq!(config.temperature, 0.7);
        assert!(config.validate);
    }

    #[test]
    fn test_synthetic_data_config_custom() {
        let config = SyntheticDataConfig {
            batch_size: 20,
            temperature: 0.9,
            validate: false,
        };
        assert_eq!(config.batch_size, 20);
        assert_eq!(config.temperature, 0.9);
        assert!(!config.validate);
    }

    #[test]
    fn test_generator_creation() {
        let teacher = Arc::new(MockTeacher);
        let config = SyntheticDataConfig::default();
        let _generator = SyntheticDataGenerator::new(teacher, config);
        // Generator created successfully
    }

    #[tokio::test]
    async fn test_generate_empty_inputs() {
        let teacher = Arc::new(MockTeacher);
        let config = SyntheticDataConfig::default();
        let generator = SyntheticDataGenerator::new(teacher, config);

        let inputs: Vec<TestState> = vec![];
        let results = generator.generate(inputs).await.unwrap();
        assert!(results.is_empty());
    }

    #[tokio::test]
    async fn test_generate_batching() {
        let teacher = Arc::new(MockTeacher);
        let config = SyntheticDataConfig {
            batch_size: 2,
            temperature: 0.7,
            validate: true,
        };
        let generator = SyntheticDataGenerator::new(teacher, config);

        // Create 5 inputs to test batching with batch_size=2
        let inputs: Vec<TestState> = (0..5)
            .map(|i| TestState {
                question: format!("Question {}", i),
                answer: None,
            })
            .collect();

        let results = generator.generate(inputs).await.unwrap();
        assert_eq!(results.len(), 5);
    }

    #[tokio::test]
    async fn test_generate_with_failing_teacher() {
        let teacher = Arc::new(FailingTeacher);
        let config = SyntheticDataConfig::default();
        let generator = SyntheticDataGenerator::new(teacher, config);

        let inputs = vec![
            TestState {
                question: "Q1".to_string(),
                answer: None,
            },
            TestState {
                question: "Q2".to_string(),
                answer: None,
            },
        ];

        // Should return empty because all executions failed
        let results = generator.generate(inputs).await.unwrap();
        assert!(results.is_empty());
    }

    #[test]
    fn test_cost_estimation_zero_examples() {
        let teacher = Arc::new(MockTeacher);
        let config = SyntheticDataConfig::default();
        let generator = SyntheticDataGenerator::new(teacher, config);

        let cost = generator.estimate_cost(0, 0.01);
        assert_eq!(cost, 0.0);
    }

    #[test]
    fn test_cost_estimation_large_scale() {
        let teacher = Arc::new(MockTeacher);
        let config = SyntheticDataConfig::default();
        let generator = SyntheticDataGenerator::new(teacher, config);

        // 10,000 examples at $0.005 each
        let cost = generator.estimate_cost(10000, 0.005);
        assert_eq!(cost, 50.0);
    }

    #[test]
    fn test_is_valid_output_always_true() {
        let teacher = Arc::new(MockTeacher);
        let config = SyntheticDataConfig::default();
        let generator = SyntheticDataGenerator::new(teacher, config);

        // Basic implementation always returns true
        let state = TestState {
            question: "test".to_string(),
            answer: Some("answer".to_string()),
        };
        assert!(generator.is_valid_output(&state));
    }

    #[tokio::test]
    async fn test_generate_preserves_input_fields() {
        let teacher = Arc::new(MockTeacher);
        let config = SyntheticDataConfig::default();
        let generator = SyntheticDataGenerator::new(teacher, config);

        let inputs = vec![TestState {
            question: "Original Question".to_string(),
            answer: None,
        }];

        let results = generator.generate(inputs).await.unwrap();
        assert_eq!(results.len(), 1);
        // Question should be preserved, answer should be filled
        assert_eq!(results[0].question, "Original Question");
        assert!(results[0].answer.is_some());
    }
}
