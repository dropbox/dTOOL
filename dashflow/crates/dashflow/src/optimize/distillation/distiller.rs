// Allow clippy warnings for this module
#![allow(clippy::expect_used, clippy::unwrap_used, clippy::clone_on_ref_ptr)]
#![allow(clippy::needless_pass_by_value, clippy::redundant_clone)]
// Copyright 2026 Dropbox (created by Andrew Yates <ayates@dropbox.com>)

//! Main distillation implementation

use crate::error::Error;
use crate::node::Node;
use crate::optimize::optimizers::bootstrap::BootstrapFewShot;
use std::sync::Arc;

use crate::optimize::distillation::analysis::{
    CostAnalysis, DistillationReport, QualityGap, ROIMetrics,
};
use crate::optimize::distillation::config::DistillationConfig;
use crate::optimize::distillation::synthetic::{SyntheticDataConfig, SyntheticDataGenerator};
use crate::optimize::distillation::DistillationResult;

/// Main distillation orchestrator
///
/// Coordinates the process of:
/// 1. Generating synthetic training data using a teacher node
/// 2. Training a student node on that synthetic data
/// 3. Evaluating quality and cost metrics
/// 4. Generating ROI analysis reports
pub struct ModelDistillation<S> {
    teacher_node: Option<Arc<dyn Node<S>>>,
    config: DistillationConfig,
}

impl<S> ModelDistillation<S>
where
    S: crate::state::GraphState,
{
    /// Create a new distillation orchestrator
    pub fn new() -> Self {
        Self {
            teacher_node: None,
            config: DistillationConfig::default(),
        }
    }

    /// Set the teacher node
    #[must_use]
    pub fn with_teacher_node(mut self, teacher: Arc<dyn Node<S>>) -> Self {
        self.teacher_node = Some(teacher);
        self
    }

    /// Set the configuration
    #[must_use]
    pub fn with_config(mut self, config: DistillationConfig) -> Self {
        self.config = config;
        self
    }

    /// Generate synthetic training data using the teacher node
    ///
    /// # Arguments
    /// * `unlabeled_inputs` - State objects with inputs but no complete labels
    ///
    /// # Returns
    /// Vector of labeled state examples generated by the teacher
    pub async fn generate_synthetic_data(&self, unlabeled_inputs: Vec<S>) -> Result<Vec<S>, Error> {
        let teacher = self
            .teacher_node
            .as_ref()
            .ok_or_else(|| Error::Validation("Teacher node not set".to_string()))?;

        let synthetic_config = SyntheticDataConfig {
            batch_size: self.config.batch_size,
            temperature: self.config.teacher_temperature,
            validate: true,
        };

        let generator = SyntheticDataGenerator::new(teacher.clone(), synthetic_config);

        // Generate up to num_synthetic_examples
        let inputs_to_use = if unlabeled_inputs.len() > self.config.num_synthetic_examples {
            &unlabeled_inputs[..self.config.num_synthetic_examples]
        } else {
            &unlabeled_inputs
        };

        generator.generate(inputs_to_use.to_vec()).await
    }

    /// Distill a student node using teacher-generated synthetic data
    ///
    /// This method trains the student node using BootstrapFewShot optimizer
    /// on synthetic data generated by the teacher.
    ///
    /// # Arguments
    /// * `student_node` - The student node to train (must be Optimizable)
    /// * `synthetic_data` - Labeled data generated by the teacher
    /// * `metric_fn` - Metric function for evaluation (takes predicted and expected states)
    ///
    /// # Returns
    /// Few-shot examples bootstrapped from synthetic data that can be used to train the student
    pub async fn distill_node<N>(
        &self,
        student_node: &N,
        synthetic_data: Vec<S>,
        metric_fn: crate::optimize::MetricFn<S>,
    ) -> Result<Vec<crate::optimize::FewShotExample>, Error>
    where
        N: Node<S>,
    {
        tracing::info!(
            "Training student node on {} synthetic examples",
            synthetic_data.len()
        );

        // Use BootstrapFewShot optimizer to generate few-shot demos
        let optimizer = BootstrapFewShot::new().with_max_demos(self.config.max_demos);

        // Split synthetic data for training
        let training_size = self.config.num_training_examples.min(synthetic_data.len());
        let trainset = &synthetic_data[..training_size];

        // Bootstrap successful demonstrations from synthetic data
        let few_shot_examples = optimizer
            .bootstrap(student_node, trainset, &metric_fn)
            .await?;

        tracing::info!(
            "Generated {} few-shot examples from {} synthetic examples",
            few_shot_examples.len(),
            synthetic_data.len()
        );

        Ok(few_shot_examples)
    }

    /// Generate a detailed report for distillation results
    pub fn generate_report(
        &self,
        result: &DistillationResult<S>,
        requests_per_day: Option<usize>,
    ) -> DistillationReport {
        let quality = QualityGap::new(
            result.teacher_quality,
            result.student_baseline_quality,
            result.distilled_quality,
            self.config.max_quality_gap,
        );

        let cost = CostAnalysis::new(
            result.teacher_cost_per_request,
            result.student_cost_per_request,
            result.synthetic_data_cost,
            result.num_synthetic_examples,
        );

        let roi = requests_per_day.map(|rpd| {
            ROIMetrics::calculate(
                rpd,
                result.teacher_cost_per_request,
                result.student_cost_per_request,
                result.synthetic_data_cost,
            )
        });

        DistillationReport::new(quality, cost, roi)
    }
}

impl<S> Default for ModelDistillation<S>
where
    S: crate::state::GraphState,
{
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::state::MergeableState;
    use async_trait::async_trait;
    use serde::{Deserialize, Serialize};

    #[derive(Clone, Debug, Serialize, Deserialize)]
    struct TestState {
        value: String,
    }

    impl MergeableState for TestState {
        fn merge(&mut self, other: &Self) {
            self.value = other.value.clone();
        }
    }

    #[tokio::test]
    async fn test_distillation_workflow() {
        // This is an integration test outline
        // Full test requires real LLM nodes, which are tested in integration tests

        let distiller: ModelDistillation<TestState> =
            ModelDistillation::new().with_config(DistillationConfig::default());

        assert!(distiller.teacher_node.is_none());
    }

    #[test]
    fn test_distillation_builder() {
        let teacher = Arc::new(MockNode);
        let config = DistillationConfig::default().with_num_synthetic_examples(200);

        let distiller: ModelDistillation<TestState> = ModelDistillation::new()
            .with_teacher_node(teacher)
            .with_config(config);

        assert!(distiller.teacher_node.is_some());
        assert_eq!(distiller.config.num_synthetic_examples, 200);
    }

    #[test]
    fn test_report_generation() {
        let distiller: ModelDistillation<TestState> = ModelDistillation::new();

        let result = DistillationResult {
            distilled_node: Arc::new(MockNode),
            synthetic_data: vec![],
            teacher_quality: 0.92,
            student_baseline_quality: 0.78,
            distilled_quality: 0.895,
            quality_gap: 0.025,
            teacher_cost_per_request: 0.0045,
            student_cost_per_request: 0.00042,
            cost_reduction_factor: 10.7,
            num_synthetic_examples: 500,
            synthetic_data_cost: 2.25,
            monthly_savings: None,
            payback_hours: None,
        };

        let report = distiller.generate_report(&result, Some(10_000));

        assert!(report.roi.is_some());
        let roi = &report.roi.as_ref().unwrap();
        assert_eq!(roi.requests_per_day, 10_000);
        assert!(roi.monthly_savings > 1200.0);
        assert!(roi.payback_hours < 2.0);

        let formatted = report.format_report();
        assert!(formatted.contains("DISTILLATION REPORT"));
    }

    // Mock node for testing
    struct MockNode;

    #[async_trait]
    impl Node<TestState> for MockNode {
        async fn execute(&self, state: TestState) -> Result<TestState, Error> {
            Ok(state)
        }

        fn as_any(&self) -> &dyn std::any::Any {
            self
        }

        fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
            self
        }
    }

    #[test]
    fn test_distillation_default() {
        let distiller: ModelDistillation<TestState> = ModelDistillation::default();
        assert!(distiller.teacher_node.is_none());
    }

    #[test]
    fn test_distillation_new() {
        let distiller: ModelDistillation<TestState> = ModelDistillation::new();
        assert!(distiller.teacher_node.is_none());
    }

    #[test]
    fn test_distillation_with_teacher() {
        let teacher = Arc::new(MockNode);
        let distiller: ModelDistillation<TestState> =
            ModelDistillation::new().with_teacher_node(teacher.clone());

        assert!(distiller.teacher_node.is_some());
    }

    #[test]
    fn test_distillation_with_config() {
        let config = DistillationConfig::default().with_num_synthetic_examples(100);

        let distiller: ModelDistillation<TestState> = ModelDistillation::new().with_config(config);

        assert_eq!(distiller.config.num_synthetic_examples, 100);
    }

    #[test]
    fn test_distillation_full_builder() {
        let teacher = Arc::new(MockNode);
        let config = DistillationConfig::default()
            .with_num_synthetic_examples(200)
            .with_max_demos(10);

        let distiller: ModelDistillation<TestState> = ModelDistillation::new()
            .with_teacher_node(teacher)
            .with_config(config);

        assert!(distiller.teacher_node.is_some());
        assert_eq!(distiller.config.num_synthetic_examples, 200);
        assert_eq!(distiller.config.max_demos, 10);
    }

    #[tokio::test]
    async fn test_generate_synthetic_data_no_teacher() {
        let distiller: ModelDistillation<TestState> = ModelDistillation::new();

        let result = distiller.generate_synthetic_data(vec![]).await;
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .to_string()
            .contains("Teacher node not set"));
    }

    #[test]
    fn test_generate_report_with_roi() {
        let distiller: ModelDistillation<TestState> = ModelDistillation::new();

        let result = DistillationResult {
            distilled_node: Arc::new(MockNode),
            synthetic_data: vec![],
            teacher_quality: 0.95,
            student_baseline_quality: 0.80,
            distilled_quality: 0.90,
            quality_gap: 0.05,
            teacher_cost_per_request: 0.004,
            student_cost_per_request: 0.0004,
            cost_reduction_factor: 10.0,
            num_synthetic_examples: 1000,
            synthetic_data_cost: 4.0,
            monthly_savings: None,
            payback_hours: None,
        };

        let report = distiller.generate_report(&result, Some(5000));

        assert!(report.roi.is_some());
        let roi = report.roi.unwrap();
        assert_eq!(roi.requests_per_day, 5000);
    }

    #[test]
    fn test_generate_report_without_roi() {
        let distiller: ModelDistillation<TestState> = ModelDistillation::new();

        let result = DistillationResult {
            distilled_node: Arc::new(MockNode),
            synthetic_data: vec![],
            teacher_quality: 0.95,
            student_baseline_quality: 0.80,
            distilled_quality: 0.90,
            quality_gap: 0.05,
            teacher_cost_per_request: 0.004,
            student_cost_per_request: 0.0004,
            cost_reduction_factor: 10.0,
            num_synthetic_examples: 1000,
            synthetic_data_cost: 4.0,
            monthly_savings: None,
            payback_hours: None,
        };

        let report = distiller.generate_report(&result, None);

        assert!(report.roi.is_none());
    }

    #[test]
    fn test_report_quality_gap_calculation() {
        let distiller: ModelDistillation<TestState> = ModelDistillation::new();

        let result = DistillationResult {
            distilled_node: Arc::new(MockNode),
            synthetic_data: vec![],
            teacher_quality: 0.95,
            student_baseline_quality: 0.75,
            distilled_quality: 0.88,
            quality_gap: 0.07,
            teacher_cost_per_request: 0.005,
            student_cost_per_request: 0.0005,
            cost_reduction_factor: 10.0,
            num_synthetic_examples: 500,
            synthetic_data_cost: 2.5,
            monthly_savings: None,
            payback_hours: None,
        };

        let report = distiller.generate_report(&result, Some(1000));

        // Check quality gap is calculated correctly
        let gap = report.quality.absolute_gap;
        assert!((gap - 0.07).abs() < 0.001);
    }
}
