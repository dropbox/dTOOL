// Copyright 2026 Dropbox (created by Andrew Yates <ayates@dropbox.com>)

//! # Signature System for DashOptimize
//!
//! Signatures define the structure of LLM tasks: what inputs are needed and what
//! outputs should be produced. They enable declarative, type-safe prompt construction.
//!
//! ## Example
//!
//! ```rust,ignore
//! use dashflow::optimize::*;
//!
//! // Simple shorthand
//! let sig = make_signature("question -> answer", "Answer questions accurately")?;
//!
//! // Explicit construction
//! let sig = Signature::new("QA")
//!     .with_input(Field::new("question", "The user's question"))
//!     .with_output(Field::new("answer", "A concise answer"))
//!     .with_instructions("Answer accurately and concisely");
//! ```

use crate::Result;
use serde::{Deserialize, Serialize};
use std::fmt;

/// Field kind: Input or Output
///
/// Determines whether a field receives data (Input) or produces data (Output)
/// in a signature.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum FieldKind {
    /// An input field that receives data for the LLM to process.
    ///
    /// Input fields are filled by the caller before invoking the signature.
    Input,
    /// An output field that the LLM should produce.
    ///
    /// Output fields are generated by the LLM and returned to the caller.
    Output,
}

/// A field in a signature (input or output)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Field {
    /// Field name (e.g., "question", "answer")
    pub name: String,

    /// Field description/purpose
    pub description: String,

    /// Whether this is an input or output field
    pub kind: FieldKind,

    /// Optional prefix for prompts (inferred from name if not provided)
    pub prefix: Option<String>,
}

impl Field {
    /// Create a new field
    pub fn new(name: impl Into<String>, description: impl Into<String>, kind: FieldKind) -> Self {
        let name = name.into();
        Self {
            name,
            description: description.into(),
            kind,
            prefix: None,
        }
    }

    /// Create an input field
    pub fn input(name: impl Into<String>, description: impl Into<String>) -> Self {
        Self::new(name, description, FieldKind::Input)
    }

    /// Create an output field
    pub fn output(name: impl Into<String>, description: impl Into<String>) -> Self {
        Self::new(name, description, FieldKind::Output)
    }

    /// Set custom prefix for prompts
    #[must_use]
    pub fn with_prefix(mut self, prefix: impl Into<String>) -> Self {
        self.prefix = Some(prefix.into());
        self
    }

    /// Set description
    #[must_use]
    pub fn with_description(mut self, description: impl Into<String>) -> Self {
        self.description = description.into();
        self
    }

    /// Get the prefix (infer from name if not explicitly set)
    pub fn get_prefix(&self) -> String {
        self.prefix
            .clone()
            .unwrap_or_else(|| infer_prefix(&self.name))
    }

    /// Check if this is an input field
    pub fn is_input(&self) -> bool {
        matches!(self.kind, FieldKind::Input)
    }

    /// Check if this is an output field
    pub fn is_output(&self) -> bool {
        matches!(self.kind, FieldKind::Output)
    }
}

/// Infer a human-readable prefix from a field name
///
/// Examples:
/// - "question" -> "Question"
/// - "user_query" -> "User Query"
/// - "llm_output" -> "LLM Output"
pub fn infer_prefix(name: &str) -> String {
    name.split('_')
        .filter(|word| !word.is_empty())
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => {
                    first.to_uppercase().collect::<String>() + &chars.as_str().to_lowercase()
                }
            }
        })
        .collect::<Vec<_>>()
        .join(" ")
}

/// Signature: defines inputs â†’ outputs for an LLM task
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signature {
    /// Signature name (e.g., "QuestionAnswer", "Classification")
    pub name: String,

    /// Input fields
    pub input_fields: Vec<Field>,

    /// Output fields
    pub output_fields: Vec<Field>,

    /// Instructions for the LLM
    pub instructions: String,
}

impl Signature {
    /// Create a new signature
    pub fn new(name: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            input_fields: Vec::new(),
            output_fields: Vec::new(),
            instructions: String::new(),
        }
    }

    /// Add an input field
    #[must_use]
    pub fn with_input(mut self, field: Field) -> Self {
        self.input_fields.push(field);
        self
    }

    /// Add an output field
    #[must_use]
    pub fn with_output(mut self, field: Field) -> Self {
        self.output_fields.push(field);
        self
    }

    /// Set instructions
    #[must_use]
    pub fn with_instructions(mut self, instructions: impl Into<String>) -> Self {
        self.instructions = instructions.into();
        self
    }

    /// Get all fields (inputs followed by outputs)
    pub fn all_fields(&self) -> Vec<&Field> {
        self.input_fields
            .iter()
            .chain(self.output_fields.iter())
            .collect()
    }

    /// Get a field by name
    pub fn get_field(&self, name: &str) -> Option<&Field> {
        self.all_fields().into_iter().find(|f| f.name == name)
    }

    /// Get the signature string (e.g., "question -> answer")
    pub fn signature_string(&self) -> String {
        let inputs = self
            .input_fields
            .iter()
            .map(|f| f.name.as_str())
            .collect::<Vec<_>>()
            .join(", ");

        let outputs = self
            .output_fields
            .iter()
            .map(|f| f.name.as_str())
            .collect::<Vec<_>>()
            .join(", ");

        format!("{} -> {}", inputs, outputs)
    }

    /// Update instructions (mutable)
    pub fn set_instructions(&mut self, instructions: impl Into<String>) {
        self.instructions = instructions.into();
    }

    /// Update a field's description
    pub fn update_field_description(
        &mut self,
        name: &str,
        description: impl Into<String>,
    ) -> Result<()> {
        let field = self
            .input_fields
            .iter_mut()
            .chain(self.output_fields.iter_mut())
            .find(|f| f.name == name)
            .ok_or_else(|| {
                crate::Error::Validation(format!("Field '{}' not found in signature", name))
            })?;

        field.description = description.into();
        Ok(())
    }
}

impl fmt::Display for Signature {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} ({})", self.name, self.signature_string())
    }
}

/// Parse a signature string and create a Signature
///
/// Format: "input1, input2 -> output1, output2"
///
/// # Example
///
/// ```rust,ignore
/// let sig = make_signature("question -> answer", "Answer questions accurately")?;
/// ```
pub fn make_signature(
    signature_str: impl AsRef<str>,
    instructions: impl Into<String>,
) -> Result<Signature> {
    let signature_str = signature_str.as_ref().trim();
    let instructions = instructions.into();

    // Split on "->"
    let parts: Vec<&str> = signature_str.split("->").map(|s| s.trim()).collect();

    if parts.len() != 2 {
        return Err(crate::Error::Validation(format!(
            "Invalid signature format: '{}'. Expected 'inputs -> outputs'",
            signature_str
        )));
    }

    let input_str = parts[0];
    let output_str = parts[1];

    // Parse input fields
    let input_fields: Vec<Field> = input_str
        .split(',')
        .map(|s| s.trim())
        .filter(|s| !s.is_empty())
        .map(|name| Field::input(name, format!("Input field: {}", name)))
        .collect();

    // Parse output fields
    let output_fields: Vec<Field> = output_str
        .split(',')
        .map(|s| s.trim())
        .filter(|s| !s.is_empty())
        .map(|name| Field::output(name, format!("Output field: {}", name)))
        .collect();

    if input_fields.is_empty() {
        return Err(crate::Error::Validation(
            "Signature must have at least one input field".to_string(),
        ));
    }

    if output_fields.is_empty() {
        return Err(crate::Error::Validation(
            "Signature must have at least one output field".to_string(),
        ));
    }

    // Generate name from signature string
    let (first_input, _) = input_fields.split_first().ok_or_else(|| {
        crate::Error::Validation("Signature must have at least one input field".to_string())
    })?;
    let (first_output, _) = output_fields.split_first().ok_or_else(|| {
        crate::Error::Validation("Signature must have at least one output field".to_string())
    })?;
    let name = format!("{}To{}", first_input.name, first_output.name);

    Ok(Signature {
        name,
        input_fields,
        output_fields,
        instructions,
    })
}

#[cfg(test)]
mod tests {
    #![allow(clippy::unwrap_used)]

    use super::*;

    #[test]
    fn test_infer_prefix() {
        assert_eq!(infer_prefix("question"), "Question");
        assert_eq!(infer_prefix("user_query"), "User Query");
        assert_eq!(infer_prefix("llm_output"), "Llm Output");
        assert_eq!(infer_prefix("answer"), "Answer");
    }

    #[test]
    fn test_make_signature() {
        let sig = make_signature("question -> answer", "Answer the question").unwrap();

        assert_eq!(sig.input_fields.len(), 1);
        assert_eq!(sig.output_fields.len(), 1);
        assert_eq!(sig.input_fields[0].name, "question");
        assert_eq!(sig.output_fields[0].name, "answer");
        assert_eq!(sig.instructions, "Answer the question");
        assert_eq!(sig.signature_string(), "question -> answer");
    }

    #[test]
    fn test_make_signature_multi_field() {
        let sig = make_signature(
            "context, question -> answer, confidence",
            "QA with confidence",
        )
        .unwrap();

        assert_eq!(sig.input_fields.len(), 2);
        assert_eq!(sig.output_fields.len(), 2);
        assert_eq!(sig.input_fields[0].name, "context");
        assert_eq!(sig.input_fields[1].name, "question");
        assert_eq!(sig.output_fields[0].name, "answer");
        assert_eq!(sig.output_fields[1].name, "confidence");
    }

    #[test]
    fn test_field_builders() {
        let input_field = Field::input("query", "User's search query").with_prefix("Search Query");

        assert!(input_field.is_input());
        assert!(!input_field.is_output());
        assert_eq!(input_field.get_prefix(), "Search Query");

        let output_field = Field::output("result", "Search results");
        assert!(output_field.is_output());
        assert!(!output_field.is_input());
        assert_eq!(output_field.get_prefix(), "Result");
    }

    #[test]
    fn test_signature_builder() {
        let sig = Signature::new("CustomQA")
            .with_input(Field::input("question", "The question"))
            .with_output(Field::output("answer", "The answer"))
            .with_instructions("Answer accurately");

        assert_eq!(sig.name, "CustomQA");
        assert_eq!(sig.input_fields.len(), 1);
        assert_eq!(sig.output_fields.len(), 1);
        assert_eq!(sig.instructions, "Answer accurately");
    }

    #[test]
    fn test_field_kind_debug() {
        assert_eq!(format!("{:?}", FieldKind::Input), "Input");
        assert_eq!(format!("{:?}", FieldKind::Output), "Output");
    }

    #[test]
    fn test_field_kind_clone_eq() {
        let kind = FieldKind::Input;
        // Use Copy trait since FieldKind is Copy
        let cloned = kind;
        assert_eq!(kind, cloned);
        assert_ne!(FieldKind::Input, FieldKind::Output);
    }

    #[test]
    fn test_field_kind_copy() {
        let kind = FieldKind::Output;
        let copied: FieldKind = kind; // Copy
        assert_eq!(kind, copied);
    }

    #[test]
    fn test_field_with_description() {
        let field =
            Field::input("name", "initial description").with_description("updated description");
        assert_eq!(field.description, "updated description");
    }

    #[test]
    fn test_field_new_explicit_kind() {
        let field = Field::new("test", "test description", FieldKind::Input);
        assert_eq!(field.name, "test");
        assert_eq!(field.description, "test description");
        assert_eq!(field.kind, FieldKind::Input);
        assert!(field.prefix.is_none());
    }

    #[test]
    fn test_field_get_prefix_default() {
        let field = Field::input("user_name", "The user name");
        assert_eq!(field.get_prefix(), "User Name");
    }

    #[test]
    fn test_field_debug() {
        let field = Field::input("query", "The query");
        let debug_str = format!("{:?}", field);
        assert!(debug_str.contains("query"));
        assert!(debug_str.contains("Input"));
    }

    #[test]
    fn test_signature_all_fields() {
        let sig = Signature::new("Test")
            .with_input(Field::input("input1", "Input 1"))
            .with_input(Field::input("input2", "Input 2"))
            .with_output(Field::output("output1", "Output 1"));

        let fields = sig.all_fields();
        assert_eq!(fields.len(), 3);
        assert_eq!(fields[0].name, "input1");
        assert_eq!(fields[1].name, "input2");
        assert_eq!(fields[2].name, "output1");
    }

    #[test]
    fn test_signature_get_field() {
        let sig = Signature::new("Test")
            .with_input(Field::input("query", "The query"))
            .with_output(Field::output("answer", "The answer"));

        assert!(sig.get_field("query").is_some());
        assert!(sig.get_field("answer").is_some());
        assert!(sig.get_field("nonexistent").is_none());

        let query_field = sig.get_field("query").unwrap();
        assert!(query_field.is_input());
    }

    #[test]
    fn test_signature_set_instructions() {
        let mut sig = Signature::new("Test").with_instructions("Initial");
        assert_eq!(sig.instructions, "Initial");

        sig.set_instructions("Updated");
        assert_eq!(sig.instructions, "Updated");
    }

    #[test]
    fn test_signature_update_field_description() {
        let mut sig =
            Signature::new("Test").with_input(Field::input("query", "Original description"));

        let result = sig.update_field_description("query", "New description");
        assert!(result.is_ok());
        assert_eq!(sig.input_fields[0].description, "New description");
    }

    #[test]
    fn test_signature_update_field_description_not_found() {
        let mut sig = Signature::new("Test").with_input(Field::input("query", "Description"));

        let result = sig.update_field_description("nonexistent", "New");
        assert!(result.is_err());
    }

    #[test]
    fn test_signature_update_output_field_description() {
        let mut sig = Signature::new("Test").with_output(Field::output("answer", "Original"));

        let result = sig.update_field_description("answer", "Updated");
        assert!(result.is_ok());
        assert_eq!(sig.output_fields[0].description, "Updated");
    }

    #[test]
    fn test_signature_display() {
        let sig = Signature::new("QA")
            .with_input(Field::input("question", "The question"))
            .with_output(Field::output("answer", "The answer"));

        let display = format!("{}", sig);
        assert!(display.contains("QA"));
        assert!(display.contains("question -> answer"));
    }

    #[test]
    fn test_signature_debug() {
        let sig = Signature::new("Test");
        let debug = format!("{:?}", sig);
        assert!(debug.contains("Test"));
    }

    #[test]
    fn test_make_signature_invalid_format() {
        let result = make_signature("invalid format", "Instructions");
        assert!(result.is_err());
    }

    #[test]
    fn test_make_signature_no_inputs() {
        let result = make_signature(" -> output", "Instructions");
        assert!(result.is_err());
    }

    #[test]
    fn test_make_signature_no_outputs() {
        let result = make_signature("input -> ", "Instructions");
        assert!(result.is_err());
    }

    #[test]
    fn test_make_signature_with_whitespace() {
        let sig = make_signature("  question  ->  answer  ", "Instructions").unwrap();
        assert_eq!(sig.input_fields[0].name, "question");
        assert_eq!(sig.output_fields[0].name, "answer");
    }

    #[test]
    fn test_infer_prefix_empty_string() {
        assert_eq!(infer_prefix(""), "");
    }

    #[test]
    fn test_infer_prefix_single_char() {
        assert_eq!(infer_prefix("a"), "A");
    }

    #[test]
    fn test_infer_prefix_multiple_underscores() {
        assert_eq!(infer_prefix("a_b_c"), "A B C");
        assert_eq!(infer_prefix("a__b"), "A B");
        assert_eq!(infer_prefix("__a__b__"), "A B");
    }

    #[test]
    fn test_field_serialization() {
        let field = Field::input("query", "The query").with_prefix("Query");
        let json = serde_json::to_string(&field).unwrap();
        assert!(json.contains("query"));
        assert!(json.contains("Input"));
    }

    #[test]
    fn test_signature_serialization() {
        let sig = Signature::new("Test")
            .with_input(Field::input("q", "Question"))
            .with_output(Field::output("a", "Answer"));

        let json = serde_json::to_string(&sig).unwrap();
        let deserialized: Signature = serde_json::from_str(&json).unwrap();

        assert_eq!(deserialized.name, "Test");
        assert_eq!(deserialized.input_fields.len(), 1);
        assert_eq!(deserialized.output_fields.len(), 1);
    }

    #[test]
    fn test_signature_clone() {
        let sig = Signature::new("Test")
            .with_instructions("Instructions")
            .with_input(Field::input("q", "Question"));

        let cloned = sig.clone();
        assert_eq!(cloned.name, sig.name);
        assert_eq!(cloned.instructions, sig.instructions);
        assert_eq!(cloned.input_fields.len(), sig.input_fields.len());
    }

    #[test]
    fn test_signature_string_empty() {
        let sig = Signature::new("Empty");
        assert_eq!(sig.signature_string(), " -> ");
    }

    #[test]
    fn test_signature_string_multiple_fields() {
        let sig = Signature::new("Multi")
            .with_input(Field::input("a", "A"))
            .with_input(Field::input("b", "B"))
            .with_output(Field::output("x", "X"))
            .with_output(Field::output("y", "Y"));

        assert_eq!(sig.signature_string(), "a, b -> x, y");
    }
}
