//! Deserialization and loading for DashFlow objects
//!
//! This module provides deserialization functionality for DashFlow objects,
//! enabling objects to be reconstructed from JSON/YAML files generated by
//! the serialization system.
//!
//! # Architecture
//!
//! The deserialization system mirrors Python `DashFlow`'s approach:
//!
//! 1. Objects implement deserialization via `from_serialized` methods
//! 2. JSON objects with `{"lc": 1, "type": "constructor", "id": [...], "kwargs": {...}}`
//!    are recognized as serialized DashFlow objects
//! 3. Secrets can be loaded from environment variables via `{"env": "VAR_NAME"}`
//! 4. The `id` field identifies the object type for deserialization
//!
//! # Example
//!
//! ```rust
//! use dashflow::core::deserialization::from_json_str;
//! use dashflow::core::prompts::PromptTemplate;
//!
//! # fn example() -> Result<(), Box<dyn std::error::Error>> {
//! let json = r#"{
//!   "lc": 1,
//!   "type": "constructor",
//!   "id": ["dashflow_core", "prompts", "PromptTemplate"],
//!   "kwargs": {
//!     "template": "Hello {name}!",
//!     "input_variables": ["name"]
//!   }
//! }"#;
//!
//! // Deserialize to PromptTemplate
//! let prompt: PromptTemplate = from_json_str(json)?;
//! # Ok(())
//! # }
//! ```
//!
//! # Round-trip Serialization
//!
//! Objects that implement both `Serializable` and deserialization support
//! round-trip conversion:
//!
//! ```rust,ignore
//! use dashflow::core::serialization::Serializable;
//! use dashflow::core::deserialization::from_json_str;
//! use dashflow::core::prompts::PromptTemplate;
//!
//! // Original object
//! let original = PromptTemplate::new("Hello {name}!")?;
//!
//! // Serialize to JSON
//! let json = original.to_json_string(false)?;
//!
//! // Deserialize back to object
//! let reconstructed: PromptTemplate = from_json_str(&json)?;
//!
//! // Objects should be functionally equivalent
//! assert_eq!(original.template(), reconstructed.template());
//! ```

use crate::core::error::{Error, Result};
use serde_json::Value;
use std::collections::HashMap;

/// Current deserialization format version
pub const DESERIALIZATION_VERSION: u32 = 1;

/// Trait for objects that can be deserialized from JSON
///
/// This trait provides a standard interface for reconstructing objects
/// from their serialized JSON representation.
///
/// # Implementation Note
///
/// Most types should implement this via a `from_serialized` associated function
/// rather than directly implementing the trait. See individual type documentation
/// for examples.
pub trait Deserializable: Sized {
    /// Deserialize from a JSON value
    ///
    /// The JSON value should be a `SerializedObject` from the serialization module,
    /// typically with the structure:
    ///
    /// ```json
    /// {
    ///   "lc": 1,
    ///   "type": "constructor",
    ///   "id": ["dashflow_core", "prompts", "PromptTemplate"],
    ///   "kwargs": {
    ///     "template": "Hello {name}!"
    ///   }
    /// }
    /// ```
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - The JSON structure is invalid
    /// - Required fields are missing
    /// - Type IDs don't match
    /// - Constructor arguments are invalid
    fn from_json(value: &Value) -> Result<Self>;
}

/// Deserialize a DashFlow object from a JSON string
///
/// This is a convenience function that parses JSON and calls the appropriate
/// deserialization method based on the `id` field.
///
/// # Type Parameter
///
/// The return type must be explicitly specified or inferrable from context:
///
/// ```rust,ignore
/// let prompt: PromptTemplate = from_json_str(json)?;
/// // or
/// let prompt = from_json_str::<PromptTemplate>(json)?;
/// ```
///
/// # Errors
///
/// Returns an error if:
/// - The JSON is malformed
/// - The object type doesn't match the expected type
/// - Deserialization fails for any reason
pub fn from_json_str<T: Deserializable>(json: &str) -> Result<T> {
    let value: Value = serde_json::from_str(json)
        .map_err(|e| Error::InvalidInput(format!("Failed to parse JSON: {e}")))?;
    T::from_json(&value)
}

/// Deserialize a DashFlow object from a parsed JSON value
///
/// Use this if you already have a `serde_json::Value` from parsing.
///
/// # Errors
///
/// Returns an error if deserialization fails
pub fn from_json_value<T: Deserializable>(value: &Value) -> Result<T> {
    T::from_json(value)
}

/// Extract and validate serialized object fields
///
/// This helper function extracts the common fields from a serialized object:
/// - `lc`: version number
/// - `type`: object type (must be "constructor")
/// - `id`: unique identifier
/// - `kwargs`: constructor arguments
///
/// # Errors
///
/// Returns an error if:
/// - Required fields are missing
/// - `lc` version is unsupported
/// - `type` is not "constructor"
pub fn extract_serialized_fields(value: &Value) -> Result<(u32, Vec<String>, &Value)> {
    let obj = value
        .as_object()
        .ok_or_else(|| Error::InvalidInput("Expected JSON object".to_string()))?;

    // Extract lc version
    let lc_u64 = obj
        .get("lc")
        .and_then(serde_json::Value::as_u64)
        .ok_or_else(|| Error::InvalidInput("Missing or invalid 'lc' field".to_string()))?;
    let lc = u32::try_from(lc_u64).map_err(|e| {
        Error::InvalidInput(format!("'lc' field value {lc_u64} exceeds u32 range: {e}"))
    })?;

    if lc != DESERIALIZATION_VERSION {
        return Err(Error::InvalidInput(format!(
            "Unsupported serialization version: {lc}. Expected {DESERIALIZATION_VERSION}"
        )));
    }

    // Extract type
    let type_str = obj
        .get("type")
        .and_then(|v| v.as_str())
        .ok_or_else(|| Error::InvalidInput("Missing or invalid 'type' field".to_string()))?;

    if type_str != "constructor" {
        return Err(Error::InvalidInput(format!(
            "Cannot deserialize type '{type_str}'. Only 'constructor' is supported"
        )));
    }

    // Extract id
    let id = obj
        .get("id")
        .and_then(|v| v.as_array())
        .ok_or_else(|| Error::InvalidInput("Missing or invalid 'id' field".to_string()))?
        .iter()
        .map(|v| {
            v.as_str()
                .map(String::from)
                .ok_or_else(|| Error::InvalidInput("ID must be array of strings".to_string()))
        })
        .collect::<Result<Vec<String>>>()?;

    // Extract kwargs
    let kwargs = obj
        .get("kwargs")
        .ok_or_else(|| Error::InvalidInput("Missing 'kwargs' field".to_string()))?;

    Ok((lc, id, kwargs))
}

/// Validate that the ID matches the expected path
///
/// This ensures type safety during deserialization by checking that the
/// serialized object's ID matches what we expect.
///
/// # Example
///
/// ```rust,ignore
/// let expected_id = vec!["dashflow_core", "prompts", "PromptTemplate"];
/// validate_id(&id, &expected_id)?;
/// ```
pub fn validate_id(actual: &[String], expected: &[String]) -> Result<()> {
    if actual != expected {
        return Err(Error::InvalidInput(format!(
            "Type mismatch: expected {expected:?}, got {actual:?}"
        )));
    }
    Ok(())
}

/// Resolve a secret reference from environment variables
///
/// If the value is a secret reference like `{"env": "OPENAI_API_KEY"}`,
/// this function retrieves the value from the environment.
///
/// If the value is a plain string, it's returned as-is.
///
/// # Errors
///
/// Returns an error if:
/// - The secret reference format is invalid
/// - The environment variable doesn't exist
pub fn resolve_secret(value: &Value) -> Result<String> {
    // Check if it's a secret reference: {"env": "VAR_NAME"}
    if let Some(obj) = value.as_object() {
        if let Some(env_var) = obj.get("env").and_then(|v| v.as_str()) {
            // Load from environment
            return std::env::var(env_var).map_err(|e| {
                Error::Configuration(format!("Environment variable '{env_var}' not found: {e}"))
            });
        }
    }

    // Otherwise, treat as plain string
    value
        .as_str()
        .map(String::from)
        .ok_or_else(|| {
            let actual_type = match value {
                Value::Null => "null",
                Value::Bool(_) => "boolean",
                Value::Number(_) => "number",
                Value::String(_) => "string", // shouldn't happen since as_str() would work
                Value::Array(_) => "array",
                Value::Object(_) => "object (not a secret reference)",
            };
            Error::InvalidInput(format!(
                "Expected string or secret reference {{\"env\": \"VAR_NAME\"}}, got {}",
                actual_type
            ))
        })
}

/// Extract a required string field from kwargs
pub fn get_string(kwargs: &Value, key: &str) -> Result<String> {
    kwargs
        .get(key)
        .and_then(|v| v.as_str())
        .map(String::from)
        .ok_or_else(|| Error::InvalidInput(format!("Missing or invalid string field '{key}'")))
}

/// Extract an optional string field from kwargs
pub fn get_optional_string(kwargs: &Value, key: &str) -> Result<Option<String>> {
    match kwargs.get(key) {
        None => Ok(None),
        Some(value) => {
            if value.is_null() {
                Ok(None)
            } else {
                value
                    .as_str()
                    .map(|s| Some(s.to_string()))
                    .ok_or_else(|| Error::InvalidInput(format!("Invalid string field '{key}'")))
            }
        }
    }
}

/// Extract a required array of strings from kwargs
pub fn get_string_array(kwargs: &Value, key: &str) -> Result<Vec<String>> {
    kwargs
        .get(key)
        .and_then(|v| v.as_array())
        .ok_or_else(|| Error::InvalidInput(format!("Missing or invalid array field '{key}'")))?
        .iter()
        .map(|v| {
            v.as_str()
                .map(String::from)
                .ok_or_else(|| Error::InvalidInput(format!("Array '{key}' must contain strings")))
        })
        .collect()
}

/// Extract an optional array of strings from kwargs
pub fn get_optional_string_array(kwargs: &Value, key: &str) -> Result<Option<Vec<String>>> {
    match kwargs.get(key) {
        None => Ok(None),
        Some(value) => {
            if value.is_null() {
                Ok(None)
            } else {
                value
                    .as_array()
                    .ok_or_else(|| Error::InvalidInput(format!("Invalid array field '{key}'")))?
                    .iter()
                    .map(|v| {
                        v.as_str().map(String::from).ok_or_else(|| {
                            Error::InvalidInput(format!("Array '{key}' must contain strings"))
                        })
                    })
                    .collect::<Result<Vec<String>>>()
                    .map(Some)
            }
        }
    }
}

/// Extract a required float field from kwargs
pub fn get_f32(kwargs: &Value, key: &str) -> Result<f32> {
    kwargs
        .get(key)
        .and_then(serde_json::Value::as_f64)
        .map(|f| f as f32)
        .ok_or_else(|| Error::InvalidInput(format!("Missing or invalid float field '{key}'")))
}

/// Extract an optional float field from kwargs
pub fn get_optional_f32(kwargs: &Value, key: &str) -> Result<Option<f32>> {
    match kwargs.get(key) {
        None => Ok(None),
        Some(value) => {
            if value.is_null() {
                Ok(None)
            } else {
                value
                    .as_f64()
                    .map(|f| Some(f as f32))
                    .ok_or_else(|| Error::InvalidInput(format!("Invalid float field '{key}'")))
            }
        }
    }
}

/// Extract a required integer field from kwargs
pub fn get_u32(kwargs: &Value, key: &str) -> Result<u32> {
    let value = kwargs
        .get(key)
        .and_then(serde_json::Value::as_u64)
        .ok_or_else(|| Error::InvalidInput(format!("Missing or invalid integer field '{key}'")))?;
    u32::try_from(value).map_err(|e| {
        Error::InvalidInput(format!(
            "Integer field '{key}' value {value} exceeds u32 range: {e}"
        ))
    })
}

/// Extract an optional integer field from kwargs
pub fn get_optional_u32(kwargs: &Value, key: &str) -> Result<Option<u32>> {
    match kwargs.get(key) {
        None => Ok(None),
        Some(value) => {
            if value.is_null() {
                Ok(None)
            } else {
                let u = value
                    .as_u64()
                    .ok_or_else(|| Error::InvalidInput(format!("Invalid integer field '{key}'")))?;
                let result = u32::try_from(u).map_err(|e| {
                    Error::InvalidInput(format!(
                        "Integer field '{key}' value {u} exceeds u32 range: {e}"
                    ))
                })?;
                Ok(Some(result))
            }
        }
    }
}

/// Extract a `HashMap`<String, String> from kwargs
pub fn get_string_map(kwargs: &Value, key: &str) -> Result<HashMap<String, String>> {
    kwargs
        .get(key)
        .and_then(|v| v.as_object())
        .ok_or_else(|| Error::InvalidInput(format!("Missing or invalid object field '{key}'")))?
        .iter()
        .map(|(k, v)| {
            v.as_str()
                .map(|s| (k.clone(), s.to_string()))
                .ok_or_else(|| {
                    Error::InvalidInput(format!("Object '{key}' must have string values"))
                })
        })
        .collect()
}

/// Extract an optional `HashMap`<String, String> from kwargs
pub fn get_optional_string_map(
    kwargs: &Value,
    key: &str,
) -> Result<Option<HashMap<String, String>>> {
    match kwargs.get(key) {
        None => Ok(None),
        Some(value) => {
            if value.is_null() {
                Ok(None)
            } else {
                value
                    .as_object()
                    .ok_or_else(|| Error::InvalidInput(format!("Invalid object field '{key}'")))?
                    .iter()
                    .map(|(k, v)| {
                        v.as_str()
                            .map(|s| (k.clone(), s.to_string()))
                            .ok_or_else(|| {
                                Error::InvalidInput(format!(
                                    "Object '{key}' must have string values"
                                ))
                            })
                    })
                    .collect::<Result<HashMap<String, String>>>()
                    .map(Some)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::{
        extract_serialized_fields, get_f32, get_optional_string, get_string, get_string_array,
        resolve_secret, validate_id,
    };
    use crate::test_prelude::*;
    use serde_json::json;

    #[test]
    fn test_extract_serialized_fields() {
        let value = json!({
            "lc": 1,
            "type": "constructor",
            "id": ["dashflow_core", "prompts", "PromptTemplate"],
            "kwargs": {
                "template": "Hello {name}!"
            }
        });

        let (lc, id, kwargs) = extract_serialized_fields(&value).unwrap();

        assert_eq!(lc, 1);
        assert_eq!(id, vec!["dashflow_core", "prompts", "PromptTemplate"]);
        assert_eq!(kwargs["template"], "Hello {name}!");
    }

    #[test]
    fn test_extract_serialized_fields_invalid_version() {
        let value = json!({
            "lc": 999,
            "type": "constructor",
            "id": ["test"],
            "kwargs": {}
        });

        let result = extract_serialized_fields(&value);
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .to_string()
            .contains("Unsupported serialization version"));
    }

    #[test]
    fn test_extract_serialized_fields_invalid_type() {
        let value = json!({
            "lc": 1,
            "type": "secret",
            "id": ["test"],
        });

        let result = extract_serialized_fields(&value);
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .to_string()
            .contains("Only 'constructor' is supported"));
    }

    #[test]
    fn test_validate_id() {
        let actual = vec![
            "dashflow_core".to_string(),
            "prompts".to_string(),
            "PromptTemplate".to_string(),
        ];
        let expected = vec![
            "dashflow_core".to_string(),
            "prompts".to_string(),
            "PromptTemplate".to_string(),
        ];

        assert!(validate_id(&actual, &expected).is_ok());

        let wrong = vec!["wrong".to_string()];
        assert!(validate_id(&actual, &wrong).is_err());
    }

    #[test]
    fn test_resolve_secret_plain_string() {
        let value = json!("my-api-key");
        let result = resolve_secret(&value).unwrap();
        assert_eq!(result, "my-api-key");
    }

    #[test]
    fn test_resolve_secret_env_var() {
        std::env::set_var("TEST_SECRET_VAR", "secret-value");
        let value = json!({"env": "TEST_SECRET_VAR"});
        let result = resolve_secret(&value).unwrap();
        assert_eq!(result, "secret-value");
        std::env::remove_var("TEST_SECRET_VAR");
    }

    #[test]
    fn test_resolve_secret_env_var_missing() {
        let value = json!({"env": "NONEXISTENT_VAR"});
        let result = resolve_secret(&value);
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .to_string()
            .contains("Environment variable"));
    }

    #[test]
    fn test_get_string() {
        let kwargs = json!({"name": "test"});
        assert_eq!(get_string(&kwargs, "name").unwrap(), "test");
    }

    #[test]
    fn test_get_string_missing() {
        let kwargs = json!({});
        assert!(get_string(&kwargs, "name").is_err());
    }

    #[test]
    fn test_get_optional_string() {
        let kwargs = json!({"name": "test"});
        assert_eq!(
            get_optional_string(&kwargs, "name").unwrap(),
            Some("test".to_string())
        );

        let kwargs = json!({});
        assert_eq!(get_optional_string(&kwargs, "name").unwrap(), None);

        let kwargs = json!({"name": null});
        assert_eq!(get_optional_string(&kwargs, "name").unwrap(), None);
    }

    #[test]
    fn test_get_string_array() {
        let kwargs = json!({"items": ["a", "b", "c"]});
        assert_eq!(
            get_string_array(&kwargs, "items").unwrap(),
            vec!["a", "b", "c"]
        );
    }

    #[test]
    fn test_get_f32() {
        let kwargs = json!({"temperature": 0.7});
        assert_eq!(get_f32(&kwargs, "temperature").unwrap(), 0.7);
    }

    #[test]
    fn test_get_optional_f32() {
        let kwargs = json!({"temperature": 0.7});
        assert_eq!(get_optional_f32(&kwargs, "temperature").unwrap(), Some(0.7));

        let kwargs = json!({});
        assert_eq!(get_optional_f32(&kwargs, "temperature").unwrap(), None);
    }

    #[test]
    fn test_get_u32() {
        let kwargs = json!({"max_tokens": 1000});
        assert_eq!(get_u32(&kwargs, "max_tokens").unwrap(), 1000);
    }

    #[test]
    fn test_get_string_map() {
        let kwargs = json!({"metadata": {"key1": "value1", "key2": "value2"}});
        let map = get_string_map(&kwargs, "metadata").unwrap();
        assert_eq!(map.len(), 2);
        assert_eq!(map.get("key1"), Some(&"value1".to_string()));
    }
}
