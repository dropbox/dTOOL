//! Build script that auto-discovers DashFlow modules using `dashflow-module-discovery`.
//!
//! M-601: Uses the `dashflow-module-discovery` crate instead of duplicating the discovery logic.
//! This eliminates duplicated code and keeps build-time and runtime discovery consistent.
//!
//! M-600: Scans all workspace crates (not just `crates/dashflow/src`) for comprehensive
//! build-time discovery that matches runtime discovery behavior.

// Allow expect in build.rs - Cargo guarantees OUT_DIR and CARGO_MANIFEST_DIR are set,
// and write failures should panic the build.
#![allow(clippy::expect_used)]

use dashflow_module_discovery::{
    discover_all_workspace_crates, discover_workspace_binaries, discover_workspace_modules,
    CliStatus, ModuleInfo, ModuleStatus,
};
use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set");

    // M-600: Navigate to workspace root from crates/dashflow/
    // CARGO_MANIFEST_DIR is crates/dashflow, so go up two levels
    let workspace_root = Path::new(&manifest_dir)
        .parent() // crates/
        .and_then(|p| p.parent()) // workspace root
        .expect("Failed to find workspace root");

    // M-600: Use comprehensive workspace-wide discovery (matches CLI introspect behavior)
    let all_crates = discover_all_workspace_crates(workspace_root);
    let mut modules = discover_workspace_modules(workspace_root, &all_crates);

    // M-605: Also discover binaries in src/bin/ directories
    let binaries = discover_workspace_binaries(workspace_root, &all_crates);
    modules.extend(binaries);

    let generated_code = generate_code(&modules);

    // Write to OUT_DIR
    let out_path = Path::new(&out_dir).join("discovered_modules.rs");
    fs::write(&out_path, generated_code).expect("Failed to write discovered_modules.rs");

    // Tell cargo to rerun if any source file changes in any crate
    println!("cargo:rerun-if-changed=../../crates");
}

fn generate_code(modules: &[ModuleInfo]) -> String {
    let mut code = String::new();

    code.push_str("// AUTO-GENERATED BY build.rs using dashflow-module-discovery - DO NOT EDIT\n");
    code.push_str("// M-601: Consolidated module discovery eliminates code duplication\n");
    code.push_str("// Regenerate by running: cargo build -p dashflow\n\n");

    code.push_str("/// Auto-discovered module information from @dashflow-module markers\n");
    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("pub struct DiscoveredModule {\n");
    code.push_str("    /// User-facing short name for the module.\n");
    code.push_str("    pub name: &'static str,\n");
    code.push_str("    /// Fully qualified Rust module path.\n");
    code.push_str("    pub path: &'static str,\n");
    code.push_str("    /// High-level category for grouping/search.\n");
    code.push_str("    pub category: &'static str,\n");
    code.push_str("    /// One-line summary extracted from module docs.\n");
    code.push_str("    pub description: &'static str,\n");
    code.push_str("    /// Source file path for this module, relative to the crate when possible.\n");
    code.push_str("    pub source_path: &'static str,\n");
    code.push_str("    /// CLI command name for this module, when applicable.\n");
    code.push_str("    pub cli_command: Option<&'static str>,\n");
    code.push_str("    /// Wiring status for the CLI entrypoint associated with this module.\n");
    code.push_str("    pub cli_status: Option<&'static str>,\n");
    code.push_str("    /// Stability designation for this module.\n");
    code.push_str("    pub status: &'static str,\n");
    code.push_str("    /// Capability tags inferred from module name/docs and children.\n");
    code.push_str("    pub capability_tags: &'static [&'static str],\n");
    code.push_str("}\n\n");

    // M-600: Updated comment to reflect workspace-wide discovery
    code.push_str(&format!(
        "/// All {} modules discovered from workspace crates (M-600 comprehensive discovery)\n",
        modules.len()
    ));
    code.push_str("pub static DISCOVERED_MODULES: &[DiscoveredModule] = &[\n");

    for m in modules {
        let cli_cmd = m
            .cli_command
            .as_ref()
            .map_or("None".to_string(), |c| format!("Some(\"{}\")", c));

        let cli_st = m.cli_status.map_or("None".to_string(), |s| {
            let status_str = match s {
                CliStatus::Wired => "wired",
                CliStatus::Stub => "stub",
                CliStatus::None => "none",
            };
            format!("Some(\"{}\")", status_str)
        });

        let status_str = match m.status {
            ModuleStatus::Stable => "stable",
            ModuleStatus::Experimental => "experimental",
            ModuleStatus::Deprecated => "deprecated",
        };

        // Escape quotes in description
        let desc = m.description.replace('\\', "\\\\").replace('"', "\\\"");
        let source_path = m.source_path.display().to_string();

        // Format capability tags as static array
        let tags: Vec<String> = m
            .capability_tags
            .iter()
            .map(|t| format!("\"{}\"", t))
            .collect();
        let tags_str = format!("&[{}]", tags.join(", "));

        code.push_str("    DiscoveredModule {\n");
        code.push_str(&format!("        name: \"{}\",\n", m.name));
        code.push_str(&format!("        path: \"{}\",\n", m.path));
        code.push_str(&format!("        category: \"{}\",\n", m.category));
        code.push_str(&format!("        description: \"{}\",\n", desc));
        code.push_str(&format!("        source_path: \"{}\",\n", source_path));
        code.push_str(&format!("        cli_command: {},\n", cli_cmd));
        code.push_str(&format!("        cli_status: {},\n", cli_st));
        code.push_str(&format!("        status: \"{}\",\n", status_str));
        code.push_str(&format!("        capability_tags: {},\n", tags_str));
        code.push_str("    },\n");
    }

    code.push_str("];\n");

    code
}
