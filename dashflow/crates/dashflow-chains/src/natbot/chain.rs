//! NatBotChain: LLM-driven browser automation.
//!
//! **Security Note**: This toolkit provides code to control a web-browser.
//! The web-browser can be used to navigate to any URL (including any internal
//! network URLs) and local files. Exercise care if exposing this chain to
//! end-users. Control who is able to access and use this chain, and isolate
//! the network access of the server that hosts this chain.

use dashflow::core::{language_models::ChatModel, Error};
use std::sync::Arc;

use super::crawler::Crawler;
use super::prompt::create_prompt;

/// NatBotChain: An LLM-driven browser automation chain.
///
/// This chain uses an LLM to control browser actions (scroll, click, type)
/// by analyzing simplified webpage representations and generating commands
/// to accomplish objectives.
///
/// # Example
/// ```no_run
/// use dashflow_chains::natbot::NatBotChain;
/// use dashflow_openai::ChatOpenAI;
/// use std::sync::Arc;
///
/// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
/// let llm = Arc::new(ChatOpenAI::default());
/// let mut natbot = NatBotChain::from_llm(llm, "Find a 2 bedroom house in Seattle").await?;
///
/// // Execute browser command
/// let command = natbot.execute("https://www.google.com", "<input id=1>Search</input>").await?;
/// println!("Command: {}", command);
/// # Ok(())
/// # }
/// ```
pub struct NatBotChain {
    llm: Arc<dyn ChatModel>,
    objective: String,
    crawler: Crawler,
    previous_command: String,
}

impl NatBotChain {
    /// Create a new NatBotChain from an LLM and objective.
    pub async fn from_llm(
        llm: Arc<dyn ChatModel>,
        objective: impl Into<String>,
    ) -> Result<Self, Error> {
        let crawler = Crawler::new().await?;
        Ok(Self {
            llm,
            objective: objective.into(),
            crawler,
            previous_command: String::new(),
        })
    }

    /// Execute the chain to figure out the next browser command.
    ///
    /// # Arguments
    /// * `url` - URL of the site currently on
    /// * `browser_content` - Content of the page as currently displayed
    ///
    /// # Returns
    /// Next browser command to run
    ///
    /// # Example
    /// ```no_run
    /// # use dashflow_chains::natbot::NatBotChain;
    /// # use dashflow_openai::ChatOpenAI;
    /// # use std::sync::Arc;
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// # let llm = Arc::new(ChatOpenAI::default());
    /// # let mut natbot = NatBotChain::from_llm(llm, "Find a house").await?;
    /// let browser_content = "<input id=1>Search</input>";
    /// let command = natbot.execute("https://www.google.com", browser_content).await?;
    /// println!("Next command: {}", command);
    /// # Ok(())
    /// # }
    /// ```
    pub async fn execute(&mut self, url: &str, browser_content: &str) -> Result<String, Error> {
        use dashflow::core::messages::Message;
        use std::collections::HashMap;

        let prompt = create_prompt();

        // Truncate inputs as per Python baseline
        let url_truncated = if url.len() > 100 { &url[..100] } else { url };

        let browser_content_truncated = if browser_content.len() > 4500 {
            &browser_content[..4500]
        } else {
            browser_content
        };

        let mut args = HashMap::new();
        args.insert("objective".to_string(), self.objective.clone());
        args.insert("url".to_string(), url_truncated.to_string());
        args.insert(
            "previous_command".to_string(),
            self.previous_command.clone(),
        );
        args.insert(
            "browser_content".to_string(),
            browser_content_truncated.to_string(),
        );

        let formatted = prompt.format(&args)?;

        // Invoke LLM
        let messages = vec![Message::human(formatted)];
        let result = self.llm.generate(&messages, None, None, None, None).await?;

        let llm_cmd = if let Some(gen) = result.generations.first() {
            gen.message.content().as_text().trim().to_string()
        } else {
            return Err(Error::tool_error("No response from LLM"));
        };

        self.previous_command = llm_cmd.clone();
        Ok(llm_cmd)
    }

    /// Run the crawler on the current page and return simplified representation.
    pub async fn crawl(&mut self) -> Result<Vec<String>, Error> {
        self.crawler.crawl().await
    }

    /// Navigate to a URL.
    pub async fn go_to_page(&mut self, url: &str) -> Result<(), Error> {
        self.crawler.go_to_page(url).await
    }

    /// Execute a browser command generated by the LLM.
    ///
    /// # Arguments
    /// * `command` - Command string like "CLICK 1", "SCROLL DOWN", "TYPE 2 \"text\""
    pub async fn execute_command(&mut self, command: &str) -> Result<(), Error> {
        let command = command.trim();

        if command.starts_with("SCROLL ") {
            let direction = command.strip_prefix("SCROLL ").unwrap().to_lowercase();
            self.crawler.scroll(&direction).await?;
        } else if command.starts_with("CLICK ") {
            let id_str = command.strip_prefix("CLICK ").unwrap();
            let id: i32 = id_str
                .parse()
                .map_err(|e| Error::tool_error(format!("Invalid CLICK id '{}': {}", id_str, e)))?;
            self.crawler.click(id).await?;
        } else if command.starts_with("TYPE ") {
            let rest = command.strip_prefix("TYPE ").unwrap();
            let parts: Vec<&str> = rest.splitn(2, ' ').collect();
            if parts.len() != 2 {
                return Err(Error::tool_error(format!(
                    "Invalid TYPE command format: {}",
                    command
                )));
            }
            let id: i32 = parts[0]
                .parse()
                .map_err(|e| Error::tool_error(format!("Invalid TYPE id '{}': {}", parts[0], e)))?;
            let text = parts[1].trim_matches('"');
            self.crawler.type_text(id, text).await?;
        } else if command.starts_with("TYPESUBMIT ") {
            let rest = command.strip_prefix("TYPESUBMIT ").unwrap();
            let parts: Vec<&str> = rest.splitn(2, ' ').collect();
            if parts.len() != 2 {
                return Err(Error::tool_error(format!(
                    "Invalid TYPESUBMIT command format: {}",
                    command
                )));
            }
            let id: i32 = parts[0]
                .parse()
                .map_err(|e| Error::tool_error(format!("Invalid TYPESUBMIT id '{}': {}", parts[0], e)))?;
            let text = parts[1].trim_matches('"');
            self.crawler.type_text(id, text).await?;
            self.crawler.enter().await?;
        } else {
            return Err(Error::tool_error(format!("Unknown command: {}", command)));
        }

        Ok(())
    }

    /// Get the objective.
    pub fn objective(&self) -> &str {
        &self.objective
    }

    /// Get the previous command.
    pub fn previous_command(&self) -> &str {
        &self.previous_command
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_parse_scroll_command() {
        let command = "SCROLL DOWN";
        assert!(command.starts_with("SCROLL "));
        let direction = command.strip_prefix("SCROLL ").unwrap();
        assert_eq!(direction.to_lowercase(), "down");
    }

    #[test]
    fn test_parse_click_command() {
        let command = "CLICK 42";
        assert!(command.starts_with("CLICK "));
        let id_str = command.strip_prefix("CLICK ").unwrap();
        let id: i32 = id_str.parse().unwrap();
        assert_eq!(id, 42);
    }

    #[test]
    fn test_parse_type_command() {
        let command = "TYPE 7 \"hello world\"";
        assert!(command.starts_with("TYPE "));
        let rest = command.strip_prefix("TYPE ").unwrap();
        let parts: Vec<&str> = rest.splitn(2, ' ').collect();
        assert_eq!(parts.len(), 2);
        let id: i32 = parts[0].parse().unwrap();
        assert_eq!(id, 7);
        let text = parts[1].trim_matches('"');
        assert_eq!(text, "hello world");
    }

    #[test]
    fn test_parse_typesubmit_command() {
        let command = "TYPESUBMIT 8 \"search query\"";
        assert!(command.starts_with("TYPESUBMIT "));
        let rest = command.strip_prefix("TYPESUBMIT ").unwrap();
        let parts: Vec<&str> = rest.splitn(2, ' ').collect();
        assert_eq!(parts.len(), 2);
        let id: i32 = parts[0].parse().unwrap();
        assert_eq!(id, 8);
        let text = parts[1].trim_matches('"');
        assert_eq!(text, "search query");
    }

    #[test]
    fn test_url_truncation() {
        let url = "https://www.example.com/very/long/path/that/exceeds/one/hundred/characters/and/should/be/truncated/to/avoid/token/waste";
        let truncated = if url.len() > 100 { &url[..100] } else { url };
        assert_eq!(truncated.len(), 100);
    }

    #[test]
    fn test_browser_content_truncation() {
        let content = "a".repeat(5000);
        let truncated = if content.len() > 4500 {
            &content[..4500]
        } else {
            content.as_str()
        };
        assert_eq!(truncated.len(), 4500);
    }
}
