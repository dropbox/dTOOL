//! Chain that makes API calls and summarizes the responses to answer a question.
//!
//! **Security Note**: This API chain makes HTTP GET requests to URLs generated by an LLM.
//!
//! Exercise care in who is allowed to use this chain. If exposing to end users, consider
//! that users will be able to make arbitrary requests on behalf of the server hosting the code.
//! For example, users could ask the server to make a request to a private API that is only
//! accessible from the server.
//!
//! Control access to who can submit requests using this chain and what network access it has.
//!
//! # Example
//!
//! ```rust,ignore
//! use dashflow_chains::api::APIChain;
//! use dashflow_openai::ChatOpenAI;
//! use std::sync::Arc;
//!
//! // API documentation for a weather API
//! let api_docs = r#"
//! API Base URL: https://api.example.com/weather
//!
//! Endpoints:
//! - GET /current?city={city} - Get current weather for a city
//! - GET /forecast?city={city}&days={days} - Get forecast for a city
//! "#;
//!
//! let llm = Arc::new(ChatOpenAI::default());
//!
//! let chain = APIChain::from_llm_and_api_docs(
//!     llm,
//!     api_docs.to_string(),
//!     vec!["https://api.example.com".to_string()],
//! )?;
//!
//! let result = chain.invoke("What's the weather in San Francisco?").await?;
//! println!("Answer: {}", result);
//! ```

use dashflow::core::http_client;
use dashflow::core::language_models::{ChatModel, LLM};
use dashflow::core::messages::{BaseMessage, HumanMessage};
use dashflow::core::prompts::PromptTemplate;
use reqwest;
use std::collections::HashMap;
use std::sync::Arc;
use url::Url;

/// Extract the scheme and domain from a URL
fn extract_scheme_and_domain(url: &str) -> Result<(String, String), Box<dyn std::error::Error>> {
    let parsed = Url::parse(url)?;
    let scheme = parsed.scheme().to_string();
    let domain = parsed.host_str().ok_or("No host in URL")?.to_string();
    Ok((scheme, domain))
}

/// Check if a URL is in the allowed domains
fn check_in_allowed_domain(url: &str, limit_to_domains: &[String]) -> bool {
    let Ok((scheme, domain)) = extract_scheme_and_domain(url) else {
        return false;
    };

    for allowed_domain in limit_to_domains {
        let Ok((allowed_scheme, allowed_domain_str)) = extract_scheme_and_domain(allowed_domain)
        else {
            continue;
        };

        if scheme == allowed_scheme && domain == allowed_domain_str {
            return true;
        }
    }

    false
}

/// Chain that makes API calls and summarizes responses to answer questions.
///
/// This chain uses an LLM to:
/// 1. Generate an API URL from documentation and a question
/// 2. Make an HTTP GET request to that URL
/// 3. Summarize the API response to answer the original question
///
/// # Security
///
/// This chain allows LLM-generated HTTP requests. You must specify allowed domains
/// using `limit_to_domains` to prevent requests to arbitrary URLs.
pub struct APIChain {
    /// The language model to use (can be `ChatModel` or LLM)
    llm: LLMType,
    /// API documentation describing available endpoints
    api_docs: String,
    /// Prompt template for generating API URLs
    api_url_prompt: PromptTemplate,
    /// Prompt template for summarizing API responses
    api_response_prompt: PromptTemplate,
    /// Allowed domains for API requests (required for security)
    limit_to_domains: Vec<String>,
    /// HTTP client for making requests
    http_client: reqwest::Client,
}

/// Enum to hold either a `ChatModel` or LLM
#[allow(clippy::upper_case_acronyms)] // LLM is a well-known domain acronym in AI/ML
enum LLMType {
    Chat(Arc<dyn ChatModel>),
    LLM(Arc<dyn LLM>),
}

impl APIChain {
    /// Create a new `APIChain` from an LLM and API documentation.
    ///
    /// # Arguments
    ///
    /// * `llm` - The language model to use for generating URLs and summarizing responses
    /// * `api_docs` - Documentation describing the API endpoints
    /// * `limit_to_domains` - List of allowed domains (e.g., `vec!["https://api.example.com"]`)
    ///
    /// # Security
    ///
    /// You **must** provide `limit_to_domains` to restrict which URLs the chain can access.
    /// An empty list means no domains are allowed.
    pub fn from_llm_chat(
        llm: Arc<dyn ChatModel>,
        api_docs: String,
        limit_to_domains: Vec<String>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        Self::validate_domains(&limit_to_domains)?;

        Ok(Self {
            llm: LLMType::Chat(llm),
            api_docs,
            api_url_prompt: default_api_url_prompt(),
            api_response_prompt: default_api_response_prompt(),
            limit_to_domains,
            http_client: http_client::create_llm_client()?,
        })
    }

    /// Create a new `APIChain` from an LLM (non-chat) and API documentation.
    pub fn from_llm(
        llm: Arc<dyn LLM>,
        api_docs: String,
        limit_to_domains: Vec<String>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        Self::validate_domains(&limit_to_domains)?;

        Ok(Self {
            llm: LLMType::LLM(llm),
            api_docs,
            api_url_prompt: default_api_url_prompt(),
            api_response_prompt: default_api_response_prompt(),
            limit_to_domains,
            http_client: http_client::create_llm_client()?,
        })
    }

    /// Set custom prompts
    #[must_use]
    pub fn with_prompts(
        mut self,
        api_url_prompt: PromptTemplate,
        api_response_prompt: PromptTemplate,
    ) -> Self {
        self.api_url_prompt = api_url_prompt;
        self.api_response_prompt = api_response_prompt;
        self
    }

    /// Validate that domains are provided and non-empty
    fn validate_domains(domains: &[String]) -> Result<(), &'static str> {
        if domains.is_empty() {
            return Err(
                "You must specify a list of domains to limit access using `limit_to_domains`",
            );
        }
        Ok(())
    }

    /// Generate the API URL using the LLM
    async fn generate_api_url(&self, question: &str) -> Result<String, Box<dyn std::error::Error>> {
        let mut inputs = HashMap::new();
        inputs.insert("api_docs".to_string(), self.api_docs.clone());
        inputs.insert("question".to_string(), question.to_string());

        let prompt_text = self.api_url_prompt.format(&inputs)?;

        let url = match &self.llm {
            LLMType::Chat(chat) => {
                let message: BaseMessage = HumanMessage::new(prompt_text).into();
                let result = chat.generate(&[message], None, None, None, None).await?;
                result
                    .generations
                    .first()
                    .map(dashflow::core::language_models::ChatGeneration::text)
                    .ok_or("No response from LLM")?
            }
            LLMType::LLM(llm) => {
                let result = llm.generate(&[prompt_text], None, None).await?;
                result
                    .generations
                    .first()
                    .and_then(|g| g.first())
                    .map(|gen| gen.text.clone())
                    .ok_or("No response from LLM")?
            }
        };

        Ok(url.trim().to_string())
    }

    /// Make HTTP GET request to the API URL
    ///
    /// Uses size-limited reading to prevent memory exhaustion from large responses.
    async fn fetch_api_response(&self, url: &str) -> Result<String, Box<dyn std::error::Error>> {
        let response = self.http_client.get(url).send().await?;
        // Use size-limited read to prevent memory exhaustion from large responses
        let text =
            http_client::read_text_with_limit(response, http_client::DEFAULT_RESPONSE_SIZE_LIMIT)
                .await?;
        Ok(text)
    }

    /// Summarize the API response using the LLM
    async fn summarize_response(
        &self,
        question: &str,
        api_url: &str,
        api_response: &str,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let mut inputs = HashMap::new();
        inputs.insert("api_docs".to_string(), self.api_docs.clone());
        inputs.insert("question".to_string(), question.to_string());
        inputs.insert("api_url".to_string(), api_url.to_string());
        inputs.insert("api_response".to_string(), api_response.to_string());

        let prompt_text = self.api_response_prompt.format(&inputs)?;

        let summary = match &self.llm {
            LLMType::Chat(chat) => {
                let message: BaseMessage = HumanMessage::new(prompt_text).into();
                let result = chat.generate(&[message], None, None, None, None).await?;
                result
                    .generations
                    .first()
                    .map(dashflow::core::language_models::ChatGeneration::text)
                    .ok_or("No response from LLM")?
            }
            LLMType::LLM(llm) => {
                let result = llm.generate(&[prompt_text], None, None).await?;
                result
                    .generations
                    .first()
                    .and_then(|g| g.first())
                    .map(|gen| gen.text.clone())
                    .ok_or("No response from LLM")?
            }
        };

        Ok(summary)
    }

    /// Invoke the API chain with a question.
    ///
    /// # Returns
    ///
    /// A summary of the API response that answers the question.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - The LLM fails to generate a valid URL
    /// - The URL is not in the allowed domains
    /// - The HTTP request fails
    /// - The LLM fails to summarize the response
    pub async fn invoke(
        &self,
        question: impl Into<String>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let question = question.into();

        // Step 1: Generate API URL from question
        let api_url = self.generate_api_url(&question).await?;

        // Step 2: Validate URL is in allowed domains
        if !check_in_allowed_domain(&api_url, &self.limit_to_domains) {
            return Err(format!(
                "Generated URL '{}' is not in the allowed domains: {:?}",
                api_url, self.limit_to_domains
            )
            .into());
        }

        // Step 3: Fetch API response
        let api_response = self.fetch_api_response(&api_url).await?;

        // Step 4: Summarize response to answer question
        let answer = self
            .summarize_response(&question, &api_url, &api_response)
            .await?;

        Ok(answer)
    }
}

/// Default prompt template for generating API URLs
#[must_use]
pub fn default_api_url_prompt() -> PromptTemplate {
    #[allow(clippy::expect_used)]
    let prompt = PromptTemplate::from_template(
        r"You are given the below API Documentation:
{api_docs}
Using this documentation, generate the full API url to call for answering the user question.
You should build the API url in order to get a response that is as short as possible, while still getting the necessary information to answer the question. Pay attention to deliberately exclude any unnecessary pieces of data in the API call.

Question:{question}
API url:",
    )
    .expect("Valid prompt template");
    prompt
}

/// Default prompt template for summarizing API responses
#[must_use]
pub fn default_api_response_prompt() -> PromptTemplate {
    #[allow(clippy::expect_used)]
    let prompt = PromptTemplate::from_template(
        r"You are given the below API Documentation:
{api_docs}
Using this documentation, generate the full API url to call for answering the user question.
You should build the API url in order to get a response that is as short as possible, while still getting the necessary information to answer the question. Pay attention to deliberately exclude any unnecessary pieces of data in the API call.

Question:{question}
API url: {api_url}

Here is the response from the API:

{api_response}

Summarize this response to answer the original question.

Summary:",
    )
    .expect("Valid prompt template");
    prompt
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_scheme_and_domain() {
        let (scheme, domain) =
            extract_scheme_and_domain("https://api.example.com/path").expect("Valid URL");
        assert_eq!(scheme, "https");
        assert_eq!(domain, "api.example.com");

        let (scheme, domain) =
            extract_scheme_and_domain("http://localhost:8080").expect("Valid URL");
        assert_eq!(scheme, "http");
        assert_eq!(domain, "localhost");
    }

    #[test]
    fn test_check_in_allowed_domain() {
        let allowed = vec!["https://api.example.com".to_string()];

        assert!(check_in_allowed_domain(
            "https://api.example.com/endpoint",
            &allowed
        ));
        assert!(!check_in_allowed_domain(
            "https://malicious.com/endpoint",
            &allowed
        ));
        assert!(!check_in_allowed_domain(
            "http://api.example.com/endpoint",
            &allowed
        )); // Different scheme
    }

    #[test]
    fn test_validate_domains_empty() {
        let result = APIChain::validate_domains(&[]);
        assert!(result.is_err());
    }

    #[test]
    fn test_validate_domains_non_empty() {
        let result = APIChain::validate_domains(&["https://api.example.com".to_string()]);
        assert!(result.is_ok(), "Non-empty domain list should be valid");
    }
}
