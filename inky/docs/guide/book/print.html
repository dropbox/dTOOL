<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>inky User Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "light";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">inky User Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>inky is a Rust-native terminal UI library with a React-like component model and flexbox
layout powered by Taffy. It targets high performance, low memory use, and ergonomic UI
composition for terminal applications.</p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<ul>
<li>Fast rendering with incremental diffing.</li>
<li>A component tree API that feels familiar to React users.</li>
<li>Predictable layout via flexbox.</li>
<li>Low memory overhead suitable for long-running CLI tools.</li>
</ul>
<h2 id="stability"><a class="header" href="#stability">Stability</a></h2>
<p>This guide calls out APIs as <strong>stable</strong> or <strong>unstable</strong> where relevant. Stable APIs are
intended to remain compatible within the current 0.x series. Unstable APIs may change
while the library iterates toward 1.0.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Add inky to your Cargo.toml:</p>
<pre><code class="language-toml">[dependencies]
inky = "0.1"
</code></pre>
<p>Minimal example:</p>
<pre><pre class="playground"><code class="language-rust no_run">use inky::prelude::*;

fn main() -&gt; Result&lt;()&gt; {
    App::new()
        .render(|_ctx| {
            BoxNode::new()
                .padding(1)
                .child(TextNode::new("Hello, inky").color(Color::Cyan).bold())
                .into()
        })
        .run()?;
    Ok(())
}</code></pre></pre>
<p>Run an example from the repo:</p>
<pre><code class="language-bash">cargo run --example hello
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<p>This section covers the basic building blocks of inky.</p>
<ul>
<li>Nodes define the UI tree.</li>
<li>Layout uses flexbox rules to position nodes.</li>
<li>Styles apply color, spacing, borders, and text attributes.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodes"><a class="header" href="#nodes">Nodes</a></h1>
<p>Nodes are the fundamental units of the UI tree. The core node types include:</p>
<ul>
<li><code>BoxNode</code>: flexbox container.</li>
<li><code>TextNode</code>: styled text.</li>
<li><code>StaticNode</code>: cached subtree for render efficiency.</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::prelude::*;

let ui = BoxNode::new()
    .padding(1)
    .child(TextNode::new("Title").bold())
    .child(TextNode::new("Body text"))
    .into();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout"><a class="header" href="#layout">Layout</a></h1>
<p>Layout is powered by Taffy and follows CSS flexbox rules. Use style setters on nodes
or the <code>style!{}</code> macro to configure layout properties.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::prelude::*;

let row = BoxNode::new()
    .flex_direction(FlexDirection::Row)
    .justify_content(JustifyContent::SpaceBetween)
    .child(TextNode::new("Left"))
    .child(TextNode::new("Right"))
    .into();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="styling"><a class="header" href="#styling">Styling</a></h1>
<p>Styles control color, spacing, borders, and text attributes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::prelude::*;

let text = TextNode::new("Alert")
    .color(Color::Red)
    .bold()
    .underline();
<span class="boring">}</span></code></pre></pre>
<p>For reusable style sets, use <code>StyleSheet</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::prelude::*;

let mut sheet = StyleSheet::new();
let warning = sheet.define("warning").color(Color::Yellow).bold();

let text = TextNode::new("Caution").style(warning);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components"><a class="header" href="#components">Components</a></h1>
<p>Components are higher-level building blocks built from core nodes and hooks.</p>
<ul>
<li>Interactive components handle input and focus.</li>
<li>Visualization components render data.</li>
<li>AI assistant components provide chat, diff, and markdown views.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interactive-components"><a class="header" href="#interactive-components">Interactive Components</a></h1>
<p>These components are stable and intended for general use:</p>
<ul>
<li><code>Input</code></li>
<li><code>Select</code></li>
<li><code>Progress</code></li>
<li><code>Spinner</code></li>
<li><code>Scroll</code></li>
<li><code>Clickable</code></li>
<li><code>Draggable</code></li>
<li><code>DropZone</code></li>
<li><code>Stack</code></li>
<li><code>Spacer</code></li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::prelude::*;

let form = BoxNode::new()
    .child(Input::new().placeholder("Search"))
    .child(Select::new(vec![
        SelectOption::new("One"),
        SelectOption::new("Two"),
    ]))
    .into();
<span class="boring">}</span></code></pre></pre>
<p>Mouse interaction example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::prelude::*;

let _button = Clickable::new(TextNode::new("Click me"))
    .on_click(|event| {
        println!("Clicked at ({}, {})", event.local_x, event.local_y);
    });

let _draggable = Draggable::new(TextNode::new("Drag me"));
let _drop_zone = DropZone::new(TextNode::new("Drop here"));
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visualization-components"><a class="header" href="#visualization-components">Visualization Components</a></h1>
<p>These components are stable and render inline charts:</p>
<ul>
<li><code>Heatmap</code></li>
<li><code>Sparkline</code></li>
<li><code>Plot</code></li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::prelude::*;

let chart = Plot::new()
    .series(Series::line(vec![0.1, 0.2, 0.4, 0.8]))
    .width(Dimension::percent(100.0))
    .height(Dimension::px(10.0));
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ai-assistant-components"><a class="header" href="#ai-assistant-components">AI Assistant Components</a></h1>
<p>These components are designed for building AI assistant interfaces like OpenAI Codex CLI.</p>
<h2 id="available-components"><a class="header" href="#available-components">Available Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>Markdown</code></td><td>Render markdown with headings, bold, italic, code blocks, lists</td></tr>
<tr><td><code>ChatView</code></td><td>Conversation history with role-aware styling</td></tr>
<tr><td><code>DiffView</code></td><td>Code diffs with add/delete/context lines</td></tr>
<tr><td><code>StatusBar</code></td><td>Animated status indicator with spinners</td></tr>
<tr><td><code>StreamingText</code></td><td>Thread-safe streaming text with ANSI support</td></tr>
</tbody></table>
</div>
<h2 id="streamingtext"><a class="header" href="#streamingtext">StreamingText</a></h2>
<p>Efficient token-by-token rendering for streaming LLM output:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::components::StreamingText;

let stream = StreamingText::new();
let handle = stream.handle();

// Append from any thread
handle.append("Hello ");
handle.append("world!");

let node = stream.to_node();
<span class="boring">}</span></code></pre></pre>
<h3 id="ansi-passthrough"><a class="header" href="#ansi-passthrough">ANSI Passthrough</a></h3>
<p>ANSI parsing is enabled by default:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::components::StreamingText;

let stream = StreamingText::new().parse_ansi(true);
stream.append("\x1b[32mOK\x1b[0m");  // Green "OK"
<span class="boring">}</span></code></pre></pre>
<p>For static text, use <code>TextNode::from_ansi</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::prelude::*;

let text = TextNode::from_ansi("\x1b[31mError:\x1b[0m file not found");
<span class="boring">}</span></code></pre></pre>
<h2 id="chatview"><a class="header" href="#chatview">ChatView</a></h2>
<p>Display conversation history with role-aware styling:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::components::{ChatView, ChatMessage, MessageRole};

let view = ChatView::new()
    .message(ChatMessage::new(MessageRole::User, "Hello"))
    .message(ChatMessage::new(MessageRole::Assistant, "**Hi** there!"));

let node = view.to_node();
<span class="boring">}</span></code></pre></pre>
<p>Message roles: <code>User</code> (cyan), <code>Assistant</code> (green, markdown), <code>System</code> (dim).</p>
<h2 id="statusbar"><a class="header" href="#statusbar">StatusBar</a></h2>
<p>Animated status indicator:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::components::{StatusBar, StatusState};

let mut status = StatusBar::new()
    .state(StatusState::Thinking)
    .message("Processing...");

// Call tick() in your render loop to animate
status.tick();
let node = status.to_node();
<span class="boring">}</span></code></pre></pre>
<p>States: <code>Idle</code> (green), <code>Thinking</code> (yellow, spinner), <code>Executing</code> (blue, spinner), <code>Error</code> (red).</p>
<h2 id="diffview"><a class="header" href="#diffview">DiffView</a></h2>
<p>Code diff display:</p>
<pre><pre class="playground"><code class="language-rust no_run">use inky::components::{DiffView, DiffLine};

let view = DiffView::new()
    .file_path("src/main.rs")
    .line(DiffLine::context(1, "fn main() {"))
    .line(DiffLine::delete(2, "    old_code();"))
    .line(DiffLine::add(2, "    new_code();"))
    .line(DiffLine::context(3, "}"));

let node = view.to_node();</code></pre></pre>
<p>See <a href="components/../../../USAGE.html">docs/USAGE.md</a> for complete API reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-widgets"><a class="header" href="#custom-widgets">Custom Widgets</a></h1>
<p>Implement the <code>Widget</code> trait when you need custom rendering logic that can't be expressed with the built-in components.</p>
<h2 id="the-widget-trait"><a class="header" href="#the-widget-trait">The Widget Trait</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::node::{CustomNode, Widget, WidgetContext};
use inky::prelude::{Color, Node};
use inky::render::{Cell, Painter};

struct Gauge {
    value: f32,
}

impl Widget for Gauge {
    fn render(&amp;self, ctx: &amp;WidgetContext, painter: &amp;mut Painter) {
        let filled = (ctx.width as f32 * self.value) as u16;
        for x in 0..filled.min(ctx.width) {
            let cell = Cell::new('=').with_fg(Color::Green);
            painter.buffer_mut().set(ctx.x + x, ctx.y, cell);
        }
    }

    fn measure(&amp;self, available_width: u16, _available_height: u16) -&gt; (u16, u16) {
        (available_width, 1)
    }
}

// Convert to Node for use in layouts
let node: Node = CustomNode::new(Gauge { value: 0.7 }).into();
<span class="boring">}</span></code></pre></pre>
<h2 id="widgetcontext"><a class="header" href="#widgetcontext">WidgetContext</a></h2>
<p>The <code>WidgetContext</code> provides layout information:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>x</code></td><td><code>u16</code></td><td>Absolute X position</td></tr>
<tr><td><code>y</code></td><td><code>u16</code></td><td>Absolute Y position</td></tr>
<tr><td><code>width</code></td><td><code>u16</code></td><td>Allocated width</td></tr>
<tr><td><code>height</code></td><td><code>u16</code></td><td>Allocated height</td></tr>
</tbody></table>
</div>
<h2 id="measure-method"><a class="header" href="#measure-method">measure() Method</a></h2>
<p>The <code>measure()</code> method tells the layout engine how much space the widget needs:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn measure(&amp;self, available_width: u16, available_height: u16) -&gt; (u16, u16) {
    // Return (width, height)
    (available_width, 1)  // Full width, 1 row tall
}
<span class="boring">}</span></code></pre></pre>
<p>Return values:</p>
<ul>
<li><code>(0, 0)</code> - Widget uses no space</li>
<li><code>(available_width, 1)</code> - Full width, single line</li>
<li><code>(specific, specific)</code> - Fixed size</li>
</ul>
<h2 id="example-progress-meter"><a class="header" href="#example-progress-meter">Example: Progress Meter</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::node::{CustomNode, Widget, WidgetContext};
use inky::prelude::{Color, Node};
use inky::render::{Cell, Painter};

struct ProgressMeter {
    value: f32,
    label: String,
}

impl Widget for ProgressMeter {
    fn render(&amp;self, ctx: &amp;WidgetContext, painter: &amp;mut Painter) {
        let bar_width = ctx.width.saturating_sub(self.label.len() as u16 + 3);
        let filled = (bar_width as f32 * self.value) as u16;

        // Draw label
        for (i, ch) in self.label.chars().enumerate() {
            let cell = Cell::new(ch).with_fg(Color::White);
            painter.buffer_mut().set(ctx.x + i as u16, ctx.y, cell);
        }

        // Draw bar
        let bar_start = ctx.x + self.label.len() as u16 + 1;
        painter.buffer_mut().set(bar_start, ctx.y, Cell::new('['));

        for x in 0..bar_width {
            let ch = if x &lt; filled { '#' } else { '-' };
            let color = if x &lt; filled { Color::Green } else { Color::DarkGray };
            painter.buffer_mut().set(bar_start + 1 + x, ctx.y, Cell::new(ch).with_fg(color));
        }

        painter.buffer_mut().set(bar_start + bar_width + 1, ctx.y, Cell::new(']'));
    }

    fn measure(&amp;self, available_width: u16, _available_height: u16) -&gt; (u16, u16) {
        (available_width, 1)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="using-custom-widgets-in-layouts"><a class="header" href="#using-custom-widgets-in-layouts">Using Custom Widgets in Layouts</a></h2>
<p>Custom widgets integrate with flexbox like any other node:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::prelude::*;

let layout = BoxNode::new()
    .flex_direction(FlexDirection::Column)
    .gap(1.0)
    .child(TextNode::new("CPU Usage:"))
    .child(CustomNode::new(Gauge { value: 0.45 }))
    .child(TextNode::new("Memory:"))
    .child(CustomNode::new(Gauge { value: 0.72 }))
    .into();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hooks"><a class="header" href="#hooks">Hooks</a></h1>
<p>Hooks provide reactive state and event wiring for components.</p>
<p>Stable hooks:</p>
<ul>
<li><code>use_signal</code></li>
<li><code>use_input</code></li>
<li><code>use_focus</code></li>
<li><code>use_interval</code></li>
<li><code>use_mouse</code></li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::prelude::*;

let count = use_signal(0);

let ui = BoxNode::new()
    .child(TextNode::new(format!("Count: {}", count.get())))
    .child(
        Input::new()
            .on_submit(move |_| count.update(|n| *n += 1)),
    )
    .into();
<span class="boring">}</span></code></pre></pre>
<p>For higher-level mouse interactions (click, drag, drop), use <code>Clickable</code>,
<code>Draggable</code>, and <code>DropZone</code> components.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-app-loop"><a class="header" href="#async-app-loop">Async App Loop</a></h1>
<p>Enable the <code>async</code> feature to use <code>AsyncApp</code> with Tokio:</p>
<pre><code class="language-toml">inky = { version = "0.1", features = ["async"] }
</code></pre>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<pre><pre class="playground"><code class="language-rust no_run">use inky::app::AsyncApp;
use inky::prelude::*;

#[derive(Clone, Default)]
struct AppState {
    text: String,
}

#[derive(Clone)]
enum Msg {
    Append(String),
    Quit,
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = AsyncApp::new()
        .state(AppState::default())
        .message_type::&lt;Msg&gt;()
        .render(|ctx| TextNode::new(&amp;ctx.state.text).into())
        .on_message(|state, msg| {
            match msg {
                Msg::Append(text) =&gt; state.text.push_str(&amp;text),
                Msg::Quit =&gt; return true,
            }
            false
        });

    let handle = app.async_handle();
    tokio::spawn(async move {
        handle.send(Msg::Append("Hello".into()));
        handle.render();
    });

    app.run_async().await
}</code></pre></pre>
<h2 id="asyncapphandle"><a class="header" href="#asyncapphandle">AsyncAppHandle</a></h2>
<p>The <code>AsyncAppHandle</code> allows background tasks to communicate with the UI:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>send(msg)</code></td><td>Send a message to the app</td></tr>
<tr><td><code>render()</code></td><td>Request a re-render</td></tr>
</tbody></table>
</div>
<p>This enables patterns like:</p>
<ul>
<li>Streaming API responses</li>
<li>Background file operations</li>
<li>Timer-based updates</li>
<li>WebSocket event handling</li>
</ul>
<h2 id="example-streaming-output"><a class="header" href="#example-streaming-output">Example: Streaming Output</a></h2>
<pre><pre class="playground"><code class="language-rust no_run">use inky::app::AsyncApp;
use inky::prelude::*;

#[derive(Clone, Default)]
struct State {
    output: String,
}

#[derive(Clone)]
enum Msg {
    AppendToken(String),
}

async fn stream_tokens(handle: AsyncAppHandle&lt;State, Msg&gt;) {
    let tokens = vec!["Hello", " ", "world", "!"];
    for token in tokens {
        handle.send(Msg::AppendToken(token.into()));
        handle.render();
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = AsyncApp::new()
        .state(State::default())
        .message_type::&lt;Msg&gt;()
        .render(|ctx| TextNode::new(&amp;ctx.state.output).into())
        .on_message(|state, msg| {
            match msg {
                Msg::AppendToken(t) =&gt; state.output.push_str(&amp;t),
            }
            false
        });

    let handle = app.async_handle();
    tokio::spawn(stream_tokens(handle));

    app.run_async().await
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ai-tooling"><a class="header" href="#ai-tooling">AI Tooling</a></h1>
<p>Inky includes helper APIs for agent-style workflows. These APIs are currently
<strong>unstable</strong> and may change in the 0.x series.</p>
<h2 id="perception-api"><a class="header" href="#perception-api">Perception API</a></h2>
<p><code>Perception</code> turns a rendered buffer into structured signals for an agent or
automation layer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::perception::Perception;
use inky::render::{Buffer, Cell};

let mut buffer = Buffer::new(5, 1);
buffer.set(0, 0, Cell::new('H'));
buffer.set(1, 0, Cell::new('i'));

let perception = Perception::new(&amp;buffer);
let text = perception.as_text();
<span class="boring">}</span></code></pre></pre>
<h3 id="text-extraction"><a class="header" href="#text-extraction">Text Extraction</a></h3>
<ul>
<li><code>as_text()</code> - Plain text content, suitable for LLM context.</li>
<li><code>as_marked_text()</code> - Text with inline style markers like <code>[bold]text[/bold]</code>.</li>
<li><code>as_tokens()</code> - Structured <code>Token</code> spans with position and style metadata.</li>
</ul>
<h3 id="change-detection"><a class="header" href="#change-detection">Change Detection</a></h3>
<p>Track changes between frames to focus agent attention:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::perception::Perception;
use inky::render::Buffer;

let prev = Buffer::new(80, 24);
let current = Buffer::new(80, 24);

let diff = Perception::semantic_diff(&amp;prev, &amp;current);
println!("Summary: {}", diff.summary());

for (row, content) in &amp;diff.added_lines {
    println!("Added at row {}: {}", row, content);
}
for (row, content) in &amp;diff.modified_lines {
    println!("Changed at row {}: {}", row, content);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="region-reading"><a class="header" href="#region-reading">Region Reading</a></h3>
<p>Read specific areas or search for content:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::perception::{Perception, Region};
use inky::render::Buffer;

let buffer = Buffer::new(80, 24);
let perception = Perception::new(&amp;buffer);

// Read a rectangular region
let region = Region::new(10, 5, 20, 3);
let content = perception.read_region(&amp;region);

// Find all occurrences of a string
let matches = perception.find("error");
for (x, y) in matches {
    println!("Found at ({}, {})", x, y);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="image-snapshots"><a class="header" href="#image-snapshots">Image snapshots</a></h3>
<p>When the optional <code>image</code> feature is enabled, you can capture PNG snapshots:</p>
<pre><code class="language-toml">inky-tui = { version = "0.1", features = ["image"] }
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::perception::Perception;
use inky::render::Buffer;

let buffer = Buffer::new(80, 24);
let perception = Perception::new(&amp;buffer);
let png_bytes = perception.as_image(2);
let png_base64 = perception.as_image_base64(2);
<span class="boring">}</span></code></pre></pre>
<h2 id="shared-memory-perception"><a class="header" href="#shared-memory-perception">Shared Memory Perception</a></h2>
<p><code>SharedPerception</code> lets external processes read terminal state from shared
memory without copying. This is useful for AI agents that run out of process.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::perception::{discover_shared_buffers, SharedPerception};

let buffers = discover_shared_buffers();
if let Some((pid, path)) = buffers.first() {
    if let Ok(mut perception) = SharedPerception::open(path) {
        if matches!(perception.poll_update(), Ok(true)) {
            let text = perception.as_text();
            println!("PID {}:\n{}", pid, text);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="clipboard-api"><a class="header" href="#clipboard-api">Clipboard API</a></h2>
<p><code>Clipboard</code> provides OSC 52 clipboard interactions for terminals that support
it.</p>
<pre><pre class="playground"><code class="language-rust">use inky::clipboard::{Clipboard, ClipboardSelection};

fn main() -&gt; std::io::Result&lt;()&gt; {
    Clipboard::copy("Hello from inky")?;
    Clipboard::copy_to_selection("Primary selection", ClipboardSelection::Primary)?;
    Ok(())
}</code></pre></pre>
<p>For paste workflows, request the paste sequence and parse the response:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inky::clipboard::Clipboard;

Clipboard::request_paste()?;
<span class="boring">}</span></code></pre></pre>
<p>Then call <code>Clipboard::parse_paste_response</code> on the incoming terminal payload.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>The repo ships with example programs that demonstrate common patterns:</p>
<pre><code class="language-bash">cargo run --example hello
cargo run --example counter
cargo run --example widgets
cargo run --example focus
cargo run --example form
cargo run --example visualization
cargo run --example dashboard
cargo run --example codex_tui
cargo run --example claude_tui
</code></pre>
<p>Each example is documented in its source file to highlight the feature it
illustrates.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<p>This section summarizes the stability of the public API. Stable APIs should remain
compatible within the current 0.x series. Unstable APIs may change as inky evolves.</p>
<h2 id="stable"><a class="header" href="#stable">Stable</a></h2>
<ul>
<li>Core modules: <code>app</code>, <code>diff</code>, <code>layout</code>, <code>node</code>, <code>style</code></li>
<li>Rendering pipeline: <code>render</code> (CPU buffer and painter)</li>
<li>Components: <code>Input</code>, <code>Select</code>, <code>Progress</code>, <code>Spinner</code>, <code>Scroll</code>, <code>Stack</code>, <code>Spacer</code>,
<code>Heatmap</code>, <code>Sparkline</code>, <code>Plot</code></li>
<li>Hooks: <code>use_signal</code>, <code>use_input</code>, <code>use_focus</code>, <code>use_interval</code></li>
<li>Terminal: <code>Terminal</code>, <code>CrosstermBackend</code>, events, signal handling</li>
<li>Styling: <code>StyleSheet</code></li>
</ul>
<h2 id="unstable"><a class="header" href="#unstable">Unstable</a></h2>
<ul>
<li>GPU rendering: <code>render::gpu</code>, <code>DtermBackend</code></li>
<li>AI and agent tooling: <code>perception</code>, <code>clipboard</code></li>
<li>High-level systems: <code>animation</code>, <code>accessibility</code>, <code>elm</code></li>
<li>AI assistant components: <code>Markdown</code>, <code>ChatView</code>, <code>DiffView</code>, <code>StatusBar</code>, <code>Image</code>,
<code>Transform</code></li>
</ul>
<p>If you depend on unstable APIs, be prepared for minor breaking changes in 0.x.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
