/*
 * dterm-core C API
 *
 * High-performance terminal emulation library.
 *
 * This header provides bindings for:
 * - Parser: Low-level VT parsing with callbacks
 * - Grid: Terminal grid manipulation
 * - Terminal: High-level terminal emulation
 * - Search: Trigram-indexed search with bloom filter
 * - Checkpoint: Session persistence and crash recovery
 * - GPU Renderer: wgpu-based GPU rendering (Phase 3.3)
 *
 * Thread Safety: All types are NOT thread-safe.
 * Use external synchronization if needed.
 */

// Enable all FFI functions
#define DTERM_FFI 1

// Enable GPU renderer FFI (requires wgpu)
#define DTERM_GPU 1

// Undefine conflicting macOS macros before redefining
#ifdef PAGE_SIZE
#undef PAGE_SIZE
#endif


#ifndef DTERM_H
#define DTERM_H

/* Generated with cbindgen:0.29.2 */

/* Warning: this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// Data is zstd compressed.
#define HeaderFlags_COMPRESSED (1 << 0)

// Has scrollback data.
#define HeaderFlags_HAS_SCROLLBACK (1 << 1)

// Maximum number of DRCS font slots.
#define MAX_FONT_SLOTS 4

// Maximum glyphs per font (96 for DRCS96, 94 for DRCS94).
#define MAX_GLYPHS_PER_FONT 96

// Default character cell width in pixels.
#define DEFAULT_CELL_WIDTH 10

// Default character cell height in pixels.
#define DEFAULT_CELL_HEIGHT 20

// Maximum cell width in pixels.
#define MAX_CELL_WIDTH 15

// Maximum cell height in pixels.
#define MAX_CELL_HEIGHT 24

// Starting character code for DRCS (space).
#define DRCS_START_CHAR 32

// Ending character code for DRCS (DEL-1).
#define DRCS_END_CHAR 127

// Zero Width Joiner (ZWJ) character.
#define ZWJ U'\U0000200D'

// Maximum codepoint that fits directly in char_data (BMP).
#define Cell_MAX_DIRECT_CODEPOINT 65535

// Maximum combining characters per cell (prevents DoS).
#define CellExtra_MAX_COMBINING 16

// Underline color is present (bytes 0-2 of colors array).
#define HAS_UNDERLINE_COLOR (1 << 0)

// Foreground RGB is present (bytes 3-5 of colors array).
#define HAS_FG_RGB (1 << 1)

// Background RGB is present (bytes 6-8 of colors array).
#define HAS_BG_RGB (1 << 2)

// Mask for color presence flags.
#define COLOR_MASK ((HAS_UNDERLINE_COLOR | HAS_FG_RGB) | HAS_BG_RGB)

// Bits 3-15 are available for extended flags.
#define EXTENDED_SHIFT 3

// Maximum dimension for inline images (width or height in pixels).
// Prevents DoS via extremely large images.
#define ITERM_MAX_DIMENSION 10000

// Maximum payload size (1 MB, matching iTerm2's limit).
#define MAX_PAYLOAD_SIZE 1048576

// Maximum dimension for Kitty images (width or height).
// Prevents DoS via extremely large images.
#define KITTY_MAX_DIMENSION 10000

// Default storage quota in bytes (320 MB).
#define DEFAULT_STORAGE_QUOTA ((320 * 1024) * 1024)

// Maximum number of images that can be stored.
#define MAX_IMAGES 10000

// Maximum depth of relative placement chains.
#define MAX_PLACEMENT_CHAIN_DEPTH 8

// Maximum number of animation frames per image.
#define MAX_FRAMES_PER_IMAGE 1000

// Stop/pause at immediate position.
#define AVSPEECH_BOUNDARY_IMMEDIATE 0

// Stop/pause at word boundary.
#define AVSPEECH_BOUNDARY_WORD 1

// Default voice quality.
#define AVSPEECH_SYNTHESIS_VOICE_QUALITY_DEFAULT 0

// Enhanced voice quality.
#define AVSPEECH_SYNTHESIS_VOICE_QUALITY_ENHANCED 1

// Premium voice quality.
#define AVSPEECH_SYNTHESIS_VOICE_QUALITY_PREMIUM 2

// Minimum speech rate.
#define AVSPEECH_UTTERANCE_MINIMUM_SPEECH_RATE 0.0

// Maximum speech rate.
#define AVSPEECH_UTTERANCE_MAXIMUM_SPEECH_RATE 1.0

// Default speech rate.
#define AVSPEECH_UTTERANCE_DEFAULT_SPEECH_RATE 0.5

// espeak-ng output sample rate (Hz).
#define ESPEAK_SAMPLE_RATE 22050

// espeak-ng output format is mono.
#define ESPEAK_CHANNELS 1

// espeak-ng output bits per sample.
#define ESPEAK_BITS_PER_SAMPLE 16

// Maximum number of CSI parameters
#define MAX_PARAMS 16

// Maximum number of intermediate bytes
#define MAX_INTERMEDIATES 4

// Total number of states (for table sizing).
#define State_COUNT 14

// Maximum key length in bytes for plugin storage.
#define PLUGIN_STORAGE_MAX_KEY_LENGTH 256

// Maximum value length in bytes for plugin storage.
#define PLUGIN_STORAGE_MAX_VALUE_LENGTH (64 * 1024)

// Default storage quota per plugin in bytes.
#define PLUGIN_STORAGE_DEFAULT_QUOTA (1024 * 1024)

// Maximum number of color registers supported.
#define MAX_COLOR_REGISTERS 1024

// Maximum Sixel image dimension to prevent DoS attacks.
#define SIXEL_MAX_DIMENSION 10000

// Disambiguate escape codes (send Esc, Alt+key, Ctrl+key using CSI u).
#define KittyKeyboardFlags_DISAMBIGUATE 1

// Report key repeat and release events.
#define KittyKeyboardFlags_REPORT_EVENTS 2

// Report alternate key codes (shifted_key, base_layout_key).
#define KittyKeyboardFlags_REPORT_ALTERNATES 4

// Report all keys as escape codes (including text-generating keys).
#define KittyKeyboardFlags_REPORT_ALL_KEYS 8

// Embed associated text in escape code (requires REPORT_ALL_KEYS).
#define KittyKeyboardFlags_REPORT_TEXT 16

// No modifiers.
#define KittyModifiers_NONE 0

// Shift modifier.
#define KittyModifiers_SHIFT 1

// Alt modifier.
#define KittyModifiers_ALT 2

// Ctrl modifier.
#define KittyModifiers_CTRL 4

// Super (Cmd/Win) modifier.
#define KittyModifiers_SUPER 8

// Hyper modifier.
#define KittyModifiers_HYPER 16

// Meta modifier.
#define KittyModifiers_META 32

// Caps Lock modifier.
#define KittyModifiers_CAPS_LOCK 64

// Num Lock modifier.
#define KittyModifiers_NUM_LOCK 128

// Maximum number of terminals the UI bridge can track.
#define MAX_TERMINALS 256

// Maximum number of events in the queue.
#define MAX_QUEUE 1024

// Maximum number of pending callbacks.
#define MAX_CALLBACKS 64

#if defined(DTERM_GPU)
// Default image memory budget in bytes (64 MB).
#define DEFAULT_IMAGE_BUDGET ((64 * 1024) * 1024)
#endif

#if defined(DTERM_GPU)
// Maximum image dimension in pixels (same as Kitty).
#define MAX_IMAGE_DIMENSION 10000
#endif

#if defined(DTERM_GPU)
// Bold text style flag.
#define FLAG_BOLD 1
#endif

#if defined(DTERM_GPU)
// Dim text style flag.
#define FLAG_DIM 2
#endif

#if defined(DTERM_GPU)
// Underlined text style flag (single underline).
#define FLAG_UNDERLINE 4
#endif

#if defined(DTERM_GPU)
// Blinking text style flag.
#define FLAG_BLINK 8
#endif

#if defined(DTERM_GPU)
// Inverse video (swap fg/bg) flag.
#define FLAG_INVERSE 16
#endif

#if defined(DTERM_GPU)
// Strikethrough text style flag.
#define FLAG_STRIKETHROUGH 32
#endif

#if defined(DTERM_GPU)
// Cell is under the cursor flag.
#define FLAG_IS_CURSOR 64
#endif

#if defined(DTERM_GPU)
// Cell is selected flag.
#define FLAG_IS_SELECTION 128
#endif

#if defined(DTERM_GPU)
// Vertex is for background quad (not glyph) flag.
#define FLAG_IS_BACKGROUND 256
#endif

#if defined(DTERM_GPU)
// Cell uses the default background color.
#define FLAG_DEFAULT_BG 4096
#endif

#if defined(DTERM_GPU)
// Double underline text style flag.
#define FLAG_DOUBLE_UNDERLINE 512
#endif

#if defined(DTERM_GPU)
// Curly underline text style flag (for spell check, etc).
#define FLAG_CURLY_UNDERLINE 1024
#endif

#if defined(DTERM_GPU)
// Vertex is for decoration (underline/strikethrough) quad.
#define FLAG_IS_DECORATION 2048
#endif

#if defined(DTERM_GPU)
// Dotted underline text style flag (SGR 4:4).
#define FLAG_DOTTED_UNDERLINE 8192
#endif

#if defined(DTERM_GPU)
// Dashed underline text style flag (SGR 4:5).
#define FLAG_DASHED_UNDERLINE 16384
#endif

#if defined(DTERM_FFI)
// Error code for FFI callbacks.
typedef enum DtermMediaError {
#if defined(DTERM_FFI)
  // Operation succeeded.
  DTERM_MEDIA_ERROR_OK = 0,
#endif
#if defined(DTERM_FFI)
  // Provider not initialized.
  DTERM_MEDIA_ERROR_NOT_INITIALIZED = 1,
#endif
#if defined(DTERM_FFI)
  // Audio format not supported.
  DTERM_MEDIA_ERROR_UNSUPPORTED_FORMAT = 2,
#endif
#if defined(DTERM_FFI)
  // Language not supported.
  DTERM_MEDIA_ERROR_UNSUPPORTED_LANGUAGE = 3,
#endif
#if defined(DTERM_FFI)
  // Speech recognition failed.
  DTERM_MEDIA_ERROR_RECOGNITION_FAILED = 4,
#endif
#if defined(DTERM_FFI)
  // Voice not found.
  DTERM_MEDIA_ERROR_VOICE_NOT_FOUND = 5,
#endif
#if defined(DTERM_FFI)
  // Speech synthesis failed.
  DTERM_MEDIA_ERROR_SYNTHESIS_FAILED = 6,
#endif
#if defined(DTERM_FFI)
  // Provider-specific error.
  DTERM_MEDIA_ERROR_PROVIDER_ERROR = 7,
#endif
#if defined(DTERM_FFI)
  // Operation was cancelled.
  DTERM_MEDIA_ERROR_CANCELLED = 8,
#endif
} DtermMediaError;
#endif

#if defined(DTERM_FFI)
// Audio format for FFI (matches AudioFormat enum).
typedef enum DtermAudioFormat {
#if defined(DTERM_FFI)
  // 16-bit PCM at 16kHz (common for STT).
  DTERM_AUDIO_FORMAT_PCM16K = 0,
#endif
#if defined(DTERM_FFI)
  // 16-bit PCM at 44.1kHz (high quality).
  DTERM_AUDIO_FORMAT_PCM44K = 1,
#endif
#if defined(DTERM_FFI)
  // Opus codec (efficient for streaming).
  DTERM_AUDIO_FORMAT_OPUS = 2,
#endif
#if defined(DTERM_FFI)
  // AAC codec (Apple ecosystem).
  DTERM_AUDIO_FORMAT_AAC = 3,
#endif
} DtermAudioFormat;
#endif

#if defined(DTERM_FFI)
// Action type for FFI.
typedef enum dterm_action_type_t {
#if defined(DTERM_FFI)
  // Print a character.
  DTERM_ACTION_TYPE_T_PRINT = 0,
#endif
#if defined(DTERM_FFI)
  // Execute a control character.
  DTERM_ACTION_TYPE_T_EXECUTE = 1,
#endif
#if defined(DTERM_FFI)
  // CSI sequence.
  DTERM_ACTION_TYPE_T_CSI = 2,
#endif
#if defined(DTERM_FFI)
  // ESC sequence.
  DTERM_ACTION_TYPE_T_ESC = 3,
#endif
#if defined(DTERM_FFI)
  // OSC sequence.
  DTERM_ACTION_TYPE_T_OSC = 4,
#endif
} dterm_action_type_t;
#endif

#if defined(DTERM_FFI)
// Mouse tracking mode for FFI.
typedef enum DtermMouseMode {
#if defined(DTERM_FFI)
  // No mouse tracking (default).
  DTERM_MOUSE_MODE_NONE = 0,
#endif
#if defined(DTERM_FFI)
  // Normal tracking mode (1000) - report button press/release.
  DTERM_MOUSE_MODE_NORMAL = 1,
#endif
#if defined(DTERM_FFI)
  // Button-event tracking mode (1002) - report press/release and motion while button pressed.
  DTERM_MOUSE_MODE_BUTTON_EVENT = 2,
#endif
#if defined(DTERM_FFI)
  // Any-event tracking mode (1003) - report all motion events.
  DTERM_MOUSE_MODE_ANY_EVENT = 3,
#endif
} DtermMouseMode;
#endif

#if defined(DTERM_FFI)
// Mouse encoding format for FFI.
typedef enum DtermMouseEncoding {
#if defined(DTERM_FFI)
  // X10 compatibility mode - coordinates encoded as single bytes (limited to 223).
  DTERM_MOUSE_ENCODING_X10 = 0,
#endif
#if defined(DTERM_FFI)
  // UTF-8 encoding (1005) - coordinates as UTF-8 characters, supports up to 2015.
  DTERM_MOUSE_ENCODING_UTF8 = 1,
#endif
#if defined(DTERM_FFI)
  // SGR encoding (1006) - coordinates as decimal parameters, supports larger values.
  DTERM_MOUSE_ENCODING_SGR = 2,
#endif
#if defined(DTERM_FFI)
  // URXVT encoding (1015) - decimal parameters without '<' prefix.
  DTERM_MOUSE_ENCODING_URXVT = 3,
#endif
#if defined(DTERM_FFI)
  // SGR pixel mode (1016) - like SGR but coordinates are in pixels.
  DTERM_MOUSE_ENCODING_SGR_PIXEL = 4,
#endif
} DtermMouseEncoding;
#endif

#if defined(DTERM_FFI)
// Search direction.
typedef enum dterm_search_direction_t {
#if defined(DTERM_FFI)
  // Search forward (oldest to newest).
  DTERM_SEARCH_DIRECTION_T_FORWARD = 0,
#endif
#if defined(DTERM_FFI)
  // Search backward (newest to oldest).
  DTERM_SEARCH_DIRECTION_T_BACKWARD = 1,
#endif
} dterm_search_direction_t;
#endif

#if defined(DTERM_FFI)
// Clipboard selection type for FFI.
//
// These correspond to OSC 52 selection parameters.
typedef enum DtermClipboardSelection {
#if defined(DTERM_FFI)
  // System clipboard ('c')
  DTERM_CLIPBOARD_SELECTION_CLIPBOARD = 0,
#endif
#if defined(DTERM_FFI)
  // Primary selection ('p')
  DTERM_CLIPBOARD_SELECTION_PRIMARY = 1,
#endif
#if defined(DTERM_FFI)
  // Secondary selection ('q')
  DTERM_CLIPBOARD_SELECTION_SECONDARY = 2,
#endif
#if defined(DTERM_FFI)
  // Select ('s')
  DTERM_CLIPBOARD_SELECTION_SELECT = 3,
#endif
#if defined(DTERM_FFI)
  // Cut buffer 0 ('0')
  DTERM_CLIPBOARD_SELECTION_CUT_BUFFER0 = 4,
#endif
#if defined(DTERM_FFI)
  // Cut buffer 1 ('1')
  DTERM_CLIPBOARD_SELECTION_CUT_BUFFER1 = 5,
#endif
#if defined(DTERM_FFI)
  // Cut buffer 2 ('2')
  DTERM_CLIPBOARD_SELECTION_CUT_BUFFER2 = 6,
#endif
#if defined(DTERM_FFI)
  // Cut buffer 3 ('3')
  DTERM_CLIPBOARD_SELECTION_CUT_BUFFER3 = 7,
#endif
#if defined(DTERM_FFI)
  // Cut buffer 4 ('4')
  DTERM_CLIPBOARD_SELECTION_CUT_BUFFER4 = 8,
#endif
#if defined(DTERM_FFI)
  // Cut buffer 5 ('5')
  DTERM_CLIPBOARD_SELECTION_CUT_BUFFER5 = 9,
#endif
#if defined(DTERM_FFI)
  // Cut buffer 6 ('6')
  DTERM_CLIPBOARD_SELECTION_CUT_BUFFER6 = 10,
#endif
#if defined(DTERM_FFI)
  // Cut buffer 7 ('7')
  DTERM_CLIPBOARD_SELECTION_CUT_BUFFER7 = 11,
#endif
} DtermClipboardSelection;
#endif

#if defined(DTERM_FFI)
// Window operation type for FFI.
typedef enum DtermWindowOpType {
#if defined(DTERM_FFI)
  // De-iconify (restore from minimized) window (CSI 1 t).
  DTERM_WINDOW_OP_TYPE_DE_ICONIFY = 1,
#endif
#if defined(DTERM_FFI)
  // Iconify (minimize) window (CSI 2 t).
  DTERM_WINDOW_OP_TYPE_ICONIFY = 2,
#endif
#if defined(DTERM_FFI)
  // Move window to pixel position (CSI 3;x;y t).
  DTERM_WINDOW_OP_TYPE_MOVE_WINDOW = 3,
#endif
#if defined(DTERM_FFI)
  // Resize window to pixel dimensions (CSI 4;height;width t).
  DTERM_WINDOW_OP_TYPE_RESIZE_WINDOW_PIXELS = 4,
#endif
#if defined(DTERM_FFI)
  // Raise window to front (CSI 5 t).
  DTERM_WINDOW_OP_TYPE_RAISE_WINDOW = 5,
#endif
#if defined(DTERM_FFI)
  // Lower window to back (CSI 6 t).
  DTERM_WINDOW_OP_TYPE_LOWER_WINDOW = 6,
#endif
#if defined(DTERM_FFI)
  // Refresh/redraw window (CSI 7 t).
  DTERM_WINDOW_OP_TYPE_REFRESH_WINDOW = 7,
#endif
#if defined(DTERM_FFI)
  // Resize text area to cell dimensions (CSI 8;rows;cols t).
  DTERM_WINDOW_OP_TYPE_RESIZE_WINDOW_CELLS = 8,
#endif
#if defined(DTERM_FFI)
  // Report window state (CSI 11 t).
  DTERM_WINDOW_OP_TYPE_REPORT_WINDOW_STATE = 11,
#endif
#if defined(DTERM_FFI)
  // Report window position (CSI 13 t).
  DTERM_WINDOW_OP_TYPE_REPORT_WINDOW_POSITION = 13,
#endif
#if defined(DTERM_FFI)
  // Report text area size in pixels (CSI 14 t).
  DTERM_WINDOW_OP_TYPE_REPORT_WINDOW_SIZE_PIXELS = 14,
#endif
#if defined(DTERM_FFI)
  // Report screen size in pixels (CSI 15 t).
  DTERM_WINDOW_OP_TYPE_REPORT_SCREEN_SIZE_PIXELS = 15,
#endif
#if defined(DTERM_FFI)
  // Report cell size in pixels (CSI 16 t).
  DTERM_WINDOW_OP_TYPE_REPORT_CELL_SIZE_PIXELS = 16,
#endif
#if defined(DTERM_FFI)
  // Report text area size in cells (CSI 18 t).
  DTERM_WINDOW_OP_TYPE_REPORT_TEXT_AREA_CELLS = 18,
#endif
#if defined(DTERM_FFI)
  // Report screen size in cells (CSI 19 t).
  DTERM_WINDOW_OP_TYPE_REPORT_SCREEN_SIZE_CELLS = 19,
#endif
#if defined(DTERM_FFI)
  // Report icon label (CSI 20 t).
  DTERM_WINDOW_OP_TYPE_REPORT_ICON_LABEL = 20,
#endif
#if defined(DTERM_FFI)
  // Report window title (CSI 21 t).
  DTERM_WINDOW_OP_TYPE_REPORT_WINDOW_TITLE = 21,
#endif
#if defined(DTERM_FFI)
  // Push icon/title to stack (CSI 22;mode t).
  DTERM_WINDOW_OP_TYPE_PUSH_TITLE = 22,
#endif
#if defined(DTERM_FFI)
  // Pop icon/title from stack (CSI 23;mode t).
  DTERM_WINDOW_OP_TYPE_POP_TITLE = 23,
#endif
#if defined(DTERM_FFI)
  // Maximize window (CSI 9;0 t).
  DTERM_WINDOW_OP_TYPE_MAXIMIZE_WINDOW = 90,
#endif
#if defined(DTERM_FFI)
  // Enter fullscreen (CSI 10;0 t).
  DTERM_WINDOW_OP_TYPE_ENTER_FULLSCREEN = 100,
#endif
#if defined(DTERM_FFI)
  // Exit fullscreen (CSI 10;1 t).
  DTERM_WINDOW_OP_TYPE_EXIT_FULLSCREEN = 101,
#endif
#if defined(DTERM_FFI)
  // Toggle fullscreen (CSI 10;2 t).
  DTERM_WINDOW_OP_TYPE_TOGGLE_FULLSCREEN = 102,
#endif
} DtermWindowOpType;
#endif

#if defined(DTERM_FFI)
// Shell event type for FFI.
typedef enum DtermShellEventType {
#if defined(DTERM_FFI)
  // Prompt started (OSC 133 ; A).
  DTERM_SHELL_EVENT_TYPE_PROMPT_START = 0,
#endif
#if defined(DTERM_FFI)
  // Command input started (OSC 133 ; B).
  DTERM_SHELL_EVENT_TYPE_COMMAND_START = 1,
#endif
#if defined(DTERM_FFI)
  // Command execution started (OSC 133 ; C).
  DTERM_SHELL_EVENT_TYPE_OUTPUT_START = 2,
#endif
#if defined(DTERM_FFI)
  // Command finished (OSC 133 ; D).
  DTERM_SHELL_EVENT_TYPE_COMMAND_FINISHED = 3,
#endif
#if defined(DTERM_FFI)
  // Working directory changed (OSC 7).
  DTERM_SHELL_EVENT_TYPE_DIRECTORY_CHANGED = 4,
#endif
} DtermShellEventType;
#endif

#if defined(DTERM_FFI)
// Kitty graphics placement location type.
typedef enum DtermKittyPlacementLocation {
#if defined(DTERM_FFI)
  // Placed at absolute cursor position.
  DTERM_KITTY_PLACEMENT_LOCATION_ABSOLUTE = 0,
#endif
#if defined(DTERM_FFI)
  // Virtual placement (for Unicode placeholder mode).
  DTERM_KITTY_PLACEMENT_LOCATION_VIRTUAL = 1,
#endif
#if defined(DTERM_FFI)
  // Relative to another placement.
  DTERM_KITTY_PLACEMENT_LOCATION_RELATIVE = 2,
#endif
} DtermKittyPlacementLocation;
#endif

#if defined(DTERM_FFI)
// Line size for DEC line attributes (DECDHL/DECDWL).
typedef enum DtermLineSize {
#if defined(DTERM_FFI)
  // Normal single-width, single-height line (DECSWL).
  DTERM_LINE_SIZE_SINGLE_WIDTH = 0,
#endif
#if defined(DTERM_FFI)
  // Double-width line (DECDWL) - each character is rendered double-wide.
  DTERM_LINE_SIZE_DOUBLE_WIDTH = 1,
#endif
#if defined(DTERM_FFI)
  // Top half of double-height line (DECDHL).
  DTERM_LINE_SIZE_DOUBLE_HEIGHT_TOP = 2,
#endif
#if defined(DTERM_FFI)
  // Bottom half of double-height line (DECDHL).
  DTERM_LINE_SIZE_DOUBLE_HEIGHT_BOTTOM = 3,
#endif
} DtermLineSize;
#endif

#if defined(DTERM_FFI)
// Shell integration state (OSC 133).
typedef enum DtermShellState {
#if defined(DTERM_FFI)
  // Ground state - waiting for prompt.
  DTERM_SHELL_STATE_GROUND = 0,
#endif
#if defined(DTERM_FFI)
  // Receiving prompt text (after OSC 133 ; A).
  DTERM_SHELL_STATE_RECEIVING_PROMPT = 1,
#endif
#if defined(DTERM_FFI)
  // User is entering command (after OSC 133 ; B).
  DTERM_SHELL_STATE_ENTERING_COMMAND = 2,
#endif
#if defined(DTERM_FFI)
  // Command is executing (after OSC 133 ; C).
  DTERM_SHELL_STATE_EXECUTING = 3,
#endif
} DtermShellState;
#endif

#if defined(DTERM_FFI)
// Output block state for block-based terminal model.
//
// Note: Variants are prefixed with `Block` to avoid C enum name collision
// with `DtermShellState` which also has `EnteringCommand` and `Executing`.
typedef enum DtermBlockState {
#if defined(DTERM_FFI)
  // Only prompt has been received.
  DTERM_BLOCK_STATE_BLOCK_PROMPT_ONLY = 0,
#endif
#if defined(DTERM_FFI)
  // User is entering a command.
  DTERM_BLOCK_STATE_BLOCK_ENTERING_COMMAND = 1,
#endif
#if defined(DTERM_FFI)
  // Command is executing.
  DTERM_BLOCK_STATE_BLOCK_EXECUTING = 2,
#endif
#if defined(DTERM_FFI)
  // Command has completed with exit code.
  DTERM_BLOCK_STATE_BLOCK_COMPLETE = 3,
#endif
} DtermBlockState;
#endif

#if defined(DTERM_FFI)
// Selection type for text selection.
//
// See `tla/Selection.tla` for the formal specification.
enum DtermSelectionType {
#if defined(DTERM_FFI)
  // Character-by-character selection (single click + drag).
  DTERM_SELECTION_TYPE_SIMPLE = 0,
#endif
#if defined(DTERM_FFI)
  // Rectangular block selection (Alt + click + drag).
  DTERM_SELECTION_TYPE_BLOCK = 1,
#endif
#if defined(DTERM_FFI)
  // Semantic selection - words, URLs, etc. (double-click).
  DTERM_SELECTION_TYPE_SEMANTIC = 2,
#endif
#if defined(DTERM_FFI)
  // Full line selection (triple-click).
  DTERM_SELECTION_TYPE_LINES = 3,
#endif
};
typedef uint8_t DtermSelectionType;
#endif

#if defined(DTERM_FFI)
// UI state enum for FFI.
typedef enum DtermUIState {
#if defined(DTERM_FFI)
  // No work in progress, ready to process events.
  DTERM_UI_STATE_IDLE = 0,
#endif
#if defined(DTERM_FFI)
  // Currently processing an event.
  DTERM_UI_STATE_PROCESSING = 1,
#endif
#if defined(DTERM_FFI)
  // Waiting for render completion.
  DTERM_UI_STATE_RENDERING = 2,
#endif
#if defined(DTERM_FFI)
  // Waiting for callback completion.
  DTERM_UI_STATE_WAITING_FOR_CALLBACK = 3,
#endif
#if defined(DTERM_FFI)
  // System is shutting down.
  DTERM_UI_STATE_SHUTTING_DOWN = 4,
#endif
} DtermUIState;
#endif

#if defined(DTERM_FFI)
// Terminal state enum for FFI.
typedef enum DtermUITerminalState {
#if defined(DTERM_FFI)
  // Terminal slot is available.
  DTERM_UI_TERMINAL_STATE_INACTIVE = 0,
#endif
#if defined(DTERM_FFI)
  // Terminal is active and usable.
  DTERM_UI_TERMINAL_STATE_ACTIVE = 1,
#endif
#if defined(DTERM_FFI)
  // Terminal has been disposed (cannot be reactivated).
  DTERM_UI_TERMINAL_STATE_DISPOSED = 2,
#endif
} DtermUITerminalState;
#endif

#if defined(DTERM_FFI)
// Error codes for UI Bridge operations.
typedef enum DtermUIErrorCode {
#if defined(DTERM_FFI)
  // Operation succeeded.
  DTERM_UI_ERROR_CODE_OK = 0,
#endif
#if defined(DTERM_FFI)
  // Event queue is full.
  DTERM_UI_ERROR_CODE_QUEUE_FULL = 1,
#endif
#if defined(DTERM_FFI)
  // System is shutting down.
  DTERM_UI_ERROR_CODE_SHUTTING_DOWN = 2,
#endif
#if defined(DTERM_FFI)
  // Terminal ID is invalid or out of range.
  DTERM_UI_ERROR_CODE_INVALID_TERMINAL_ID = 3,
#endif
#if defined(DTERM_FFI)
  // Terminal is not in the expected state.
  DTERM_UI_ERROR_CODE_INVALID_TERMINAL_STATE = 4,
#endif
#if defined(DTERM_FFI)
  // Callback ID is already pending.
  DTERM_UI_ERROR_CODE_DUPLICATE_CALLBACK = 5,
#endif
#if defined(DTERM_FFI)
  // No event to process.
  DTERM_UI_ERROR_CODE_NO_EVENT_PENDING = 6,
#endif
#if defined(DTERM_FFI)
  // Invalid state transition.
  DTERM_UI_ERROR_CODE_INVALID_STATE_TRANSITION = 7,
#endif
#if defined(DTERM_FFI)
  // Null pointer passed to FFI function.
  DTERM_UI_ERROR_CODE_NULL_POINTER = 8,
#endif
} DtermUIErrorCode;
#endif

#if defined(DTERM_FFI)
// Event kind enum for FFI.
typedef enum DtermUIEventKind {
#if defined(DTERM_FFI)
  // User input to a terminal.
  DTERM_UI_EVENT_KIND_INPUT = 0,
#endif
#if defined(DTERM_FFI)
  // Terminal resize request.
  DTERM_UI_EVENT_KIND_RESIZE = 1,
#endif
#if defined(DTERM_FFI)
  // Render request for a terminal.
  DTERM_UI_EVENT_KIND_RENDER = 2,
#endif
#if defined(DTERM_FFI)
  // Create a new terminal.
  DTERM_UI_EVENT_KIND_CREATE_TERMINAL = 3,
#endif
#if defined(DTERM_FFI)
  // Destroy an existing terminal.
  DTERM_UI_EVENT_KIND_DESTROY_TERMINAL = 4,
#endif
#if defined(DTERM_FFI)
  // Request a callback.
  DTERM_UI_EVENT_KIND_REQUEST_CALLBACK = 5,
#endif
#if defined(DTERM_FFI)
  // System shutdown.
  DTERM_UI_EVENT_KIND_SHUTDOWN = 6,
#endif
} DtermUIEventKind;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Cursor style for FFI.
//
// Matches the cursor styles supported by terminal emulators.
typedef enum DtermCursorStyle {
#if (defined(DTERM_GPU) && defined(DTERM_FFI))
  // Solid block cursor
  DTERM_CURSOR_STYLE_BLOCK = 0,
#endif
#if (defined(DTERM_GPU) && defined(DTERM_FFI))
  // Horizontal underline cursor
  DTERM_CURSOR_STYLE_UNDERLINE = 1,
#endif
#if (defined(DTERM_GPU) && defined(DTERM_FFI))
  // Vertical bar cursor
  DTERM_CURSOR_STYLE_BAR = 2,
#endif
} DtermCursorStyle;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Frame status for FFI.
typedef enum DtermFrameStatus {
#if (defined(DTERM_GPU) && defined(DTERM_FFI))
  // Frame is ready
  DTERM_FRAME_STATUS_READY = 0,
#endif
#if (defined(DTERM_GPU) && defined(DTERM_FFI))
  // Timeout expired
  DTERM_FRAME_STATUS_TIMEOUT = 1,
#endif
#if (defined(DTERM_GPU) && defined(DTERM_FFI))
  // Frame was cancelled
  DTERM_FRAME_STATUS_CANCELLED = 2,
#endif
} DtermFrameStatus;
#endif

#if defined(DTERM_GPU)
// Blend mode for background images.
typedef enum DtermBlendMode {
#if defined(DTERM_GPU)
  // Standard alpha blend.
  DTERM_BLEND_MODE_NORMAL = 0,
#endif
#if defined(DTERM_GPU)
  // Multiply source and destination colors.
  DTERM_BLEND_MODE_MULTIPLY = 1,
#endif
#if defined(DTERM_GPU)
  // Screen blend (inverse multiply).
  DTERM_BLEND_MODE_SCREEN = 2,
#endif
#if defined(DTERM_GPU)
  // Overlay blend (multiply or screen depending on base).
  DTERM_BLEND_MODE_OVERLAY = 3,
#endif
} DtermBlendMode;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Render error codes for FFI.
typedef enum DtermRenderError {
#if (defined(DTERM_GPU) && defined(DTERM_FFI))
  // Success
  DTERM_RENDER_ERROR_OK = 0,
#endif
#if (defined(DTERM_GPU) && defined(DTERM_FFI))
  // Null pointer argument
  DTERM_RENDER_ERROR_NULL_POINTER = 1,
#endif
#if (defined(DTERM_GPU) && defined(DTERM_FFI))
  // Invalid device handle
  DTERM_RENDER_ERROR_INVALID_DEVICE = 2,
#endif
#if (defined(DTERM_GPU) && defined(DTERM_FFI))
  // Invalid queue handle
  DTERM_RENDER_ERROR_INVALID_QUEUE = 3,
#endif
#if (defined(DTERM_GPU) && defined(DTERM_FFI))
  // Invalid surface view handle
  DTERM_RENDER_ERROR_INVALID_SURFACE_VIEW = 4,
#endif
#if (defined(DTERM_GPU) && defined(DTERM_FFI))
  // Rendering failed
  DTERM_RENDER_ERROR_RENDER_FAILED = 5,
#endif
} DtermRenderError;
#endif

// Color type for style storage.
//
// Used to track whether a color is default, indexed (palette), or RGB.
enum ColorType {
  // Default terminal color (white fg, black bg).
  COLOR_TYPE_DEFAULT = 0,
  // Indexed color (0-255 palette).
  COLOR_TYPE_INDEXED = 1,
  // True color RGB.
  COLOR_TYPE_RGB = 2,
};
typedef uint8_t ColorType;

#if defined(DTERM_FFI)
// Clipboard operation type for FFI.
typedef enum DtermClipboardOpType {
#if defined(DTERM_FFI)
  // Set clipboard content
  DTERM_CLIPBOARD_OP_TYPE_SET = 0,
#endif
#if defined(DTERM_FFI)
  // Query clipboard content
  DTERM_CLIPBOARD_OP_TYPE_QUERY = 1,
#endif
#if defined(DTERM_FFI)
  // Clear clipboard
  DTERM_CLIPBOARD_OP_TYPE_CLEAR = 2,
#endif
} DtermClipboardOpType;
#endif

// Compressed cell attributes for RLE storage.
//
// This is a compact representation of cell styling that can be efficiently
// RLE-encoded. It captures the essential visual attributes:
// - Foreground color (packed)
// - Background color (packed)
// - Cell flags (bold, italic, underline, etc.)
//
// ## Memory Layout
//
// ```text
// ┌─────────────────────────────────────────────────────────────┐
// │ fg: u32 (4 bytes) - Packed foreground color                 │
// │   Format: 0xTT_RRGGBB where TT = type (default/indexed/rgb) │
// ├─────────────────────────────────────────────────────────────┤
// │ bg: u32 (4 bytes) - Packed background color                 │
// │   Format: 0xTT_RRGGBB where TT = type (default/indexed/rgb) │
// ├─────────────────────────────────────────────────────────────┤
// │ flags: u16 (2 bytes) - Visual attribute flags               │
// │   Bits 0-7: bold, dim, italic, underline, blink, inverse... │
// └─────────────────────────────────────────────────────────────┘
// Total: 10 bytes per unique style (vs 8 bytes per cell uncompressed)
// ```
//
// ## Compression Benefit
//
// An 80-column line with plain text: 80 cells × 8 bytes = 640 bytes
// With RLE (1 style run): ~15 bytes (10 bytes style + 5 bytes overhead)
//
// An 80-column prompt line with 3 color regions:
// - Uncompressed: 640 bytes
// - RLE: ~45 bytes (3 runs × 10 bytes + overhead)
typedef struct CellAttrs CellAttrs;

// Damage state for the terminal grid.
typedef struct Damage Damage;

// Device attributes flags for DA1 response.
//
// These are the feature flags reported in response to `CSI c` (DA1).
typedef struct DeviceAttributes DeviceAttributes;

// DRCS font slot identifier.
typedef struct DrcsFontId DrcsFontId;

#if defined(DTERM_FFI)
// Opaque checkpoint manager handle.
typedef struct dterm_checkpoint_t dterm_checkpoint_t;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Opaque GPU renderer handle that wraps the full wgpu Renderer.
//
// This is separate from `DtermRenderer` which handles frame synchronization and hybrid data.
// The platform must provide wgpu device/queue handles.
typedef struct DtermGpuRenderer DtermGpuRenderer;
#endif

#if defined(DTERM_FFI)
// Opaque grid handle.
typedef struct dterm_grid_t dterm_grid_t;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Opaque hybrid renderer handle.
//
// Unlike `DtermGpuRenderer` which does full wgpu rendering, this only
// generates data for the platform to render with its own graphics API.
typedef struct DtermHybridRenderer DtermHybridRenderer;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Opaque image texture cache handle for FFI.
typedef struct DtermImageCache DtermImageCache;
#endif

#if defined(DTERM_FFI)
// Opaque parser handle.
typedef struct dterm_parser_t dterm_parser_t;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Opaque renderer handle for FFI.
typedef struct DtermRenderer DtermRenderer;
#endif

#if defined(DTERM_FFI)
// Opaque search index handle.
typedef struct dterm_search_t dterm_search_t;
#endif

#if defined(DTERM_FFI)
// Opaque handle for smart selection engine.
typedef struct DtermSmartSelection DtermSmartSelection;
#endif

#if defined(DTERM_FFI)
// Opaque terminal handle.
typedef struct dterm_terminal_t dterm_terminal_t;
#endif

#if defined(DTERM_FFI)
// Opaque UI Bridge handle.
typedef struct DtermUIBridge DtermUIBridge;
#endif

// Extended style with color type information.
//
// This struct stores the full style information including color types,
// allowing conversion back to `PackedColors + CellFlags` format.
typedef struct ExtendedStyle ExtendedStyle;

#if defined(DTERM_GPU)
// Handle to a GPU image texture.
//
// Handles are unique within a cache instance and are never reused.
typedef struct ImageHandle ImageHandle;
#endif

typedef struct Option_DtermClipboardCallback Option_DtermClipboardCallback;

// RGB color tuple type (R, G, B).
typedef struct Rgb Rgb;

// Terminal emulator.
//
// Combines a [`Parser`] and a [`Grid`] to provide full terminal emulation.
typedef struct Terminal Terminal;

#if defined(DTERM_FFI)
// Callback to start STT session.
// Returns DtermMediaError::Ok on success.
typedef enum DtermMediaError (*DtermSttStartCallback)(void *context,
                                                      enum DtermAudioFormat format,
                                                      const char *language);
#endif

#if defined(DTERM_FFI)
// Callback to feed audio data to STT.
// Returns DtermMediaError::Ok on success.
typedef enum DtermMediaError (*DtermSttFeedCallback)(void *context,
                                                     const uint8_t *data,
                                                     uintptr_t len);
#endif

#if defined(DTERM_FFI)
// STT result for FFI.
typedef struct DtermSttResult {
  // Recognized text (null-terminated UTF-8, caller-owned).
  char *text;
  // Confidence score (0-100).
  uint8_t confidence;
  // Whether this is a final result.
  bool is_final;
} DtermSttResult;
#endif

#if defined(DTERM_FFI)
// Callback to get partial STT result.
// Returns null if no partial result available.
typedef struct DtermSttResult *(*DtermSttPartialCallback)(void *context);
#endif

#if defined(DTERM_FFI)
// Callback to stop STT and get final result.
// Returns null on error.
typedef struct DtermSttResult *(*DtermSttStopCallback)(void *context);
#endif

#if defined(DTERM_FFI)
// Callback to cancel STT session.
typedef void (*DtermSttCancelCallback)(void *context);
#endif

#if defined(DTERM_FFI)
// Callback to check voice activity.
// Returns 0 = inactive, 1 = active, -1 = unsupported.
typedef int8_t (*DtermSttVadCallback)(void *context);
#endif

#if defined(DTERM_FFI)
// Callback to synthesize speech (blocking).
// Returns audio data length, writes to buffer. Returns 0 on error.
typedef uintptr_t (*DtermTtsSynthesizeCallback)(void *context,
                                                const char *text,
                                                enum DtermAudioFormat format,
                                                const char *voice,
                                                uint8_t *out_buffer,
                                                uintptr_t buffer_len);
#endif

#if defined(DTERM_FFI)
// Callback to start streaming TTS.
// Returns DtermMediaError::Ok on success.
typedef enum DtermMediaError (*DtermTtsStreamStartCallback)(void *context,
                                                            const char *text,
                                                            enum DtermAudioFormat format,
                                                            const char *voice);
#endif

#if defined(DTERM_FFI)
// Callback to read TTS stream chunk.
// Returns bytes written, or 0 if complete, or -1 on error.
typedef intptr_t (*DtermTtsStreamReadCallback)(void *context, uint8_t *buffer, uintptr_t buffer_len);
#endif

#if defined(DTERM_FFI)
// Callback to stop TTS streaming.
typedef void (*DtermTtsStreamStopCallback)(void *context);
#endif

#if defined(DTERM_FFI)
// Action for FFI.
typedef struct dterm_action_t {
  // Action type.
  enum dterm_action_type_t action_type;
  // Character for Print, byte for Execute.
  uint32_t byte;
  // Final byte for CSI/ESC.
  uint8_t final_byte;
  // Number of parameters.
  uint8_t param_count;
  // Parameters (up to 16).
  uint16_t params[16];
} dterm_action_t;
#endif

#if defined(DTERM_FFI)
// Callback function type.
typedef void (*DtermCallback)(void*, struct dterm_action_t);
#endif

#if defined(DTERM_FFI)
// Cell data for FFI.
typedef struct dterm_cell_t {
  // Unicode codepoint (0 for empty cell).
  uint32_t codepoint;
  // Foreground color (packed).
  uint32_t fg;
  // Background color (packed).
  uint32_t bg;
  // Underline color (packed). 0xFFFFFFFF means use foreground color.
  uint32_t underline_color;
  // Cell flags (bold, italic, etc.).
  // Bits 0-10: Standard visual attributes
  // Bit 11: Superscript (SGR 73)
  // Bit 12: Subscript (SGR 74)
  // Bits 13-15: Reserved
  uint16_t flags;
} dterm_cell_t;
#endif

#if defined(DTERM_FFI)
// Scrollback cell information for FFI.
//
// Contains the character codepoint and style attributes for a cell in scrollback.
typedef struct DtermScrollbackCell {
  // Unicode codepoint (0 if empty or continuation).
  uint32_t codepoint;
  // Foreground color (packed: 0xTT_RRGGBB where TT is type).
  // - 0x00: Indexed color (BB = index)
  // - 0x01: True color RGB
  // - 0xFF: Default color
  uint32_t fg;
  // Background color (same format as fg).
  uint32_t bg;
  // Cell flags (bold, italic, underline, etc.).
  uint16_t flags;
  // Reserved for alignment.
  uint16_t reserved;
} DtermScrollbackCell;
#endif

#if defined(DTERM_FFI)
// Style information for FFI.
typedef struct dterm_style_t {
  // Foreground color (packed).
  uint32_t fg;
  // Background color (packed).
  uint32_t bg;
  // Cell flags (bold, italic, etc.).
  // Bits 0-10: Standard visual attributes
  // Bit 11: Superscript (SGR 73)
  // Bit 12: Subscript (SGR 74)
  uint16_t flags;
} dterm_style_t;
#endif

#if defined(DTERM_FFI)
// Mode flags for FFI.
typedef struct dterm_modes_t {
  // Cursor visible (DECTCEM).
  bool cursor_visible;
  // Cursor style (DECSCUSR).
  // Values match DECSCUSR parameters (1-6).
  uint8_t cursor_style;
  // Application cursor keys (DECCKM).
  bool application_cursor_keys;
  // Alternate screen buffer active.
  bool alternate_screen;
  // Auto-wrap mode (DECAWM).
  bool auto_wrap;
  // Origin mode (DECOM).
  bool origin_mode;
  // Insert mode (IRM).
  bool insert_mode;
  // Bracketed paste mode.
  bool bracketed_paste;
  // Mouse tracking mode (1000/1002/1003).
  enum DtermMouseMode mouse_mode;
  // Mouse encoding format (X10 or SGR/1006).
  enum DtermMouseEncoding mouse_encoding;
  // Focus reporting mode (1004).
  bool focus_reporting;
  // Synchronized output mode (2026).
  // When enabled, rendering should be deferred to prevent tearing.
  bool synchronized_output;
  // Reverse video mode (DECSET 5).
  // When enabled, screen colors are inverted.
  bool reverse_video;
  // Cursor blink mode (DECSET 12).
  // When enabled, cursor blinks.
  bool cursor_blink;
  // Application keypad mode (DECKPAM/DECKPNM).
  // When enabled, keypad sends application sequences.
  bool application_keypad;
  // 132 column mode (DECSET 3).
  // When enabled, terminal uses 132 columns.
  bool column_mode_132;
  // Reverse wraparound mode (DECSET 45).
  // When enabled, backspace at column 0 wraps to previous line.
  bool reverse_wraparound;
} dterm_modes_t;
#endif

#if defined(DTERM_FFI)
// Search match result for FFI.
typedef struct dterm_search_match_t {
  // Line number (0-indexed).
  uintptr_t line;
  // Starting column of the match (0-indexed).
  uintptr_t start_col;
  // Ending column of the match (exclusive).
  uintptr_t end_col;
} dterm_search_match_t;
#endif

#if defined(DTERM_FFI)
// RGB color value for FFI.
typedef struct DtermRgb {
  // Red component (0-255).
  uint8_t r;
  // Green component (0-255).
  uint8_t g;
  // Blue component (0-255).
  uint8_t b;
} DtermRgb;
#endif

#if defined(DTERM_FFI)
// DCS callback type for handling DCS sequences.
//
// Parameters:
// - `context`: User-provided context pointer
// - `data`: DCS payload data
// - `len`: Length of data
// - `final_byte`: Final byte of the DCS sequence
typedef void (*DtermDCSCallback)(void *context,
                                 const uint8_t *data,
                                 uintptr_t len,
                                 uint8_t final_byte);
#endif

#if defined(DTERM_FFI)
// Bell callback type.
//
// Nullable function pointer - pass null to disable the callback.
typedef void (*DtermBellCallback)(void*);
#endif

#if defined(DTERM_FFI)
// Buffer activation callback type.
//
// Called when the terminal switches between main and alternate screen buffers.
// The boolean parameter is `true` when switching to the alternate screen,
// `false` when switching back to the main screen.
//
// Nullable function pointer - pass null to disable the callback.
typedef void (*DtermBufferActivationCallback)(void*, bool);
#endif

#if defined(DTERM_FFI)
// Kitty image callback type.
//
// Called when a Kitty graphics image is successfully transmitted and stored.
// Parameters:
// - `context`: User context pointer
// - `id`: Image ID assigned by the terminal
// - `width`: Image width in pixels
// - `height`: Image height in pixels
// - `data`: RGBA pixel data (4 bytes per pixel, length = width * height * 4)
// - `data_len`: Length of the pixel data in bytes
//
// The `data` pointer is valid only during the callback invocation.
// The caller must copy the data if it needs to persist beyond the callback.
//
// Nullable function pointer - pass null to disable the callback.
typedef void (*DtermKittyImageCallback)(void*,
                                        uint32_t,
                                        uint32_t,
                                        uint32_t,
                                        const uint8_t*,
                                        uintptr_t);
#endif

#if defined(DTERM_FFI)
// Title callback type.
//
// Called when the terminal title changes (OSC 0, OSC 2).
// Parameters:
// - `context`: User context pointer
// - `title`: Null-terminated UTF-8 string with the new title
//
// The `title` pointer is valid only during the callback invocation.
//
// Nullable function pointer - pass null to disable the callback.
typedef void (*DtermTitleCallback)(void*, const char*);
#endif

#if defined(DTERM_FFI)
// Window operation parameters structure.
typedef struct DtermWindowOp {
  // Operation type.
  enum DtermWindowOpType op_type;
  // First parameter (x, height, or mode depending on operation).
  uint16_t param1;
  // Second parameter (y, width, or 0 depending on operation).
  uint16_t param2;
} DtermWindowOp;
#endif

#if defined(DTERM_FFI)
// Window callback response structure.
typedef struct DtermWindowResponse {
  // Whether a response should be sent to the terminal.
  bool has_response;
  // For state reports: the state value.
  uint8_t state;
  // For position/size reports: x or width value.
  uint16_t x_or_width;
  // For position/size reports: y or height value.
  uint16_t y_or_height;
} DtermWindowResponse;
#endif

#if defined(DTERM_FFI)
// Window command callback type.
//
// Called when a window manipulation command is received (CSI t).
// The callback should handle the operation and optionally return response data.
//
// Parameters:
// - `context`: User context pointer
// - `op`: The window operation to perform
// - `response`: Output parameter for the response (if any)
//
// Returns: true if the operation was handled, false otherwise.
//
// Nullable function pointer - pass null to disable the callback.
typedef bool (*DtermWindowCallback)(void*, const struct DtermWindowOp*, struct DtermWindowResponse*);
#endif

#if defined(DTERM_FFI)
// Shell event structure for FFI.
typedef struct DtermShellEvent {
  // Event type.
  enum DtermShellEventType event_type;
  // Row where event occurred (for position events).
  uint32_t row;
  // Column where event occurred (for position events).
  uint16_t col;
  // Exit code (for CommandFinished, -1 if unknown).
  int32_t exit_code;
  // Path or URL (for DirectoryChanged, null otherwise).
  // Valid only during callback invocation.
  const char *path;
} DtermShellEvent;
#endif

#if defined(DTERM_FFI)
// Shell event callback type.
//
// Called when shell integration events occur (OSC 133, OSC 7).
// Parameters:
// - `context`: User context pointer
// - `event`: The shell event data
//
// Nullable function pointer - pass null to disable the callback.
typedef void (*DtermShellEventCallback)(void*, const struct DtermShellEvent*);
#endif

#if defined(DTERM_FFI)
// Sixel image structure for high-level Sixel API.
typedef struct DtermSixelImage {
  // Width in pixels.
  uint32_t width;
  // Height in pixels.
  uint32_t height;
  // RGBA pixel data (width * height * 4 bytes).
  // Owned by the caller after successful call.
  uint32_t *pixels;
} DtermSixelImage;
#endif

#if defined(DTERM_FFI)
// Kitty graphics image info structure for FFI.
typedef struct DtermKittyImageInfo {
  // Image ID.
  uint32_t id;
  // Image number (0 if not assigned).
  uint32_t number;
  // Width in pixels.
  uint32_t width;
  // Height in pixels.
  uint32_t height;
  // Number of placements.
  uint32_t placement_count;
} DtermKittyImageInfo;
#endif

#if defined(DTERM_FFI)
// Kitty graphics placement structure for FFI.
typedef struct DtermKittyPlacement {
  // Placement ID within the image.
  uint32_t id;
  // Location type.
  enum DtermKittyPlacementLocation location_type;
  // Row position (for Absolute) or parent image ID (for Relative).
  uint32_t row_or_parent_image;
  // Column position (for Absolute) or parent placement ID (for Relative).
  uint32_t col_or_parent_placement;
  // Horizontal offset (for Relative placement, in cells).
  int32_t offset_x;
  // Vertical offset (for Relative placement, in cells).
  int32_t offset_y;
  // Source rectangle x offset (in pixels).
  uint32_t source_x;
  // Source rectangle y offset (in pixels).
  uint32_t source_y;
  // Source rectangle width (0 = full image).
  uint32_t source_width;
  // Source rectangle height (0 = full image).
  uint32_t source_height;
  // Pixel offset within starting cell, x.
  uint32_t cell_x_offset;
  // Pixel offset within starting cell, y.
  uint32_t cell_y_offset;
  // Number of columns to display (0 = auto).
  uint32_t num_columns;
  // Number of rows to display (0 = auto).
  uint32_t num_rows;
  // Z-index for stacking (negative = below text).
  int32_t z_index;
  // Whether this is a virtual placement.
  bool is_virtual;
} DtermKittyPlacement;
#endif

#if defined(DTERM_FFI)
// Damage bounds for a single row.
typedef struct DtermRowDamage {
  // Row index (0 = top of visible area).
  uint16_t row;
  // First damaged column (inclusive).
  uint16_t left;
  // Last damaged column (exclusive).
  uint16_t right;
} DtermRowDamage;
#endif

#if defined(DTERM_FFI)
// An output block representing a command and its output.
//
// Output blocks are the fundamental unit of the block-based terminal model.
// Each block contains a prompt, optional command, and optional output.
typedef struct DtermOutputBlock {
  // Unique identifier for this block.
  uint64_t id;
  // Current state of this block.
  enum DtermBlockState state;
  // Row where the prompt started (absolute line number).
  uintptr_t prompt_start_row;
  // Column where the prompt started.
  uint16_t prompt_start_col;
  // Row where the command text started (0 if not set).
  uintptr_t command_start_row;
  // Column where the command text started (0 if not set).
  uint16_t command_start_col;
  // Whether command_start is valid.
  bool has_command_start;
  // Row where command output started (0 if not set).
  uintptr_t output_start_row;
  // Whether output_start_row is valid.
  bool has_output_start;
  // Row where this block ends (exclusive).
  uintptr_t end_row;
  // Whether end_row is valid.
  bool has_end_row;
  // Command exit code (only valid if state is Complete).
  int32_t exit_code;
  // Whether exit_code is valid.
  bool has_exit_code;
  // Whether the output portion of this block is collapsed.
  bool collapsed;
} DtermOutputBlock;
#endif

#if defined(DTERM_FFI)
// Result of a smart selection match.
typedef struct DtermSelectionMatch {
  // Start byte offset in the text.
  uint32_t start;
  // End byte offset in the text (exclusive).
  uint32_t end;
  // Rule name (null-terminated).
  char *rule_name;
  // Matched text (null-terminated).
  char *matched_text;
  // Kind of match (see `DtermSelectionKind`).
  uint8_t kind;
} DtermSelectionMatch;
#endif

// Terminal identifier.
typedef uint32_t TerminalId;

// Callback identifier.
typedef uint32_t CallbackId;

// Event identifier (unique per event).
typedef uint64_t EventId;

#if defined(DTERM_FFI)
// Event info returned from start_processing.
typedef struct DtermUIEventInfo {
  // Event ID.
  EventId event_id;
  // Event kind.
  enum DtermUIEventKind kind;
  // Target terminal (u32::MAX if none).
  TerminalId terminal_id;
  // Callback ID (u32::MAX if none).
  CallbackId callback_id;
  // Number of rows (for resize events).
  uint16_t rows;
  // Number of columns (for resize events).
  uint16_t cols;
} DtermUIEventInfo;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Renderer configuration for FFI.
//
// # Size
//
// This struct is 48 bytes on all platforms (verified for Swift binding).
//
// # Layout (offsets in bytes)
//
// | Offset | Field              | Size |
// |--------|---------------------|------|
// | 0      | initial_width      | 4    |
// | 4      | initial_height     | 4    |
// | 8      | scale_factor       | 4    |
// | 12     | background_r       | 1    |
// | 13     | background_g       | 1    |
// | 14     | background_b       | 1    |
// | 15     | background_a       | 1    |
// | 16     | vsync              | 1    |
// | 17     | (padding)          | 3    |
// | 20     | target_fps         | 4    |
// | 24     | drawable_timeout_ms| 8    |
// | 32     | damage_rendering   | 1    |
// | 33     | (padding)          | 3    |
// | 36     | cursor_style       | 4    |
// | 40     | cursor_blink_ms    | 4    |
// | 44     | selection_r        | 1    |
// | 45     | selection_g        | 1    |
// | 46     | selection_b        | 1    |
// | 47     | selection_a        | 1    |
typedef struct DtermRendererConfig {
  // Initial viewport width in pixels
  uint32_t initial_width;
  // Initial viewport height in pixels
  uint32_t initial_height;
  // Display scale factor (e.g., 2.0 for Retina)
  float scale_factor;
  // Background color red component (0-255)
  uint8_t background_r;
  // Background color green component (0-255)
  uint8_t background_g;
  // Background color blue component (0-255)
  uint8_t background_b;
  // Background color alpha component (0-255)
  uint8_t background_a;
  // Enable vsync
  bool vsync;
  // Target FPS when vsync is disabled
  uint32_t target_fps;
  // Drawable timeout in milliseconds
  uint64_t drawable_timeout_ms;
  // Enable damage-based rendering
  bool damage_rendering;
  // Cursor style
  enum DtermCursorStyle cursor_style;
  // Cursor blink rate in milliseconds (0 = no blinking)
  uint32_t cursor_blink_ms;
  // Selection color red component (0-255)
  uint8_t selection_r;
  // Selection color green component (0-255)
  uint8_t selection_g;
  // Selection color blue component (0-255)
  uint8_t selection_b;
  // Selection color alpha component (0-255)
  uint8_t selection_a;
} DtermRendererConfig;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Frame handle for FFI.
//
// This is a simplified handle that stores just the frame ID.
// The actual FrameRequest is stored in a map inside DtermRenderer.
//
// # Size
//
// This struct is 8 bytes on all platforms.
typedef struct DtermFrameHandle {
  // Frame ID
  uint64_t id;
} DtermFrameHandle;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Render result for FFI.
//
// Provides detailed information about the render operation.
//
// # Size
//
// This struct is 24 bytes on all platforms.
//
// # Layout (offsets in bytes)
//
// | Offset | Field         | Size |
// |--------|---------------|------|
// | 0      | success       | 1    |
// | 1      | (padding)     | 7    |
// | 8      | frame_time_us | 8    |
// | 16     | cells_rendered| 4    |
// | 20     | error_code    | 4    |
typedef struct DtermRenderResult {
  // Whether the render succeeded
  bool success;
  // Frame render time in microseconds
  uint64_t frame_time_us;
  // Number of cells rendered
  uint32_t cells_rendered;
  // Error code (0 = success, matches DtermRenderError values)
  int32_t error_code;
} DtermRenderResult;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Configuration for glyph atlas.
typedef struct DtermAtlasConfig {
  // Initial atlas size (width = height, must be power of 2)
  uint32_t initial_size;
  // Maximum atlas size (width = height)
  uint32_t max_size;
  // Default font size in pixels
  uint16_t default_font_size;
  // Padding between glyphs in pixels
  uint32_t padding;
} DtermAtlasConfig;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Vertex data for FFI.
//
// This matches the CellVertex layout in pipeline.rs:
// - position: `[f32; 2]` (8 bytes)
// - uv: `[f32; 2]` (8 bytes)
// - `fg_color`: `[f32; 4]` (16 bytes)
// - `bg_color`: `[f32; 4]` (16 bytes)
// - flags: u32 (4 bytes)
// - `_padding`: `[u32; 3]` (12 bytes)
//
// Total: 64 bytes per vertex
typedef struct DtermCellVertex {
  // Position in cell grid coordinates (fractional for sub-cell positioning)
  float position[2];
  // UV coordinates in atlas texture (normalized 0-1)
  float uv[2];
  // Foreground color (RGBA, 0-1)
  float fg_color[4];
  // Background color (RGBA, 0-1)
  float bg_color[4];
  // Flags (bold, dim, underline, etc.)
  uint32_t flags;
  // Padding for alignment (required for GPU buffer compatibility)
  uint32_t _padding[3];
} DtermCellVertex;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Uniform data for FFI.
//
// This matches the Uniforms layout in pipeline.rs (64 bytes total).
typedef struct DtermUniforms {
  // Viewport width in pixels
  float viewport_width;
  // Viewport height in pixels
  float viewport_height;
  // Cell width in pixels
  float cell_width;
  // Cell height in pixels
  float cell_height;
  // Atlas texture size in pixels
  float atlas_size;
  // Time for animations (seconds)
  float time;
  // Cursor X position (cell coordinates, -1 if hidden)
  int32_t cursor_x;
  // Cursor Y position (cell coordinates, -1 if hidden)
  int32_t cursor_y;
  // Cursor color (RGBA)
  float cursor_color[4];
  // Padding for alignment (required for GPU uniform buffer compatibility)
  float _padding[4];
} DtermUniforms;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Glyph entry data for FFI.
//
// Describes a single glyph's position and size in the atlas texture.
typedef struct DtermGlyphEntry {
  // X offset in atlas (pixels)
  uint16_t x;
  // Y offset in atlas (pixels)
  uint16_t y;
  // Glyph width (pixels)
  uint16_t width;
  // Glyph height (pixels)
  uint16_t height;
  // Horizontal offset from cursor position (pixels, can be negative)
  int16_t bearing_x;
  // Vertical offset from baseline (pixels)
  int16_t bearing_y;
  // Horizontal advance after rendering (pixels)
  uint16_t advance;
  // Padding for alignment
  uint16_t _padding;
} DtermGlyphEntry;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Inline image info for FFI.
//
// Contains metadata about an iTerm2 inline image stored via OSC 1337 File.
//
// # Size
//
// This struct is 40 bytes on all platforms.
typedef struct DtermInlineImageInfo {
  // Unique image ID.
  uint64_t id;
  // Row where image was placed.
  uint16_t row;
  // Column where image was placed.
  uint16_t col;
  // Width specification type: 0=Auto, 1=Cells, 2=Pixels, 3=Percent.
  uint8_t width_spec_type;
  // Width specification value (cells/pixels/percent, 0 for auto).
  uint32_t width_spec_value;
  // Height specification type: 0=Auto, 1=Cells, 2=Pixels, 3=Percent.
  uint8_t height_spec_type;
  // Height specification value (cells/pixels/percent, 0 for auto).
  uint32_t height_spec_value;
  // Whether to preserve aspect ratio.
  bool preserve_aspect_ratio;
  // Size of image data in bytes.
  uintptr_t data_size;
} DtermInlineImageInfo;
#endif

// A style identifier.
//
// Style IDs are indices into a `StyleTable`. The ID 0 is always the default
// style (white on black, no attributes).
typedef uint16_t StyleId;
// The default style ID (index 0).
//
// This is always valid and represents the default terminal style
// (white foreground, black background, no attributes).
// Equivalent to `GRID_DEFAULT_STYLE_ID`.
#define StyleId_DEFAULT 0

#if defined(DTERM_FFI)
// Clipboard operation for FFI.
//
// This struct is passed to the clipboard callback when an OSC 52
// sequence is processed.
typedef struct DtermClipboardOp {
  // Operation type (Set, Query, or Clear)
  enum DtermClipboardOpType op_type;
  // Selection targets (bitmask: bit 0 = clipboard, bit 1 = primary, etc.)
  // Use `dterm_clipboard_selection_mask()` to convert DtermClipboardSelection to mask.
  uint16_t selections_mask;
  // Number of selections (1-12)
  uint8_t selection_count;
  // Array of selection targets (up to 12)
  enum DtermClipboardSelection selections[12];
  // Content length in bytes (for Set operations)
  uintptr_t content_len;
  // Content pointer (for Set operations, UTF-8 encoded, NOT null-terminated)
  // NULL for Query and Clear operations.
  const char *content;
} DtermClipboardOp;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Damage region for FFI.
//
// Represents a rectangular region of the terminal that needs to be redrawn.
typedef struct DtermDamageRegion {
  // Starting row (0-indexed)
  uint16_t start_row;
  // Ending row (exclusive)
  uint16_t end_row;
  // Starting column (0-indexed)
  uint16_t start_col;
  // Ending column (exclusive)
  uint16_t end_col;
  // Whether this represents full damage
  bool is_full;
} DtermDamageRegion;
#endif



// The default style ID (index 0).
//
// Named GRID_DEFAULT_STYLE_ID to avoid conflict with rle::DEFAULT_STYLE_ID in FFI.
#define GRID_DEFAULT_STYLE_ID 0



// The default style ID (no special attributes).
#define DEFAULT_STYLE_ID 0









































#if defined(DTERM_FFI)
// Register STT callbacks from the platform layer.
//
// This must be called before any STT operations can succeed.
//
// # Safety
//
// - `context` must remain valid for the duration of all STT operations
// - All callback function pointers must be valid
// - `formats` must point to `formats_len` valid `DtermAudioFormat` values
// - `languages` must point to `languages_len` valid null-terminated C strings

void dterm_media_register_stt_callbacks(void *context,
                                        DtermSttStartCallback start,
                                        DtermSttFeedCallback feed,
                                        DtermSttPartialCallback partial,
                                        DtermSttStopCallback stop,
                                        DtermSttCancelCallback cancel,
                                        DtermSttVadCallback vad,
                                        const enum DtermAudioFormat *formats,
                                        uintptr_t formats_len,
                                        const char *const *languages,
                                        uintptr_t languages_len)
;
#endif

#if defined(DTERM_FFI)
// Register TTS callbacks from the platform layer.
//
// This must be called before any TTS operations can succeed.
//
// # Safety
//
// - `context` must remain valid for the duration of all TTS operations
// - All callback function pointers must be valid
// - `formats` must point to `formats_len` valid `DtermAudioFormat` values

void dterm_media_register_tts_callbacks(void *context,
                                        DtermTtsSynthesizeCallback synthesize,
                                        DtermTtsStreamStartCallback stream_start,
                                        DtermTtsStreamReadCallback stream_read,
                                        DtermTtsStreamStopCallback stream_stop,
                                        const enum DtermAudioFormat *formats,
                                        uintptr_t formats_len)
;
#endif

#if defined(DTERM_FFI)
// Check if STT callbacks are registered.
 bool dterm_media_stt_initialized(void) ;
#endif

#if defined(DTERM_FFI)
// Check if TTS callbacks are registered.
 bool dterm_media_tts_initialized(void) ;
#endif

#if defined(DTERM_FFI)
// Free an STT result returned by callbacks.
//
// # Safety
//
// - `result` must be a valid pointer previously returned by an STT callback,
//   or null (in which case this is a no-op)
// - `result` must not have been freed previously
 void dterm_media_free_stt_result(struct DtermSttResult *result) ;
#endif

#if defined(DTERM_FFI)
// Allocate an STT result for returning from callbacks.
//
// Platform layer should call this to create properly allocated results.
//
// # Safety
//
// - `text` must be a valid null-terminated UTF-8 string, or null
// - The returned pointer must be freed with `dterm_media_free_stt_result`

struct DtermSttResult *dterm_media_alloc_stt_result(const char *text,
                                                    uint8_t confidence,
                                                    bool is_final)
;
#endif

#if defined(DTERM_FFI)
// Get the last error code.
//
// Returns the error code from the most recent FFI operation that failed.
// Returns `DtermError::Success` (0) if the last operation succeeded.
 int32_t dterm_get_last_error(void) ;
#endif

#if defined(DTERM_FFI)
// Clear the last error code.
//
// Resets the error state to `DtermError::Success`.
 void dterm_clear_error(void) ;
#endif

#if defined(DTERM_FFI)
// Get a human-readable error message.
//
// Returns a static string describing the error code.
// The returned pointer is valid for the lifetime of the program.
//
// # Safety
//
// - The returned pointer must not be freed by the caller.
// - The returned string is valid UTF-8 and null-terminated.
 const char *dterm_error_message(int32_t error) ;
#endif

#if defined(DTERM_FFI)
// Create a new parser.
 struct dterm_parser_t *dterm_parser_new(void) ;
#endif

#if defined(DTERM_FFI)
// Free a parser.
//
// # Safety
//
// - `parser` must be a valid pointer returned by `dterm_parser_new`, or null.
// - `parser` must not have been freed previously (no double-free).
// - After this call, `parser` is invalid and must not be used.
 void dterm_parser_free(struct dterm_parser_t *parser) ;
#endif

#if defined(DTERM_FFI)
// Feed data to the parser.
//
// # Safety
//
// - `parser` must be a valid pointer returned by `dterm_parser_new`.
// - `data` must point to at least `len` readable bytes, or be null (in which case this is a no-op).
// - `len` must not exceed `isize::MAX` to avoid pointer arithmetic overflow.
// - `callback` must be a valid function pointer that can be safely called.
// - `context` is passed directly to `callback` - caller ensures validity.
// - The callback must not call back into this parser (no re-entrancy).

void dterm_parser_feed(struct dterm_parser_t *parser,
                       const uint8_t *data,
                       uintptr_t len,
                       void *context,
                       DtermCallback callback)
;
#endif

#if defined(DTERM_FFI)
// Reset the parser to ground state.
//
// # Safety
//
// - `parser` must be a valid pointer returned by `dterm_parser_new`, or null (no-op).
// - `parser` must not have been freed.
 void dterm_parser_reset(struct dterm_parser_t *parser) ;
#endif

#if defined(DTERM_FFI)
// Create a new grid with default scrollback.
 struct dterm_grid_t *dterm_grid_new(uint16_t rows, uint16_t cols) ;
#endif

#if defined(DTERM_FFI)
// Create a new grid with custom scrollback size.

struct dterm_grid_t *dterm_grid_new_with_scrollback(uint16_t rows,
                                                    uint16_t cols,
                                                    uintptr_t max_scrollback)
;
#endif

#if defined(DTERM_FFI)
// Free a grid.
//
// # Safety
//
// - `grid` must be a valid pointer returned by `dterm_grid_new` or
//   `dterm_grid_new_with_scrollback`, or null (no-op).
// - `grid` must not have been freed previously (no double-free).
// - After this call, `grid` is invalid and must not be used.
 void dterm_grid_free(struct dterm_grid_t *grid) ;
#endif

#if defined(DTERM_FFI)
// Get number of rows.
//
// # Safety
//
// - `grid` must be a valid pointer returned by a grid constructor, or null (returns 0).
 uint16_t dterm_grid_rows(const struct dterm_grid_t *grid) ;
#endif

#if defined(DTERM_FFI)
// Get number of columns.
//
// # Safety
//
// - `grid` must be a valid pointer returned by a grid constructor, or null (returns 0).
 uint16_t dterm_grid_cols(const struct dterm_grid_t *grid) ;
#endif

#if defined(DTERM_FFI)
// Get cursor row.
//
// # Safety
//
// - `grid` must be a valid pointer returned by a grid constructor, or null (returns 0).
 uint16_t dterm_grid_cursor_row(const struct dterm_grid_t *grid) ;
#endif

#if defined(DTERM_FFI)
// Get cursor column.
//
// # Safety
//
// - `grid` must be a valid pointer returned by a grid constructor, or null (returns 0).
 uint16_t dterm_grid_cursor_col(const struct dterm_grid_t *grid) ;
#endif

#if defined(DTERM_FFI)
// Set cursor position.
//
// # Safety
//
// - `grid` must be a valid pointer returned by a grid constructor, or null (no-op).
// - `row` and `col` will be clamped to valid bounds by the implementation.
 void dterm_grid_set_cursor(struct dterm_grid_t *grid, uint16_t row, uint16_t col) ;
#endif

#if defined(DTERM_FFI)
// Get cell at position.
//
// Returns true if cell exists, false otherwise.
// Cell data is written to `out_cell` if non-null.
//
// # Safety
//
// - `grid` must be a valid pointer returned by a grid constructor, or null (returns false).
// - `out_cell` must be a valid writable pointer, or null (cell data not returned).
// - If `out_cell` is non-null, it must point to properly aligned `DtermCell`.

bool dterm_grid_get_cell(const struct dterm_grid_t *grid,
                         uint16_t row,
                         uint16_t col,
                         struct dterm_cell_t *out_cell)
;
#endif

#if defined(DTERM_FFI)
// Write a character at cursor position.
//
// # Safety
//
// - `grid` must be a valid pointer returned by a grid constructor, or null (no-op).
// - `c` must be a valid Unicode codepoint (invalid values are ignored).
 void dterm_grid_write_char(struct dterm_grid_t *grid, uint32_t c) ;
#endif

#if defined(DTERM_FFI)
// Resize the grid.
//
// # Safety
//
// - `grid` must be a valid pointer returned by a grid constructor, or null (no-op).
// - `rows` and `cols` should be positive; zero values may cause undefined behavior.
 void dterm_grid_resize(struct dterm_grid_t *grid, uint16_t rows, uint16_t cols) ;
#endif

#if defined(DTERM_FFI)
// Scroll display by delta lines (positive = up, negative = down).
//
// # Safety
//
// - `grid` must be a valid pointer returned by a grid constructor, or null (no-op).
 void dterm_grid_scroll_display(struct dterm_grid_t *grid, int32_t delta) ;
#endif

#if defined(DTERM_FFI)
// Get display offset (scroll position).
//
// # Safety
//
// - `grid` must be a valid pointer returned by a grid constructor, or null (returns 0).
 uintptr_t dterm_grid_display_offset(const struct dterm_grid_t *grid) ;
#endif

#if defined(DTERM_FFI)
// Get total scrollback lines.
//
// # Safety
//
// - `grid` must be a valid pointer returned by a grid constructor, or null (returns 0).
 uintptr_t dterm_grid_scrollback_lines(const struct dterm_grid_t *grid) ;
#endif

#if defined(DTERM_FFI)
// Check if grid needs full redraw.
//
// # Safety
//
// - `grid` must be a valid pointer returned by a grid constructor, or null (returns false).
 bool dterm_grid_needs_redraw(const struct dterm_grid_t *grid) ;
#endif

#if defined(DTERM_FFI)
// Clear damage after rendering.
//
// # Safety
//
// - `grid` must be a valid pointer returned by a grid constructor, or null (no-op).
 void dterm_grid_clear_damage(struct dterm_grid_t *grid) ;
#endif

#if defined(DTERM_FFI)
// Erase screen.
//
// # Safety
//
// - `grid` must be a valid pointer returned by a grid constructor, or null (no-op).
 void dterm_grid_erase_screen(struct dterm_grid_t *grid) ;
#endif

#if defined(DTERM_FFI)
// Check if a Unicode codepoint is a box drawing character.
//
// This function is used by the grid adapter to set the `isBoxDrawingCharacter` flag
// for proper rendering. Box drawing characters require special geometric rendering
// rather than font glyphs.
//
// Returns true for:
// - U+2500-U+257F: Box Drawing (lines, corners, tees, crosses)
// - U+2580-U+259F: Block Elements (shades, quadrants, half blocks)
// - U+25E2-U+25FF: Geometric Shapes (triangles)
// - U+1FB00-U+1FB3C: Sextant characters (legacy terminal)
//
// # Example (Objective-C)
// ```objc
// uint32_t codepoint = cell.codepoint;
// BOOL isBoxDrawing = dterm_is_box_drawing_character(codepoint);
// ```
 bool dterm_is_box_drawing_character(uint32_t codepoint) ;
#endif

#if defined(DTERM_FFI)
// Create a new terminal.
 struct dterm_terminal_t *dterm_terminal_new(uint16_t rows, uint16_t cols) ;
#endif

#if defined(DTERM_FFI)
// Create a new terminal with tiered scrollback.
//
// # Arguments
//
// * `rows` - Number of visible rows
// * `cols` - Number of columns
// * `ring_buffer_size` - Size of fast ring buffer
// * `hot_limit` - Max lines in hot tier
// * `warm_limit` - Max lines in warm tier
// * `memory_budget` - Memory budget in bytes

struct dterm_terminal_t *dterm_terminal_new_with_scrollback(uint16_t rows,
                                                            uint16_t cols,
                                                            uintptr_t ring_buffer_size,
                                                            uintptr_t hot_limit,
                                                            uintptr_t warm_limit,
                                                            uintptr_t memory_budget)
;
#endif

#if defined(DTERM_FFI)
// Free a terminal.
//
// # Safety
//
// - `term` must be a valid pointer returned by `dterm_terminal_new` or
//   `dterm_terminal_new_with_scrollback`, or null (no-op).
// - `term` must not have been freed previously (no double-free).
// - After this call, `term` is invalid and must not be used.
// - Any pointers returned by `dterm_terminal_title` become invalid.
 void dterm_terminal_free(struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Process input bytes.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor.
// - `data` must point to at least `len` readable bytes, or be null (no-op).
// - `len` must not exceed `isize::MAX` to avoid pointer arithmetic overflow.
 void dterm_terminal_process(struct dterm_terminal_t *term, const uint8_t *data, uintptr_t len) ;
#endif

#if defined(DTERM_FFI)
// Get number of rows.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns 0).
 uint16_t dterm_terminal_rows(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get number of columns.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns 0).
 uint16_t dterm_terminal_cols(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get terminal memory usage in bytes.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns 0).
 uintptr_t dterm_terminal_memory_usage(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Set the scrollback memory budget in bytes.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (no-op).
 void dterm_terminal_set_memory_budget(struct dterm_terminal_t *term, uintptr_t bytes) ;
#endif

#if defined(DTERM_FFI)
// Get cursor row.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns 0).
 uint16_t dterm_terminal_cursor_row(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get cursor column.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns 0).
 uint16_t dterm_terminal_cursor_col(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Check if cursor is visible.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns true).
 bool dterm_terminal_cursor_visible(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get window title (null-terminated UTF-8 string).
//
// The returned pointer is valid until the next call to this function
// or until the terminal is freed.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns null).
// - The returned pointer must not be used after the next call to this function.
// - The returned pointer must not be used after `dterm_terminal_free`.
// - The returned pointer must not be freed by the caller.
 const char *dterm_terminal_title(struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get window icon name (null-terminated UTF-8 string).
//
// The icon name is set by OSC 1 escape sequences.
// The returned pointer is valid until the next call to this function
// or until the terminal is freed.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns null).
// - The returned pointer must not be used after the next call to this function.
// - The returned pointer must not be used after `dterm_terminal_free`.
// - The returned pointer must not be freed by the caller.
 const char *dterm_terminal_icon_name(struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get cursor style.
//
// Returns the DECSCUSR cursor style value (1-6):
// - 1: Blinking block (default)
// - 2: Steady block
// - 3: Blinking underline
// - 4: Steady underline
// - 5: Blinking bar
// - 6: Steady bar
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns 1).
 uint8_t dterm_terminal_cursor_style(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Check if alternate screen is active.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns false).
 bool dterm_terminal_is_alternate_screen(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Resize the terminal.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (no-op).
// - `rows` and `cols` should be positive; zero values may cause undefined behavior.
 void dterm_terminal_resize(struct dterm_terminal_t *term, uint16_t rows, uint16_t cols) ;
#endif

#if defined(DTERM_FFI)
// Reset the terminal to initial state.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (no-op).
 void dterm_terminal_reset(struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Scroll display by delta lines.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (no-op).
 void dterm_terminal_scroll_display(struct dterm_terminal_t *term, int32_t delta) ;
#endif

#if defined(DTERM_FFI)
// Scroll to top of scrollback.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (no-op).
 void dterm_terminal_scroll_to_top(struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Scroll to bottom (live content).
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (no-op).
 void dterm_terminal_scroll_to_bottom(struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get cell at position.
//
// Returns true if cell exists, false otherwise.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns false).
// - `out_cell` must be a valid writable pointer, or null (cell data not returned).
// - If `out_cell` is non-null, it must point to properly aligned `DtermCell`.

bool dterm_terminal_get_cell(const struct dterm_terminal_t *term,
                             uint16_t row,
                             uint16_t col,
                             struct dterm_cell_t *out_cell)
;
#endif

#if defined(DTERM_FFI)
// Get the Unicode codepoint for a cell.
//
// For complex characters, looks up the overflow string table.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns 0).
 uint32_t dterm_cell_codepoint(const struct dterm_terminal_t *term, uint16_t row, uint16_t col) ;
#endif

#if defined(DTERM_FFI)
// Get foreground color as RGB.
//
// Resolves indexed colors via the palette and true color via overflow tables.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (no-op).
// - `r`, `g`, and `b` must be valid writable pointers.

void dterm_cell_fg_rgb(const struct dterm_terminal_t *term,
                       uint16_t row,
                       uint16_t col,
                       uint8_t *r,
                       uint8_t *g,
                       uint8_t *b)
;
#endif

#if defined(DTERM_FFI)
// Get background color as RGB.
//
// Resolves indexed colors via the palette and true color via overflow tables.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (no-op).
// - `r`, `g`, and `b` must be valid writable pointers.

void dterm_cell_bg_rgb(const struct dterm_terminal_t *term,
                       uint16_t row,
                       uint16_t col,
                       uint8_t *r,
                       uint8_t *g,
                       uint8_t *b)
;
#endif

#if defined(DTERM_FFI)
// Check if terminal needs full redraw.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns false).
 bool dterm_terminal_needs_redraw(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Clear damage after rendering.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (no-op).
 void dterm_terminal_clear_damage(struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get total scrollback lines.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns 0).
 uintptr_t dterm_terminal_scrollback_lines(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get a cell from scrollback history.
//
// Retrieves the character and attributes at a specific position in scrollback.
//
// Parameters:
// - `term`: Terminal handle
// - `scrollback_row`: Row index in scrollback (0 = oldest line)
// - `col`: Column index (0-based)
// - `out_cell`: Output cell info
//
// Returns true if the cell exists, false if out of bounds or scrollback unavailable.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns false).
// - `out_cell` must be a valid writable pointer, or null (returns existence only).
// - If `out_cell` is non-null, it must point to properly aligned `DtermScrollbackCell`.

bool dterm_terminal_get_scrollback_cell(const struct dterm_terminal_t *term,
                                        uintptr_t scrollback_row,
                                        uint16_t col,
                                        struct DtermScrollbackCell *out_cell)
;
#endif

#if defined(DTERM_FFI)
// Get scrollback line length (number of characters).
//
// Returns the number of characters in the specified scrollback line.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns 0).

uintptr_t dterm_terminal_scrollback_line_len(const struct dterm_terminal_t *term,
                                             uintptr_t scrollback_row)
;
#endif

#if defined(DTERM_FFI)
// Check if scrollback line is wrapped (continuation of previous line).
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns false).

bool dterm_terminal_scrollback_line_wrapped(const struct dterm_terminal_t *term,
                                            uintptr_t scrollback_row)
;
#endif

#if defined(DTERM_FFI)
// Get display offset (scroll position).
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns 0).
 uintptr_t dterm_terminal_display_offset(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get current style.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (no-op).
// - `out_style` must be a valid writable pointer, or null (no-op).
// - If `out_style` is non-null, it must point to properly aligned `DtermStyle`.

void dterm_terminal_get_style(const struct dterm_terminal_t *term,
                              struct dterm_style_t *out_style)
;
#endif

#if defined(DTERM_FFI)
// Get terminal modes.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (no-op).
// - `out_modes` must be a valid writable pointer, or null (no-op).
// - If `out_modes` is non-null, it must point to properly aligned `DtermModes`.

void dterm_terminal_get_modes(const struct dterm_terminal_t *term,
                              struct dterm_modes_t *out_modes)
;
#endif

#if defined(DTERM_FFI)
// Check if the terminal has pending response data.
//
// Returns true if there is response data to read (from DSR/DA sequences).
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns false).
 bool dterm_terminal_has_response(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get the number of bytes in the pending response.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns 0).
 uintptr_t dterm_terminal_response_len(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Read pending response data from the terminal.
//
// Copies up to `buffer_size` bytes of response data into `buffer` and returns
// the number of bytes copied. The copied data is removed from the response
// buffer.
//
// This should be called after processing input to check for any responses
// that need to be written back to the PTY (such as cursor position reports
// or device attribute responses).
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor.
// - `buffer` must point to at least `buffer_size` writable bytes, or be null (returns 0).
// - `buffer_size` must not exceed `isize::MAX` to avoid pointer arithmetic overflow.
// - The memory at `buffer` must not overlap with terminal internal memory.
//
// # Returns
//
// The number of bytes copied to `buffer`. Returns 0 if there is no
// pending response or if either pointer is null.

uintptr_t dterm_terminal_read_response(struct dterm_terminal_t *term,
                                       uint8_t *buffer,
                                       uintptr_t buffer_size)
;
#endif

#if defined(DTERM_FFI)
// Check if mouse tracking is enabled.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns false).
 bool dterm_terminal_mouse_tracking_enabled(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get the current mouse tracking mode.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns None).
 enum DtermMouseMode dterm_terminal_mouse_mode(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get the current mouse encoding format.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns X10).
 enum DtermMouseEncoding dterm_terminal_mouse_encoding(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Check if focus reporting is enabled.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns false).
 bool dterm_terminal_focus_reporting_enabled(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Check if synchronized output mode is enabled.
//
// When enabled, the terminal is in "batch update" mode and the renderer
// should defer drawing until the mode is disabled. This prevents screen
// tearing during rapid updates from applications like vim or tmux.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns false).
 bool dterm_terminal_synchronized_output_enabled(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Encode a mouse button press event.
//
// Returns the number of bytes written to `buffer`, or 0 if mouse reporting
// is disabled or parameters are invalid. Coordinates are 0-indexed.
//
// # Arguments
//
// * `button` - Mouse button (0=left, 1=middle, 2=right)
// * `col` - Column (0-indexed)
// * `row` - Row (0-indexed)
// * `modifiers` - Modifier keys (shift=4, meta=8, ctrl=16)
// * `buffer` - Output buffer for the escape sequence
// * `buffer_size` - Size of the output buffer
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns 0).
// - `buffer` must point to at least `buffer_size` writable bytes, or be null (returns 0).

uintptr_t dterm_terminal_encode_mouse_press(const struct dterm_terminal_t *term,
                                            uint8_t button,
                                            uint16_t col,
                                            uint16_t row,
                                            uint8_t modifiers,
                                            uint8_t *buffer,
                                            uintptr_t buffer_size)
;
#endif

#if defined(DTERM_FFI)
// Encode a mouse button release event.
//
// Returns the number of bytes written to `buffer`, or 0 if mouse reporting
// is disabled or parameters are invalid. Coordinates are 0-indexed.
//
// # Arguments
//
// * `button` - Original mouse button (0=left, 1=middle, 2=right)
// * `col` - Column (0-indexed)
// * `row` - Row (0-indexed)
// * `modifiers` - Modifier keys (shift=4, meta=8, ctrl=16)
// * `buffer` - Output buffer for the escape sequence
// * `buffer_size` - Size of the output buffer
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns 0).
// - `buffer` must point to at least `buffer_size` writable bytes, or be null (returns 0).

uintptr_t dterm_terminal_encode_mouse_release(const struct dterm_terminal_t *term,
                                              uint8_t button,
                                              uint16_t col,
                                              uint16_t row,
                                              uint8_t modifiers,
                                              uint8_t *buffer,
                                              uintptr_t buffer_size)
;
#endif

#if defined(DTERM_FFI)
// Encode a mouse motion event.
//
// Returns the number of bytes written to `buffer`, or 0 if motion tracking
// is not enabled or parameters are invalid. Coordinates are 0-indexed.
//
// Motion events are only sent in ButtonEvent (1002) or AnyEvent (1003) modes.
//
// # Arguments
//
// * `button` - Button held during motion (0=left, 1=middle, 2=right, 3=none)
// * `col` - Column (0-indexed)
// * `row` - Row (0-indexed)
// * `modifiers` - Modifier keys (shift=4, meta=8, ctrl=16)
// * `buffer` - Output buffer for the escape sequence
// * `buffer_size` - Size of the output buffer
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns 0).
// - `buffer` must point to at least `buffer_size` writable bytes, or be null (returns 0).

uintptr_t dterm_terminal_encode_mouse_motion(const struct dterm_terminal_t *term,
                                             uint8_t button,
                                             uint16_t col,
                                             uint16_t row,
                                             uint8_t modifiers,
                                             uint8_t *buffer,
                                             uintptr_t buffer_size)
;
#endif

#if defined(DTERM_FFI)
// Encode a mouse wheel event.
//
// Returns the number of bytes written to `buffer`, or 0 if mouse reporting
// is disabled or parameters are invalid. Coordinates are 0-indexed.
//
// # Arguments
//
// * `up` - True for wheel up, false for wheel down
// * `col` - Column (0-indexed)
// * `row` - Row (0-indexed)
// * `modifiers` - Modifier keys (shift=4, meta=8, ctrl=16)
// * `buffer` - Output buffer for the escape sequence
// * `buffer_size` - Size of the output buffer
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns 0).
// - `buffer` must point to at least `buffer_size` writable bytes, or be null (returns 0).

uintptr_t dterm_terminal_encode_mouse_wheel(const struct dterm_terminal_t *term,
                                            bool up,
                                            uint16_t col,
                                            uint16_t row,
                                            uint8_t modifiers,
                                            uint8_t *buffer,
                                            uintptr_t buffer_size)
;
#endif

#if defined(DTERM_FFI)
// Encode a focus event.
//
// Returns the number of bytes written to `buffer`, or 0 if focus reporting
// is disabled.
//
// # Arguments
//
// * `focused` - True if window gained focus, false if lost focus
// * `buffer` - Output buffer for the escape sequence
// * `buffer_size` - Size of the output buffer
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns 0).
// - `buffer` must point to at least `buffer_size` writable bytes, or be null (returns 0).

uintptr_t dterm_terminal_encode_focus_event(const struct dterm_terminal_t *term,
                                            bool focused,
                                            uint8_t *buffer,
                                            uintptr_t buffer_size)
;
#endif

#if defined(DTERM_FFI)
// Create a new search index.
 struct dterm_search_t *dterm_search_new(void) ;
#endif

#if defined(DTERM_FFI)
// Create a new search index with expected capacity.
 struct dterm_search_t *dterm_search_with_capacity(uintptr_t expected_lines) ;
#endif

#if defined(DTERM_FFI)
// Free a search index.
//
// # Safety
//
// - `search` must be a valid pointer returned by `dterm_search_new` or
//   `dterm_search_with_capacity`, or null (no-op).
// - `search` must not have been freed previously (no double-free).
// - After this call, `search` is invalid and must not be used.
 void dterm_search_free(struct dterm_search_t *search) ;
#endif

#if defined(DTERM_FFI)
// Index a scrollback line for searching.
//
// # Safety
//
// - `search` must be a valid pointer returned by a search constructor, or null (no-op).
// - `text` must point to at least `len` readable bytes, or be null (no-op).
// - `len` must not exceed `isize::MAX`.
// - `text` must contain valid UTF-8 data.
 void dterm_search_index_line(struct dterm_search_t *search, const uint8_t *text, uintptr_t len) ;
#endif

#if defined(DTERM_FFI)
// Check if a query might have matches (fast bloom filter check).
//
// Returns false if definitely no matches exist.
// Returns true if matches are possible (verify with actual search).
//
// # Safety
//
// - `search` must be a valid pointer returned by a search constructor, or null (returns false).
// - `query` must point to at least `query_len` readable bytes, or be null (returns false).
// - `query` must contain valid UTF-8 data.

bool dterm_search_might_contain(const struct dterm_search_t *search,
                                const uint8_t *query,
                                uintptr_t query_len)
;
#endif

#if defined(DTERM_FFI)
// Search for a query string.
//
// Returns the number of matches found. Matches are written to `out_matches`
// up to `max_matches` count.
//
// # Safety
//
// - `search` must be a valid pointer returned by a search constructor, or null (returns 0).
// - `query` must point to at least `query_len` readable bytes, or be null (returns 0).
// - `query` must contain valid UTF-8 data.
// - `out_matches` must point to at least `max_matches` writable `DtermSearchMatch`, or be null.
// - If `out_matches` is null, only the count is returned (useful for sizing a buffer).

uintptr_t dterm_search_find(const struct dterm_search_t *search,
                            const uint8_t *query,
                            uintptr_t query_len,
                            struct dterm_search_match_t *out_matches,
                            uintptr_t max_matches)
;
#endif

#if defined(DTERM_FFI)
// Search for a query string in the specified direction.
//
// Returns the number of matches found. Matches are written to `out_matches`
// up to `max_matches` count, sorted by the specified direction.
//
// # Safety
//
// - `search` must be a valid pointer returned by a search constructor, or null (returns 0).
// - `query` must point to at least `query_len` readable bytes, or be null (returns 0).
// - `query` must contain valid UTF-8 data.
// - `out_matches` must point to at least `max_matches` writable `DtermSearchMatch`, or be null.

uintptr_t dterm_search_find_ordered(const struct dterm_search_t *search,
                                    const uint8_t *query,
                                    uintptr_t query_len,
                                    enum dterm_search_direction_t direction,
                                    struct dterm_search_match_t *out_matches,
                                    uintptr_t max_matches)
;
#endif

#if defined(DTERM_FFI)
// Find the next match after a given position.
//
// Returns true if a match was found, false otherwise.
//
// # Safety
//
// - `search` must be a valid pointer returned by a search constructor, or null (returns false).
// - `query` must point to at least `query_len` readable bytes, or be null (returns false).
// - `query` must contain valid UTF-8 data.
// - `out_match` must be a valid writable pointer, or null (no-op but still returns result).

bool dterm_search_find_next(const struct dterm_search_t *search,
                            const uint8_t *query,
                            uintptr_t query_len,
                            uintptr_t after_line,
                            uintptr_t after_col,
                            struct dterm_search_match_t *out_match)
;
#endif

#if defined(DTERM_FFI)
// Find the previous match before a given position.
//
// Returns true if a match was found, false otherwise.
//
// # Safety
//
// - `search` must be a valid pointer returned by a search constructor, or null (returns false).
// - `query` must point to at least `query_len` readable bytes, or be null (returns false).
// - `query` must contain valid UTF-8 data.
// - `out_match` must be a valid writable pointer, or null (no-op but still returns result).

bool dterm_search_find_prev(const struct dterm_search_t *search,
                            const uint8_t *query,
                            uintptr_t query_len,
                            uintptr_t before_line,
                            uintptr_t before_col,
                            struct dterm_search_match_t *out_match)
;
#endif

#if defined(DTERM_FFI)
// Get the number of indexed lines.
//
// # Safety
//
// - `search` must be a valid pointer returned by a search constructor, or null (returns 0).
 uintptr_t dterm_search_line_count(const struct dterm_search_t *search) ;
#endif

#if defined(DTERM_FFI)
// Clear the search index.
//
// # Safety
//
// - `search` must be a valid pointer returned by a search constructor, or null (no-op).
 void dterm_search_clear(struct dterm_search_t *search) ;
#endif

#if defined(DTERM_FFI)
// Create a new checkpoint manager.
//
// # Safety
//
// - `path` must point to at least `path_len` readable bytes, or be null (returns null).
// - `path` must contain valid UTF-8 data representing a valid filesystem path.
 struct dterm_checkpoint_t *dterm_checkpoint_new(const uint8_t *path, uintptr_t path_len) ;
#endif

#if defined(DTERM_FFI)
// Free a checkpoint manager.
//
// # Safety
//
// - `checkpoint` must be a valid pointer returned by `dterm_checkpoint_new`, or null (no-op).
// - `checkpoint` must not have been freed previously (no double-free).
// - After this call, `checkpoint` is invalid and must not be used.
 void dterm_checkpoint_free(struct dterm_checkpoint_t *checkpoint) ;
#endif

#if defined(DTERM_FFI)
// Check if a checkpoint should be performed based on time and line thresholds.
//
// # Safety
//
// - `checkpoint` must be a valid pointer returned by `dterm_checkpoint_new`, or null (returns false).

bool dterm_checkpoint_should_save(const struct dterm_checkpoint_t *checkpoint)
;
#endif

#if defined(DTERM_FFI)
// Notify the checkpoint manager that lines were added.
//
// # Safety
//
// - `checkpoint` must be a valid pointer returned by `dterm_checkpoint_new`, or null (no-op).
 void dterm_checkpoint_notify_lines(struct dterm_checkpoint_t *checkpoint, uintptr_t count) ;
#endif

#if defined(DTERM_FFI)
// Check if a valid checkpoint exists.
//
// # Safety
//
// - `checkpoint` must be a valid pointer returned by `dterm_checkpoint_new`, or null (returns false).

bool dterm_checkpoint_exists(const struct dterm_checkpoint_t *checkpoint)
;
#endif

#if defined(DTERM_FFI)
// Save a checkpoint of the terminal state.
//
// Returns true on success, false on failure.
//
// # Safety
//
// - `checkpoint` must be a valid pointer returned by `dterm_checkpoint_new`, or null (returns false).
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns false).

bool dterm_checkpoint_save(struct dterm_checkpoint_t *checkpoint,
                           const struct dterm_terminal_t *term)
;
#endif

#if defined(DTERM_FFI)
// Restore terminal state from the latest checkpoint.
//
// Returns a new terminal on success, null on failure.
//
// # Safety
//
// - `checkpoint` must be a valid pointer returned by `dterm_checkpoint_new`, or null (returns null).

struct dterm_terminal_t *dterm_checkpoint_restore(const struct dterm_checkpoint_t *checkpoint)
;
#endif

#if defined(DTERM_FFI)
// Get the bitmask value for a clipboard selection.
//
// Use this to interpret the `selections_mask` field in DtermClipboardOp.
 uint16_t dterm_clipboard_selection_mask(enum DtermClipboardSelection selection) ;
#endif

#if defined(DTERM_FFI)
// Set clipboard callback for OSC 52 operations.
//
// The callback is invoked when an application sends OSC 52 to set, query,
// or clear the clipboard.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (no-op).
// - `callback` must be a valid function pointer, or null to disable clipboard support.
// - `context` is passed to the callback and can be any value (including null).
// - The callback and context must remain valid for the lifetime of the terminal.
// - The caller is responsible for ensuring thread-safety of the context data.

void dterm_terminal_set_clipboard_callback(struct dterm_terminal_t *term,
                                           struct Option_DtermClipboardCallback callback,
                                           void *context)
;
#endif

#if defined(DTERM_FFI)
// Get the hyperlink URL for a cell, if any.
//
// OSC 8 hyperlinks allow terminal applications to create clickable links.
// This function returns the URL associated with a cell, or NULL if the cell
// has no hyperlink.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns null).
// - The returned string is owned by the terminal and must NOT be freed by the caller.
// - The returned string is valid until the next call to `dterm_terminal_process`,
//   `dterm_terminal_reset`, or `dterm_terminal_free`.
//
// # Returns
//
// A pointer to a null-terminated UTF-8 string containing the URL, or NULL if:
// - `term` is NULL
// - The cell is out of bounds
// - The cell has no hyperlink

const char *dterm_terminal_cell_hyperlink(struct dterm_terminal_t *term,
                                          uint16_t row,
                                          uint16_t col)
;
#endif

#if defined(DTERM_FFI)
// Check if a cell has a hyperlink.
//
// This is a faster check than `dterm_terminal_cell_hyperlink` when you only
// need to know if a hyperlink exists, not what the URL is.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns false).

bool dterm_terminal_cell_has_hyperlink(const struct dterm_terminal_t *term,
                                       uint16_t row,
                                       uint16_t col)
;
#endif

#if defined(DTERM_FFI)
// Check if a cell contains a complex character (non-BMP, grapheme cluster).
//
// Complex characters are stored in overflow and cannot be represented
// as a single codepoint. Use `dterm_terminal_cell_display_string` to
// get the actual character string.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns false).

bool dterm_terminal_cell_is_complex(const struct dterm_terminal_t *term,
                                    uint16_t row,
                                    uint16_t col)
;
#endif

#if defined(DTERM_FFI)
// Get the display string for a cell.
//
// For simple cells, returns a string containing just the character.
// For complex cells (non-BMP, grapheme clusters), returns the full string
// from the overflow table. For wide continuation cells, returns an empty string.
//
// # Returns
//
// - Pointer to a null-terminated UTF-8 string for valid cells
// - Null pointer if the cell doesn't exist or on error
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns null).
// - The returned string is owned by the terminal and must NOT be freed by the caller.
// - The returned string is valid until the next call to this function,
//   `dterm_terminal_process`, `dterm_terminal_reset`, or `dterm_terminal_free`.

const char *dterm_terminal_cell_display_string(struct dterm_terminal_t *term,
                                               uint16_t row,
                                               uint16_t col)
;
#endif

#if defined(DTERM_FFI)
// Get the text content of a visible row, properly resolving complex characters.
//
// This returns the full text of a row, including proper handling of
// non-BMP characters like emoji that are stored in overflow.
//
// # Returns
//
// - Pointer to a null-terminated UTF-8 string
// - Null pointer if row is out of bounds or on error
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns null).
// - The returned string is owned by the terminal and must NOT be freed by the caller.
// - The returned string is valid until the next call to this function,
//   `dterm_terminal_process`, `dterm_terminal_reset`, or `dterm_terminal_free`.
 const char *dterm_terminal_row_text(struct dterm_terminal_t *term, uint16_t row) ;
#endif

#if defined(DTERM_FFI)
// Get the current hyperlink URL being applied to new text.
//
// When an OSC 8 hyperlink sequence is received, subsequent text will have
// the hyperlink applied until the hyperlink is cleared. This function
// returns the current active hyperlink URL, if any.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns null).
// - The returned string is owned by the terminal and must NOT be freed by the caller.
// - The returned string is valid until the next call to `dterm_terminal_process`,
//   `dterm_terminal_reset`, or `dterm_terminal_free`.
 const char *dterm_terminal_current_hyperlink(struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get the current working directory (OSC 7).
//
// Returns the path portion of the file:// URL set by OSC 7, or null if not set.
// The path is already percent-decoded.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns null).
// - The returned string is owned by the terminal and must NOT be freed by the caller.
// - The returned string is valid until the next call to `dterm_terminal_process`,
//   `dterm_terminal_reset`, or `dterm_terminal_free`.
 const char *dterm_terminal_current_working_directory(struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Check if a current working directory is set.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns false).
 bool dterm_terminal_has_working_directory(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get a color from the terminal's 256-color palette.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null.
// - `out_color` must be a valid pointer to a `DtermRgb` struct.
//
// # Returns
//
// Returns true if successful, false if `term` is null or `index` is invalid (>= 256).

bool dterm_terminal_get_palette_color(const struct dterm_terminal_t *term,
                                      uint8_t index,
                                      struct DtermRgb *out_color)
;
#endif

#if defined(DTERM_FFI)
// Set a color in the terminal's 256-color palette.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (no-op).

void dterm_terminal_set_palette_color(struct dterm_terminal_t *term,
                                      uint8_t index,
                                      uint8_t r,
                                      uint8_t g,
                                      uint8_t b)
;
#endif

#if defined(DTERM_FFI)
// Reset the entire 256-color palette to default values.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (no-op).
 void dterm_terminal_reset_palette(struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Reset a single color in the palette to its default value.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (no-op).
 void dterm_terminal_reset_palette_color(struct dterm_terminal_t *term, uint8_t index) ;
#endif

#if defined(DTERM_FFI)
// Set a callback for DCS sequences (e.g., Sixel graphics, DECRQSS).
//
// The callback will be invoked for each DCS sequence received by the terminal.
// Currently supported DCS sequences:
// - Sixel graphics (callback receives raw payload bytes)
// - DECRQSS (request selection or settings)
// - Unknown DCS sequences (payload passed through)
//
// # Safety
//
// - `term` must be a valid pointer returned by `dterm_terminal_new`, or null (no-op).
// - `callback` may be null to disable the callback.
// - `context` is passed to the callback and must remain valid while set.

void dterm_terminal_set_dcs_callback(struct dterm_terminal_t *term,
                                     DtermDCSCallback callback,
                                     void *context)
;
#endif

#if defined(DTERM_FFI)
// Set a callback for the terminal bell (BEL character, 0x07).
//
// The callback will be invoked when the terminal receives a BEL character.
// This is typically used to play a sound or flash the window.
//
// # Safety
//
// - `term` must be a valid pointer returned by `dterm_terminal_new`, or null (no-op).
// - `callback` may be null to disable the callback.
// - `context` is passed to the callback and must remain valid while set.

void dterm_terminal_set_bell_callback(struct dterm_terminal_t *term,
                                      DtermBellCallback callback,
                                      void *context)
;
#endif

#if defined(DTERM_FFI)
// Set a callback to be invoked when the terminal switches between buffers.
//
// The callback will be invoked when the terminal switches between the main
// and alternate screen buffers (e.g., when entering/exiting vim, less, etc.).
// The boolean parameter is `true` when switching to the alternate screen,
// `false` when switching back to the main screen.
//
// This maps to SwiftTerm's `bufferActivated` delegate callback.
//
// # Safety
//
// - `term` must be a valid pointer returned by `dterm_terminal_new`, or null (no-op).
// - `callback` may be null to disable the callback.
// - `context` is passed to the callback and must remain valid while set.

void dterm_terminal_set_buffer_activation_callback(struct dterm_terminal_t *term,
                                                   DtermBufferActivationCallback callback,
                                                   void *context)
;
#endif

#if defined(DTERM_FFI)
// Set callback for Kitty graphics images.
//
// The callback is invoked when a Kitty graphics image is successfully
// transmitted and stored. Parameters passed to the callback:
// - `context`: User context pointer
// - `id`: Image ID assigned by the terminal
// - `width`: Image width in pixels
// - `height`: Image height in pixels
// - `data`: RGBA pixel data (4 bytes per pixel)
// - `data_len`: Length of the pixel data in bytes
//
// The `data` pointer is valid only during the callback invocation.
// The caller must copy the data if it needs to persist beyond the callback.
//
// This maps to SwiftTerm's `createImage` delegate callback.
//
// # Safety
//
// - `term` must be a valid pointer returned by `dterm_terminal_new`, or null (no-op).
// - `callback` may be null to disable the callback.
// - `context` is passed to the callback and must remain valid while set.

void dterm_terminal_set_kitty_image_callback(struct dterm_terminal_t *term,
                                             DtermKittyImageCallback callback,
                                             void *context)
;
#endif

#if defined(DTERM_FFI)
// Set callback for terminal title changes (OSC 0, OSC 2).
//
// The callback is invoked when the terminal title is changed via OSC 0 or OSC 2.
// This maps to SwiftTerm's `setTerminalTitle` delegate callback.
//
// # Safety
//
// - `term` must be a valid pointer returned by `dterm_terminal_new`, or null (no-op).
// - `callback` may be null to disable the callback.
// - `context` is passed to the callback and must remain valid while set.

void dterm_terminal_set_title_callback(struct dterm_terminal_t *term,
                                       DtermTitleCallback callback,
                                       void *context)
;
#endif

#if defined(DTERM_FFI)
// Set callback for window manipulation commands (CSI t / XTWINOPS).
//
// The callback is invoked when a window manipulation command is received.
// This maps to SwiftTerm's `windowCommand` delegate callback.
//
// The callback receives the operation type and parameters, and can optionally
// provide a response (for query operations like report window position).
//
// # Safety
//
// - `term` must be a valid pointer returned by `dterm_terminal_new`, or null (no-op).
// - `callback` may be null to disable the callback.
// - `context` is passed to the callback and must remain valid while set.

void dterm_terminal_set_window_callback(struct dterm_terminal_t *term,
                                        DtermWindowCallback callback,
                                        void *context)
;
#endif

#if defined(DTERM_FFI)
// Set callback for shell integration events (OSC 133, OSC 7).
//
// The callback is invoked when shell integration markers are received.
// This allows tracking of command prompts, input areas, output, and completion.
//
// This maps to SwiftTerm's various shell integration delegate callbacks.
//
// # Safety
//
// - `term` must be a valid pointer returned by `dterm_terminal_new`, or null (no-op).
// - `callback` may be null to disable the callback.
// - `context` is passed to the callback and must remain valid while set.

void dterm_terminal_set_shell_callback(struct dterm_terminal_t *term,
                                       DtermShellEventCallback callback,
                                       void *context)
;
#endif

#if defined(DTERM_FFI)
// Check if the terminal has a pending Sixel image.
//
// Returns true if a Sixel image is available via `dterm_terminal_get_sixel_image`.
//
// # Safety
//
// - `term` must be a valid pointer or null (returns false).
 bool dterm_terminal_has_sixel_image(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get the pending Sixel image from the terminal.
//
// If a Sixel image is available, fills `out` and returns true.
// The caller owns the `pixels` pointer and must free it with `dterm_sixel_image_free`.
//
// # Safety
//
// - `term` must be a valid pointer or null (returns false).
// - `out` must be a valid pointer to write the image structure.
 bool dterm_terminal_get_sixel_image(struct dterm_terminal_t *term, struct DtermSixelImage *out) ;
#endif

#if defined(DTERM_FFI)
// Free a Sixel image's pixel buffer.
//
// # Safety
//
// - `pixels` must be a pointer returned by `dterm_terminal_get_sixel_image`, or null.
 void dterm_sixel_image_free(uint32_t *pixels) ;
#endif

#if defined(DTERM_FFI)
// Check if Kitty graphics storage has any images.
//
// # Safety
//
// - `term` must be a valid pointer or null (returns false).
 bool dterm_terminal_kitty_has_images(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Check if Kitty graphics storage has been modified since last clear.
//
// Use this to determine if re-rendering is needed.
//
// # Safety
//
// - `term` must be a valid pointer or null (returns false).
 bool dterm_terminal_kitty_is_dirty(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Clear the Kitty graphics dirty flag after rendering.
//
// # Safety
//
// - `term` must be a valid pointer or null (no-op).
 void dterm_terminal_kitty_clear_dirty(struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get the number of Kitty graphics images.
//
// # Safety
//
// - `term` must be a valid pointer or null (returns 0).
 uint32_t dterm_terminal_kitty_image_count(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get all Kitty image IDs into a buffer.
//
// Returns the number of IDs written (or needed if buffer is null).
//
// # Safety
//
// - `term` must be a valid pointer or null (returns 0).
// - If `ids` is not null, it must be valid for `ids_capacity` elements.

uint32_t dterm_terminal_kitty_image_ids(const struct dterm_terminal_t *term,
                                        uint32_t *ids,
                                        uint32_t ids_capacity)
;
#endif

#if defined(DTERM_FFI)
// Get info about a Kitty graphics image by ID.
//
// Returns true if the image exists and info was filled.
//
// # Safety
//
// - `term` must be a valid pointer or null (returns false).
// - `info` must be a valid pointer (returns false if null).

bool dterm_terminal_kitty_get_image_info(const struct dterm_terminal_t *term,
                                         uint32_t image_id,
                                         struct DtermKittyImageInfo *info)
;
#endif

#if defined(DTERM_FFI)
// Get pixel data for a Kitty graphics image.
//
// The pixel data is in RGBA format (4 bytes per pixel).
// Returns true if successful and fills `pixels` with a pointer to allocated memory.
// The caller must free the memory with `dterm_kitty_image_free`.
//
// # Safety
//
// - `term` must be a valid pointer or null (returns false).
// - `pixels` must be a valid pointer (returns false if null).
// - `pixel_count` must be a valid pointer (returns false if null).

bool dterm_terminal_kitty_get_image_pixels(const struct dterm_terminal_t *term,
                                           uint32_t image_id,
                                           uint8_t **pixels,
                                           uintptr_t *pixel_count)
;
#endif

#if defined(DTERM_FFI)
// Free Kitty image pixel data.
//
// # Safety
//
// - `pixels` must be a pointer returned by `dterm_terminal_kitty_get_image_pixels`, or null.
 void dterm_kitty_image_free(uint8_t *pixels) ;
#endif

#if defined(DTERM_FFI)
// Get the number of placements for a Kitty graphics image.
//
// # Safety
//
// - `term` must be a valid pointer or null (returns 0).

uint32_t dterm_terminal_kitty_placement_count(const struct dterm_terminal_t *term,
                                              uint32_t image_id)
;
#endif

#if defined(DTERM_FFI)
// Get placement IDs for a Kitty graphics image.
//
// Returns the number of IDs written (or needed if buffer is null).
//
// # Safety
//
// - `term` must be a valid pointer or null (returns 0).
// - If `ids` is not null, it must be valid for `ids_capacity` elements.

uint32_t dterm_terminal_kitty_placement_ids(const struct dterm_terminal_t *term,
                                            uint32_t image_id,
                                            uint32_t *ids,
                                            uint32_t ids_capacity)
;
#endif

#if defined(DTERM_FFI)
// Get a placement for a Kitty graphics image.
//
// Returns true if the placement exists and was filled.
//
// # Safety
//
// - `term` must be a valid pointer or null (returns false).
// - `placement` must be a valid pointer (returns false if null).

bool dterm_terminal_kitty_get_placement(const struct dterm_terminal_t *term,
                                        uint32_t image_id,
                                        uint32_t placement_id,
                                        struct DtermKittyPlacement *placement)
;
#endif

#if defined(DTERM_FFI)
// Get total bytes used by Kitty graphics storage.
//
// # Safety
//
// - `term` must be a valid pointer or null (returns 0).
 uintptr_t dterm_terminal_kitty_total_bytes(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get Kitty graphics storage quota in bytes.
//
// # Safety
//
// - `term` must be a valid pointer or null (returns 0).
 uintptr_t dterm_terminal_kitty_quota(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get the total number of lines (visible + scrollback).
//
// This includes all lines in the terminal: the visible screen area
// plus all scrollback history.
//
// # Safety
//
// - `term` must be a valid pointer or null (returns 0).
 uintptr_t dterm_terminal_total_lines(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get the text content of a line.
//
// Returns the number of bytes written to `buffer`, or the required buffer size
// if `buffer` is null or `buffer_size` is 0.
//
// Parameters:
// - `term`: Terminal handle
// - `line_index`: Line index (0 = first scrollback line, scrollback_lines = first visible row)
// - `buffer`: Output buffer for UTF-8 text (may be null to query size)
// - `buffer_size`: Size of buffer in bytes
//
// Returns:
// - If buffer is null or size is 0: required buffer size (including null terminator)
// - Otherwise: bytes written (not including null terminator)
//
// # Safety
//
// - `term` must be a valid pointer or null (returns 0).
// - If `buffer` is not null, it must be valid for `buffer_size` bytes.

uintptr_t dterm_terminal_get_line_text(const struct dterm_terminal_t *term,
                                       uintptr_t line_index,
                                       uint8_t *buffer,
                                       uintptr_t buffer_size)
;
#endif

#if defined(DTERM_FFI)
// Get visible line text (convenience wrapper).
//
// Gets the text of a visible row (not scrollback).
//
// Parameters:
// - `term`: Terminal handle
// - `row`: Row index (0 = top of visible area)
// - `buffer`: Output buffer for UTF-8 text
// - `buffer_size`: Size of buffer in bytes
//
// # Safety
//
// Same as `dterm_terminal_get_line_text`.

uintptr_t dterm_terminal_get_visible_line_text(const struct dterm_terminal_t *term,
                                               uint16_t row,
                                               uint8_t *buffer,
                                               uintptr_t buffer_size)
;
#endif

#if defined(DTERM_FFI)
// Get damaged rows for partial rendering.
//
// Returns the number of damaged rows, filling `out_damages` up to `max_count`.
//
// Use this to efficiently re-render only changed regions:
// ```c
// DtermRowDamage damages[100];
// size_t count = dterm_terminal_get_damage(term, damages, 100);
// for (size_t i = 0; i < count; i++) {
//     render_row_range(damages[i].row, damages[i].left, damages[i].right);
// }
// dterm_terminal_clear_damage(term);
// ```
//
// # Safety
//
// - `term` must be a valid pointer or null (returns 0).
// - `out_damages` must be valid for `max_count` elements, or null (returns total count).

uintptr_t dterm_terminal_get_damage(const struct dterm_terminal_t *term,
                                    struct DtermRowDamage *out_damages,
                                    uintptr_t max_count)
;
#endif

#if defined(DTERM_FFI)
// Check if a specific row is damaged.
//
// # Safety
//
// - `term` must be a valid pointer or null (returns false).
 bool dterm_terminal_row_is_damaged(const struct dterm_terminal_t *term, uint16_t row) ;
#endif

#if defined(DTERM_FFI)
// Get damage bounds for a specific row.
//
// Returns true if the row is damaged, filling `out_left` and `out_right`.
//
// # Safety
//
// - `term` must be a valid pointer or null (returns false).
// - `out_left` and `out_right` must be valid pointers, or null (just returns damaged status).

bool dterm_terminal_get_row_damage(const struct dterm_terminal_t *term,
                                   uint16_t row,
                                   uint16_t *out_left,
                                   uint16_t *out_right)
;
#endif

#if defined(DTERM_FFI)
// Get the line size attribute for a row.
//
// This indicates whether the row should be rendered as:
// - SingleWidth (0): Normal rendering
// - DoubleWidth (1): Characters rendered at 2x width
// - DoubleHeightTop (2): Top half of double-height characters
// - DoubleHeightBottom (3): Bottom half of double-height characters
//
// For double-height text, two consecutive rows must be used together:
// the top row with DoubleHeightTop, bottom row with DoubleHeightBottom.
//
// # Safety
//
// - `term` must be a valid pointer or null (returns SingleWidth).
// - `row` must be within bounds (returns SingleWidth if out of bounds).

enum DtermLineSize dterm_terminal_row_line_size(const struct dterm_terminal_t *term,
                                                uint16_t row)
;
#endif

#if defined(DTERM_FFI)
// Get the current shell integration state.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null.
 enum DtermShellState dterm_terminal_shell_state(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get the number of completed output blocks.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null.
 uintptr_t dterm_terminal_block_count(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get an output block by index.
//
// Returns true if the block was found and written to `out_block`.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null.
// - `out_block` must be a valid writable pointer, or null (returns false).

bool dterm_terminal_get_block(const struct dterm_terminal_t *term,
                              uintptr_t index,
                              struct DtermOutputBlock *out_block)
;
#endif

#if defined(DTERM_FFI)
// Get the current (in-progress) output block.
//
// Returns true if there is a current block and it was written to `out_block`.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null.
// - `out_block` must be a valid writable pointer, or null (returns false).

bool dterm_terminal_get_current_block(const struct dterm_terminal_t *term,
                                      struct DtermOutputBlock *out_block)
;
#endif

#if defined(DTERM_FFI)
// Find the output block containing a given row.
//
// Returns the block index if found, or `usize::MAX` if no block contains the row.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null.
 uintptr_t dterm_terminal_block_at_row(const struct dterm_terminal_t *term, uintptr_t row) ;
#endif

#if defined(DTERM_FFI)
// Get the exit code of the last completed block.
//
// Returns true if there was a completed or current block with an exit code.
// Checks current_block first (most recent), then falls back to output_blocks.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null.
// - `out_exit_code` must be a valid writable pointer, or null (returns false).
 bool dterm_terminal_last_exit_code(const struct dterm_terminal_t *term, int32_t *out_exit_code) ;
#endif

#if defined(DTERM_FFI)
// Create a new smart selection engine with all built-in rules.
//
// Returns a handle that can be used with `dterm_terminal_smart_*` functions.
// The handle must be freed with `dterm_smart_selection_free`.
 struct DtermSmartSelection *dterm_smart_selection_new(void) ;
#endif

#if defined(DTERM_FFI)
// Create an empty smart selection engine (no rules).
 struct DtermSmartSelection *dterm_smart_selection_new_empty(void) ;
#endif

#if defined(DTERM_FFI)
// Free a smart selection engine.
//
// # Safety
//
// - `selection` must be a valid pointer returned by `dterm_smart_selection_new*`, or null.
// - `selection` must not have been freed previously.
 void dterm_smart_selection_free(struct DtermSmartSelection *selection) ;
#endif

#if defined(DTERM_FFI)
// Enable or disable a rule by name.
//
// Returns true if the rule was found, false otherwise.
//
// # Safety
//
// - `selection` must be a valid pointer.
// - `name` must be a valid null-terminated UTF-8 string.

bool dterm_smart_selection_set_rule_enabled(struct DtermSmartSelection *selection,
                                            const char *name,
                                            bool enabled)
;
#endif

#if defined(DTERM_FFI)
// Free a selection match returned by `dterm_terminal_smart_match_at`.
//
// # Safety
//
// - `match_ptr` must be a valid pointer to a `DtermSelectionMatch`, or null.
 void dterm_selection_match_free(struct DtermSelectionMatch *match_ptr) ;
#endif

#if defined(DTERM_FFI)
// Get smart word boundaries at a position on a row.
//
// Returns true if a word/semantic unit was found, false otherwise.
// On success, `out_start` and `out_end` are set to the column boundaries.
//
// # Safety
//
// - All pointers must be valid (or null for output pointers if result not needed).

bool dterm_terminal_smart_word_at(const struct dterm_terminal_t *term,
                                  const struct DtermSmartSelection *selection,
                                  uint32_t row,
                                  uint32_t col,
                                  uint32_t *out_start,
                                  uint32_t *out_end)
;
#endif

#if defined(DTERM_FFI)
// Find a semantic match at a position on a row.
//
// Returns a pointer to a `DtermSelectionMatch` if found, null otherwise.
// The returned match must be freed with `dterm_selection_match_free`.
//
// # Safety
//
// - All pointers must be valid.

struct DtermSelectionMatch *dterm_terminal_smart_match_at(const struct dterm_terminal_t *term,
                                                          const struct DtermSmartSelection *selection,
                                                          uint32_t row,
                                                          uint32_t col)
;
#endif

#if defined(DTERM_FFI)
// Count semantic matches on a row.
//
// # Safety
//
// - All pointers must be valid.

uint32_t dterm_terminal_smart_match_count(const struct dterm_terminal_t *term,
                                          const struct DtermSmartSelection *selection,
                                          uint32_t row)
;
#endif

#if defined(DTERM_FFI)
// Get semantic matches on a row.
//
// Fills `out_matches` with up to `max_matches` matches. Returns the actual count.
// Each match must be freed with `dterm_selection_match_free`.
//
// # Safety
//
// - All pointers must be valid.
// - `out_matches` must have room for at least `max_matches` pointers.

uint32_t dterm_terminal_smart_matches_on_row(const struct dterm_terminal_t *term,
                                             const struct DtermSmartSelection *selection,
                                             uint32_t row,
                                             struct DtermSelectionMatch **out_matches,
                                             uint32_t max_matches)
;
#endif

#if defined(DTERM_FFI)
// Start a text selection.
//
// Call this on mouse down to begin a new selection.
//
// # Parameters
//
// - `term`: Terminal handle
// - `col`: Starting column (0-indexed)
// - `row`: Starting row (0 = top of visible area, negative = scrollback)
// - `selection_type`: Type of selection (Simple, Block, Semantic, Lines)
//
// # Safety
//
// - `term` must be a valid pointer returned by `dterm_terminal_new*`.

void dterm_terminal_selection_start(struct dterm_terminal_t *term,
                                    uint32_t col,
                                    int32_t row,
                                    DtermSelectionType selection_type)
;
#endif

#if defined(DTERM_FFI)
// Update text selection endpoint.
//
// Call this on mouse drag to update the selection.
// Only works when selection is in progress.
//
// # Parameters
//
// - `term`: Terminal handle
// - `col`: Current column (0-indexed)
// - `row`: Current row (0 = top of visible area, negative = scrollback)
//
// # Safety
//
// - `term` must be a valid pointer returned by `dterm_terminal_new*`.
 void dterm_terminal_selection_update(struct dterm_terminal_t *term, uint32_t col, int32_t row) ;
#endif

#if defined(DTERM_FFI)
// Complete text selection.
//
// Call this on mouse up to complete the selection.
//
// # Safety
//
// - `term` must be a valid pointer returned by `dterm_terminal_new*`.
 void dterm_terminal_selection_end(struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Clear text selection.
//
// Removes any active selection.
//
// # Safety
//
// - `term` must be a valid pointer returned by `dterm_terminal_new*`.
 void dterm_terminal_selection_clear(struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Check if terminal has an active selection.
//
// Returns true if there is any selection (in progress or complete).
//
// # Safety
//
// - `term` must be a valid pointer returned by `dterm_terminal_new*`.
 bool dterm_terminal_has_selection(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Get selected text as a C string.
//
// Returns the selected text, or null if there is no selection.
// The returned string must be freed by the caller using `dterm_string_free`.
//
// # Safety
//
// - `term` must be a valid pointer returned by `dterm_terminal_new*`.
// - The returned pointer must be freed with `dterm_string_free`.
 char *dterm_terminal_selection_to_string(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Free a string returned by dterm FFI functions.
//
// Strings returned by functions like `dterm_terminal_selection_to_string`
// must be freed using this function.
//
// # Safety
//
// - `s` must be a valid pointer returned by a dterm FFI function, or null.
// - `s` must not have been freed previously.
 void dterm_string_free(char *s) ;
#endif

#if defined(DTERM_FFI)
// Check if secure keyboard entry mode is enabled.
//
// When enabled, the UI layer should activate platform-specific secure input
// mechanisms to prevent keylogging:
//
// - **macOS**: Call `EnableSecureEventInput()` / `DisableSecureEventInput()`
// - **iOS**: Not applicable (sandboxed by default)
// - **Windows**: Limited protection available (document to users)
// - **Linux/X11**: Not possible (X11 is inherently insecure)
// - **Linux/Wayland**: Secure by default (no action needed)
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor, or null (returns false).
 bool dterm_terminal_is_secure_keyboard_entry(const struct dterm_terminal_t *term) ;
#endif

#if defined(DTERM_FFI)
// Enable or disable secure keyboard entry mode.
//
// When enabled, the UI layer should activate platform-specific secure input
// mechanisms to prevent keylogging. See `dterm_terminal_is_secure_keyboard_entry`
// for platform-specific guidance.
//
// # Safety
//
// - `term` must be a valid pointer returned by a terminal constructor.
// - `term` must not be null.
 void dterm_terminal_set_secure_keyboard_entry(struct dterm_terminal_t *term, bool enabled) ;
#endif

#if defined(DTERM_FFI)
// Get library version string.
 const char *dterm_version(void) ;
#endif

#if defined(DTERM_FFI)
// Create a new UI Bridge.
//
// Returns a pointer to the bridge, or null on allocation failure.
 struct DtermUIBridge *dterm_ui_create(void) ;
#endif

#if defined(DTERM_FFI)
// Free a UI Bridge.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.
// - `bridge` must not have been freed previously (no double-free).
// - After this call, `bridge` is invalid and must not be used.
 void dterm_ui_free(struct DtermUIBridge *bridge) ;
#endif

#if defined(DTERM_FFI)
// Get the current UI state.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.
//
// Returns `Idle` if bridge is null.
 enum DtermUIState dterm_ui_state(const struct DtermUIBridge *bridge) ;
#endif

#if defined(DTERM_FFI)
// Get the number of pending events in the queue.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.
//
// Returns 0 if bridge is null.
 uintptr_t dterm_ui_pending_count(const struct DtermUIBridge *bridge) ;
#endif

#if defined(DTERM_FFI)
// Get the number of pending callbacks.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.
//
// Returns 0 if bridge is null.
 uintptr_t dterm_ui_callback_count(const struct DtermUIBridge *bridge) ;
#endif

#if defined(DTERM_FFI)
// Get the number of pending renders.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.
//
// Returns 0 if bridge is null.
 uintptr_t dterm_ui_render_pending_count(const struct DtermUIBridge *bridge) ;
#endif

#if defined(DTERM_FFI)
// Check if the UI Bridge is in a consistent state.
//
// This verifies all TLA+ invariants hold.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.
//
// Returns false if bridge is null.
 bool dterm_ui_is_consistent(const struct DtermUIBridge *bridge) ;
#endif

#if defined(DTERM_FFI)
// Get the state of a terminal.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.
//
// Returns `Inactive` if bridge is null.

enum DtermUITerminalState dterm_ui_terminal_state(const struct DtermUIBridge *bridge,
                                                  TerminalId terminal_id)
;
#endif

#if defined(DTERM_FFI)
// Enqueue an input event.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.
// - `data` must be a valid pointer to `data_len` bytes, or null if `data_len` is 0.

enum DtermUIErrorCode dterm_ui_enqueue_input(struct DtermUIBridge *bridge,
                                             TerminalId terminal_id,
                                             const uint8_t *data,
                                             uintptr_t data_len)
;
#endif

#if defined(DTERM_FFI)
// Enqueue a resize event.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.

enum DtermUIErrorCode dterm_ui_enqueue_resize(struct DtermUIBridge *bridge,
                                              TerminalId terminal_id,
                                              uint16_t rows,
                                              uint16_t cols)
;
#endif

#if defined(DTERM_FFI)
// Enqueue a render event.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.

enum DtermUIErrorCode dterm_ui_enqueue_render(struct DtermUIBridge *bridge,
                                              TerminalId terminal_id)
;
#endif

#if defined(DTERM_FFI)
// Enqueue a create terminal event.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.

enum DtermUIErrorCode dterm_ui_enqueue_create_terminal(struct DtermUIBridge *bridge,
                                                       TerminalId terminal_id)
;
#endif

#if defined(DTERM_FFI)
// Enqueue a destroy terminal event.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.

enum DtermUIErrorCode dterm_ui_enqueue_destroy_terminal(struct DtermUIBridge *bridge,
                                                        TerminalId terminal_id)
;
#endif

#if defined(DTERM_FFI)
// Enqueue a callback request event.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.

enum DtermUIErrorCode dterm_ui_enqueue_callback(struct DtermUIBridge *bridge,
                                                TerminalId terminal_id,
                                                CallbackId callback_id)
;
#endif

#if defined(DTERM_FFI)
// Enqueue a shutdown event.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.
 enum DtermUIErrorCode dterm_ui_enqueue_shutdown(struct DtermUIBridge *bridge) ;
#endif

#if defined(DTERM_FFI)
// Start processing the next event.
//
// Returns Ok (0) and fills `out_info` if successful.
// Returns an error code on failure.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.
// - `out_info` must be a valid writable pointer, or null.

enum DtermUIErrorCode dterm_ui_start_processing(struct DtermUIBridge *bridge,
                                                struct DtermUIEventInfo *out_info)
;
#endif

#if defined(DTERM_FFI)
// Complete processing the current event.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.
 enum DtermUIErrorCode dterm_ui_complete_processing(struct DtermUIBridge *bridge) ;
#endif

#if defined(DTERM_FFI)
// Complete a render for a terminal.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.

enum DtermUIErrorCode dterm_ui_complete_render(struct DtermUIBridge *bridge,
                                               TerminalId terminal_id)
;
#endif

#if defined(DTERM_FFI)
// Complete a callback.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.

enum DtermUIErrorCode dterm_ui_complete_callback(struct DtermUIBridge *bridge,
                                                 CallbackId callback_id)
;
#endif

#if defined(DTERM_FFI)
// Handle an event in one shot (convenience function).
//
// This enqueues and processes the event immediately if the bridge is idle.
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.

enum DtermUIErrorCode dterm_ui_handle_create_terminal(struct DtermUIBridge *bridge,
                                                      TerminalId terminal_id)
;
#endif

#if defined(DTERM_FFI)
// Handle a destroy terminal event in one shot (convenience function).
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.

enum DtermUIErrorCode dterm_ui_handle_destroy_terminal(struct DtermUIBridge *bridge,
                                                       TerminalId terminal_id)
;
#endif

#if defined(DTERM_FFI)
// Handle an input event in one shot (convenience function).
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.
// - `data` must be a valid pointer to `data_len` bytes, or null if `data_len` is 0.

enum DtermUIErrorCode dterm_ui_handle_input(struct DtermUIBridge *bridge,
                                            TerminalId terminal_id,
                                            const uint8_t *data,
                                            uintptr_t data_len)
;
#endif

#if defined(DTERM_FFI)
// Handle a resize event in one shot (convenience function).
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.

enum DtermUIErrorCode dterm_ui_handle_resize(struct DtermUIBridge *bridge,
                                             TerminalId terminal_id,
                                             uint16_t rows,
                                             uint16_t cols)
;
#endif

#if defined(DTERM_FFI)
// Handle a shutdown event in one shot (convenience function).
//
// # Safety
//
// - `bridge` must be a valid pointer returned by `dterm_ui_create`, or null.
 enum DtermUIErrorCode dterm_ui_handle_shutdown(struct DtermUIBridge *bridge) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Create a new renderer with optional configuration.
//
// Returns a pointer to the renderer, or null on failure.
//
// # Safety
//
// - `config` may be null (uses defaults).
 struct DtermRenderer *dterm_renderer_create(const struct DtermRendererConfig *config) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Create a new renderer with custom configuration.
//
// Returns a pointer to the renderer, or null on failure.
//
// # Safety
//
// - `config` must be a valid pointer to a `DtermRendererConfig`, or null.
 struct DtermRenderer *dterm_renderer_create_with_config(const struct DtermRendererConfig *config) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Free a renderer.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`, or null.
// - `renderer` must not have been freed previously.
 void dterm_renderer_free(struct DtermRenderer *renderer) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Destroy a renderer.
//
// This is an alias for `dterm_renderer_free`.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`, or null.
 void dterm_renderer_destroy(struct DtermRenderer *renderer) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Request a new frame.
//
// The returned handle must be completed with `dterm_renderer_complete_frame`
// or the frame will timeout/cancel automatically.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.
 struct DtermFrameHandle dterm_renderer_request_frame(struct DtermRenderer *renderer) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Provide a drawable for a frame request.
//
// This should be called after the platform provides a drawable
// (e.g., CAMetalDrawable from nextDrawable()).
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.
// - `handle` must be a valid handle returned by `dterm_renderer_request_frame`.
// - `metal_texture` may be null (signals readiness without storing a drawable).

bool dterm_renderer_provide_drawable(struct DtermRenderer *renderer,
                                     struct DtermFrameHandle handle,
                                     void *metal_texture)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Complete a frame request, signaling that the drawable is ready.
//
// This is a compatibility wrapper for `dterm_renderer_provide_drawable`.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.
// - `handle` must be a valid handle returned by `dterm_renderer_request_frame`.

void dterm_renderer_complete_frame(struct DtermRenderer *renderer,
                                   struct DtermFrameHandle handle)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Cancel a frame request.
//
// This can be called if the platform cannot provide a drawable.
// The frame will be marked as cancelled.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.
// - `handle` must be a valid handle returned by `dterm_renderer_request_frame`.
 void dterm_renderer_cancel_frame(struct DtermRenderer *renderer, struct DtermFrameHandle handle) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Wait for a frame to be ready.
//
// Blocks until the frame is ready, cancelled, or timeout expires.
//
// # Arguments
// * `renderer` - Renderer handle
// * `handle` - Frame handle to wait on
// * `timeout_ms` - Timeout in milliseconds
//
// # Returns
// Frame status (Ready, Timeout, or Cancelled).
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.

enum DtermFrameStatus dterm_renderer_wait_frame(struct DtermRenderer *renderer,
                                                struct DtermFrameHandle handle,
                                                uint64_t timeout_ms)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Render the terminal using the hybrid renderer.
//
// This builds vertex/uniform data for the current terminal state and stores
// it in the renderer's hybrid cache for platform rendering.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.
// - `terminal` must be a valid pointer to a `Terminal`.

struct DtermRenderResult dterm_renderer_render(struct DtermRenderer *renderer,
                                               const struct Terminal *terminal)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get the default renderer configuration.
//
// # Safety
//
// - `out_config` must be a valid pointer to a `DtermRendererConfig`.
 void dterm_renderer_get_default_config(struct DtermRendererConfig *out_config) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Check if the renderer FFI is available.
//
// This can be called to verify that the GPU renderer was compiled in.
 bool dterm_renderer_available(void) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Set the background color for the renderer.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.
//
// # Arguments
//
// * `r`, `g`, `b`, `a` - Color components (0.0-1.0 range)

bool dterm_renderer_set_background_color(struct DtermRenderer *renderer,
                                         float r,
                                         float g,
                                         float b,
                                         float _a)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Set the background image for the renderer.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.
// - `texture` must be a valid platform texture pointer (opaque).

bool dterm_renderer_set_background_image(struct DtermRenderer *renderer,
                                         void *texture,
                                         enum DtermBlendMode blend_mode,
                                         float opacity)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Clear the background image for the renderer.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.
 bool dterm_renderer_clear_background_image(struct DtermRenderer *renderer) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Set the cursor style for the renderer.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.
 bool dterm_renderer_set_cursor_style(struct DtermRenderer *renderer, enum DtermCursorStyle style) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Set the cursor blink rate in milliseconds.
//
// A value of 0 disables cursor blinking.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.
 bool dterm_renderer_set_cursor_blink_rate(struct DtermRenderer *renderer, uint32_t ms) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Set the selection highlight color.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.
//
// # Arguments
//
// * `r`, `g`, `b`, `a` - Color components (0.0-1.0 range)

bool dterm_renderer_set_selection_color(struct DtermRenderer *renderer,
                                        float r,
                                        float g,
                                        float b,
                                        float a)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Set the base font for the renderer from raw font data.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.
// - `font_data` must point to valid TTF/OTF data of length `font_data_len`.
//
// # Returns
//
// `true` on success, `false` on failure.

bool dterm_renderer_set_font(struct DtermRenderer *renderer,
                             const uint8_t *font_data,
                             uintptr_t font_data_len,
                             float size_pts)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Set the bold font variant for the renderer.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.
// - `font_data` must point to valid TTF/OTF data of length `font_data_len`.

bool dterm_renderer_set_bold_font(struct DtermRenderer *renderer,
                                  const uint8_t *font_data,
                                  uintptr_t font_data_len,
                                  float size_pts)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Set the italic font variant for the renderer.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.
// - `font_data` must point to valid TTF/OTF data of length `font_data_len`.

bool dterm_renderer_set_italic_font(struct DtermRenderer *renderer,
                                    const uint8_t *font_data,
                                    uintptr_t font_data_len,
                                    float size_pts)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Clear the font cache, forcing all glyphs to be re-rasterized.
//
// Call this when changing font sizes or after extended use to free memory.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.
 bool dterm_renderer_clear_font_cache(struct DtermRenderer *renderer) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get cell dimensions from the renderer.
//
// Returns the cell width and height in pixels based on the current font.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.
// - `cell_width` and `cell_height` must be valid pointers.

bool dterm_renderer_get_cell_size(struct DtermRenderer *renderer,
                                  float *cell_width,
                                  float *cell_height)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get the font baseline offset.
//
// Returns the distance from the top of the cell to the text baseline, in pixels.
// This is needed for correct text positioning.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_renderer_create`.
//
// # Returns
//
// Baseline offset in pixels, or 0.0 if no font is set.
 float dterm_renderer_get_baseline(const struct DtermRenderer *renderer) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Create a full GPU renderer.
//
// The platform must provide valid wgpu device and queue pointers. These are
// typically obtained by creating a wgpu instance and requesting a device.
//
// # Safety
//
// - `device` must be a valid pointer to a `wgpu::Device`
// - `queue` must be a valid pointer to a `wgpu::Queue`
// - Both must remain valid for the lifetime of the renderer
//
// # Returns
//
// Pointer to the renderer, or null on failure.

struct DtermGpuRenderer *dterm_gpu_renderer_create(const void *device,
                                                   const void *queue,
                                                   const struct DtermRendererConfig *config)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Create a full GPU renderer with explicit surface format.
//
// Like `dterm_gpu_renderer_create`, but allows specifying the swapchain format.
//
// # Safety
//
// Same requirements as `dterm_gpu_renderer_create`.
// Additionally, `surface_format` must be a valid wgpu::TextureFormat value.

struct DtermGpuRenderer *dterm_gpu_renderer_create_with_format(const void *device,
                                                               const void *queue,
                                                               const struct DtermRendererConfig *config,
                                                               uint32_t surface_format)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Free a GPU renderer.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_gpu_renderer_create`, or null.
// - `renderer` must not have been freed previously.
 void dterm_gpu_renderer_free(struct DtermGpuRenderer *renderer) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Render the terminal to the provided surface view.
//
// This performs a full render of all terminal cells.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_gpu_renderer_create`.
// - `terminal` must be a valid pointer to a `Terminal`.
// - `surface_view` must be a valid pointer to a `wgpu::TextureView`.
//
// # Returns
//
// `DtermRenderError::Ok` on success, error code on failure.

enum DtermRenderError dterm_gpu_renderer_render(struct DtermGpuRenderer *renderer,
                                                const struct Terminal *terminal,
                                                const void *surface_view)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Render the terminal with damage-based optimization.
//
// This only renders cells that have changed, significantly reducing GPU work
// for small updates. If `damage` is null, performs a full render.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_gpu_renderer_create`.
// - `terminal` must be a valid pointer to a `Terminal`.
// - `surface_view` must be a valid pointer to a `wgpu::TextureView`.
// - `damage` may be null (triggers full render) or a valid pointer to a `Damage`.
//
// # Returns
//
// `DtermRenderError::Ok` on success, error code on failure.

enum DtermRenderError dterm_gpu_renderer_render_with_damage(struct DtermGpuRenderer *renderer,
                                                            const struct Terminal *terminal,
                                                            const void *surface_view,
                                                            const struct Damage *damage)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Request a frame from the renderer's frame sync.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_gpu_renderer_create`.
//
// # Returns
//
// Frame handle with ID, or handle with id=u64::MAX on error.
 struct DtermFrameHandle dterm_gpu_renderer_request_frame(struct DtermGpuRenderer *renderer) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Wait for a frame to be ready.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_gpu_renderer_create`.
//
// # Returns
//
// Frame status.

enum DtermFrameStatus dterm_gpu_renderer_wait_frame(struct DtermGpuRenderer *renderer,
                                                    uint64_t timeout_ms)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Check if the full GPU renderer FFI is available.
 bool dterm_gpu_renderer_available(void) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Set the font for the GPU renderer from raw font data (TTF/OTF bytes).
//
// This creates a glyph atlas from the provided font data and attaches it
// to the renderer. The font data is copied internally, so the caller can
// free the original buffer after this call returns.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_gpu_renderer_create`.
// - `font_data` must be a valid pointer to TTF/OTF font data.
// - `font_len` must be the exact length of the font data in bytes.
// - The font data must be valid for the duration of this call.
//
// # Returns
//
// `true` on success, `false` on failure (invalid renderer, font, or config).

bool dterm_gpu_renderer_set_font(struct DtermGpuRenderer *renderer,
                                 const uint8_t *font_data,
                                 uintptr_t font_len,
                                 const struct DtermAtlasConfig *config)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Set additional font variants (bold, italic, bold-italic) for the GPU renderer.
//
// This should be called after `dterm_gpu_renderer_set_font` to add style variants.
// Each variant is optional and can be NULL.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_gpu_renderer_create`.
// - Font data pointers must be valid if not NULL.
// - Font lengths must match the actual data lengths.
//
// # Returns
//
// `true` on success, `false` on failure.

bool dterm_gpu_renderer_set_font_variants(struct DtermGpuRenderer *renderer,
                                          const uint8_t *bold_data,
                                          uintptr_t bold_len,
                                          const uint8_t *italic_data,
                                          uintptr_t italic_len,
                                          const uint8_t *bold_italic_data,
                                          uintptr_t bold_italic_len)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get cell dimensions from the glyph atlas.
//
// Returns the cell width and height in pixels based on the current font.
// These values are needed by the platform to properly size the terminal view.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_gpu_renderer_create`.
// - `cell_width` and `cell_height` must be valid pointers.
//
// # Returns
//
// `true` if cell dimensions were retrieved, `false` if no font is set.

bool dterm_gpu_renderer_get_cell_size(struct DtermGpuRenderer *renderer,
                                      float *cell_width,
                                      float *cell_height)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Set a background image for the GPU renderer.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_gpu_renderer_create`.
// - `texture_view` must be a valid pointer to a `wgpu::TextureView`.
// - This function takes ownership of the `TextureView`. The caller must not
//   use or free the texture view after calling this function.

bool dterm_gpu_renderer_set_background_image(struct DtermGpuRenderer *renderer,
                                             void *texture_view,
                                             enum DtermBlendMode blend_mode,
                                             float opacity)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Clear the background image for the GPU renderer.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_gpu_renderer_create`.
 bool dterm_gpu_renderer_clear_background_image(struct DtermGpuRenderer *renderer) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Create a hybrid renderer.
//
// This creates a renderer that generates vertex data for the platform to use.
//
// # Safety
//
// - `config` may be null (uses defaults).
//
// # Returns
//
// Pointer to the renderer, or null on failure.

struct DtermHybridRenderer *dterm_hybrid_renderer_create(const struct DtermRendererConfig *config)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Free a hybrid renderer.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_hybrid_renderer_create`, or null.
 void dterm_hybrid_renderer_free(struct DtermHybridRenderer *renderer) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Set the font for the hybrid renderer from raw font data.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_hybrid_renderer_create`.
// - `font_data` must be a valid pointer to TTF/OTF font data.
// - `font_len` must be the exact length of the font data in bytes.
//
// # Returns
//
// `true` on success, `false` on failure.

bool dterm_hybrid_renderer_set_font(struct DtermHybridRenderer *renderer,
                                    const uint8_t *font_data,
                                    uintptr_t font_len,
                                    const struct DtermAtlasConfig *config)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get cell dimensions from the hybrid renderer.
//
// # Safety
//
// - `renderer` must be a valid pointer.
// - `cell_width` and `cell_height` must be valid pointers.
//
// # Returns
//
// `true` if cell dimensions were retrieved, `false` if no font is set.

bool dterm_hybrid_renderer_get_cell_size(struct DtermHybridRenderer *renderer,
                                         float *cell_width,
                                         float *cell_height)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Build vertex data for the terminal.
//
// This generates all vertex data needed to render the terminal. The data
// is cached internally and can be accessed via `dterm_hybrid_renderer_get_vertices`.
//
// # Safety
//
// - `renderer` must be a valid pointer.
// - `terminal` must be a valid pointer to a Terminal.
//
// # Returns
//
// The number of vertices generated, or 0 on failure.

uint32_t dterm_hybrid_renderer_build(struct DtermHybridRenderer *renderer,
                                     const struct Terminal *terminal)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get the background vertex data from the last build.
//
// Returns solid-color background quads (rendered first, no texture needed).
//
// # Safety
// - `renderer` must be a valid pointer.
// - `out_count` must be a valid pointer.

const struct DtermCellVertex *dterm_hybrid_renderer_get_background_vertices(const struct DtermHybridRenderer *renderer,
                                                                            uint32_t *out_count)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get the glyph vertex data from the last build.
//
// Returns textured glyph quads (rendered second, uses atlas texture).
//
// # Safety
// - `renderer` must be a valid pointer.
// - `out_count` must be a valid pointer.

const struct DtermCellVertex *dterm_hybrid_renderer_get_glyph_vertices(const struct DtermHybridRenderer *renderer,
                                                                       uint32_t *out_count)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get the decoration vertex data from the last build.
//
// Returns underline/strikethrough/box-drawing quads (rendered last, solid color).
//
// # Safety
// - `renderer` must be a valid pointer.
// - `out_count` must be a valid pointer.

const struct DtermCellVertex *dterm_hybrid_renderer_get_decoration_vertices(const struct DtermHybridRenderer *renderer,
                                                                            uint32_t *out_count)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get all vertex data combined from the last build (DEPRECATED).
//
// Returns total count but only pointer to backgrounds.
// Use separate getters for proper multi-pass rendering.
//
// # Safety
// - `renderer` must be a valid pointer.
// - `out_count` must be a valid pointer.

const struct DtermCellVertex *dterm_hybrid_renderer_get_vertices(const struct DtermHybridRenderer *renderer,
                                                                 uint32_t *out_count)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get the uniforms from the last build.
//
// The returned pointer is valid until the next call to `dterm_hybrid_renderer_build`
// or `dterm_hybrid_renderer_free`.
//
// # Safety
//
// - `renderer` must be a valid pointer.
//
// # Returns
//
// Pointer to the uniforms, or null if no data is available.

const struct DtermUniforms *dterm_hybrid_renderer_get_uniforms(const struct DtermHybridRenderer *renderer)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get the atlas size.
//
// # Safety
//
// - `renderer` must be a valid pointer.
//
// # Returns
//
// Atlas size in pixels, or 0 if no font is set.
 uint32_t dterm_hybrid_renderer_get_atlas_size(const struct DtermHybridRenderer *renderer) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get the number of pending glyph uploads.
//
// # Safety
//
// - `renderer` must be a valid pointer.
//
// # Returns
//
// The number of pending glyphs, or 0 if none.
 uint32_t dterm_hybrid_renderer_pending_glyph_count(const struct DtermHybridRenderer *renderer) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get pending glyph data by index.
//
// After `dterm_hybrid_renderer_build` is called, new glyphs may have been
// rasterized. This function returns the pending glyph bitmap data that needs
// to be uploaded to the platform's texture.
//
// # Safety
//
// - `renderer` must be a valid pointer.
// - `index` must be less than the count returned by `dterm_hybrid_renderer_pending_glyph_count`.
// - `out_entry` must be a valid pointer.
// - `out_data` must be a valid pointer.
// - `out_data_len` must be a valid pointer.
//
// # Returns
//
// `true` if the glyph data was retrieved, `false` if index is out of bounds.

bool dterm_hybrid_renderer_get_pending_glyph(const struct DtermHybridRenderer *renderer,
                                             uint32_t index,
                                             struct DtermGlyphEntry *out_entry,
                                             const uint8_t **out_data,
                                             uintptr_t *out_data_len)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Clear pending glyph data.
//
// Call this after uploading all pending glyphs to the platform texture.
//
// # Safety
//
// - `renderer` must be a valid pointer.
 void dterm_hybrid_renderer_clear_pending_glyphs(struct DtermHybridRenderer *renderer) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get the full atlas bitmap data.
//
// This returns the entire atlas texture data as a single-channel (grayscale) bitmap.
// The platform can use this to create or update its texture.
//
// The returned pointer is valid until the next call to `dterm_hybrid_renderer_build`,
// `dterm_hybrid_renderer_set_font`, or `dterm_hybrid_renderer_free`.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_hybrid_renderer_create`.
// - `out_data` must be a valid pointer to receive the texture data pointer.
// - `out_len` must be a valid pointer to receive the texture data length in bytes.
// - `out_width` must be a valid pointer to receive the atlas width in pixels.
// - `out_height` must be a valid pointer to receive the atlas height in pixels.
//
// # Returns
//
// `true` if atlas data is available, `false` if no font is set or any pointer is null.

bool dterm_hybrid_renderer_get_atlas_data(const struct DtermHybridRenderer *renderer,
                                          const uint8_t **out_data,
                                          uintptr_t *out_len,
                                          uint32_t *out_width,
                                          uint32_t *out_height)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Check if the hybrid renderer FFI is available.
 bool dterm_hybrid_renderer_available(void) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Enable or disable platform-rendered glyph mode.
//
// When enabled, the renderer uses platform-provided glyph entries instead of
// the internal fontdue-based atlas. The platform must provide glyph entries
// via `dterm_hybrid_renderer_add_platform_glyph`.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_hybrid_renderer_create`.
//
// # Returns
//
// `true` on success, `false` if renderer is null.

bool dterm_hybrid_renderer_enable_platform_glyphs(struct DtermHybridRenderer *renderer,
                                                  bool enable)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Set the cell size for platform-rendered glyphs.
//
// The platform computes cell dimensions from font metrics using Core Text.
// This must be called before `dterm_hybrid_renderer_build` when using
// platform glyphs.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_hybrid_renderer_create`.
//
// # Returns
//
// `true` on success, `false` if renderer is null.

bool dterm_hybrid_renderer_set_platform_cell_size(struct DtermHybridRenderer *renderer,
                                                  float width,
                                                  float height)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Set the atlas size for platform-rendered glyphs.
//
// The platform manages its own texture atlas. This tells dterm-core the
// atlas dimensions for UV coordinate calculation.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_hybrid_renderer_create`.
//
// # Returns
//
// `true` on success, `false` if renderer is null.

bool dterm_hybrid_renderer_set_platform_atlas_size(struct DtermHybridRenderer *renderer,
                                                   uint32_t size)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Add a platform-rendered glyph entry.
//
// The platform renders glyphs using Core Text and adds them to its texture atlas.
// This function tells dterm-core where each glyph is located in the atlas.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_hybrid_renderer_create`.
//
// # Returns
//
// `true` on success, `false` if renderer is null.

bool dterm_hybrid_renderer_add_platform_glyph(struct DtermHybridRenderer *renderer,
                                              uint32_t codepoint,
                                              uint16_t x,
                                              uint16_t y,
                                              uint16_t width,
                                              uint16_t height,
                                              int16_t bearing_x,
                                              int16_t bearing_y,
                                              uint16_t advance)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Clear all platform-rendered glyph entries.
//
// Call this when changing fonts to remove stale glyph entries.
//
// # Safety
//
// - `renderer` must be a valid pointer returned by `dterm_hybrid_renderer_create`.
 void dterm_hybrid_renderer_clear_platform_glyphs(struct DtermHybridRenderer *renderer) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get the number of platform glyph entries.
//
// # Safety
//
// - `renderer` must be a valid pointer.
//
// # Returns
//
// The number of platform glyphs registered, or 0 if renderer is null.
 uint32_t dterm_hybrid_renderer_platform_glyph_count(const struct DtermHybridRenderer *renderer) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Check if platform glyph mode is enabled.
//
// # Safety
//
// - `renderer` must be a valid pointer.
//
// # Returns
//
// `true` if platform glyph mode is enabled, `false` otherwise.
 bool dterm_hybrid_renderer_is_platform_glyphs_enabled(const struct DtermHybridRenderer *renderer) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Create a new image texture cache.
//
// # Safety
//
// The returned pointer must be freed with `dterm_image_cache_free`.
//
// # Arguments
//
// * `memory_budget` - Maximum GPU memory budget in bytes (0 = use default 64MB).
//
// # Returns
//
// A new image cache handle, or null on failure.
 struct DtermImageCache *dterm_image_cache_create(uintptr_t memory_budget) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Free an image texture cache.
//
// # Safety
//
// - `cache` must be a valid pointer returned by `dterm_image_cache_create`,
//   or null (which is a no-op).
 void dterm_image_cache_free(struct DtermImageCache *cache) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Upload an image to the cache.
//
// This allocates a handle and prepares the image for GPU upload.
// The actual GPU texture creation is the caller's responsibility.
//
// # Safety
//
// - `cache` must be a valid pointer returned by `dterm_image_cache_create`.
// - `data` must be a valid pointer to image pixel data.
// - `data_len` must be the exact length of the data in bytes.
// - The data must remain valid for the duration of this call.
//
// # Arguments
//
// * `cache` - Image cache handle.
// * `data` - Pointer to image pixel data.
// * `data_len` - Length of data in bytes.
// * `width` - Image width in pixels.
// * `height` - Image height in pixels.
// * `format` - Image format (0=RGBA, 1=RGB, 2=ARGB).
// * `out_rgba` - Output pointer for converted RGBA data (caller must free with `dterm_image_free_rgba`).
// * `out_rgba_len` - Output length of RGBA data.
//
// # Returns
//
// Image handle (non-zero on success, 0 on failure).

uint64_t dterm_image_cache_upload(struct DtermImageCache *cache,
                                  const uint8_t *data,
                                  uintptr_t data_len,
                                  uint32_t width,
                                  uint32_t height,
                                  uint8_t format,
                                  uint8_t **out_rgba,
                                  uintptr_t *out_rgba_len)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Free RGBA data returned by `dterm_image_cache_upload`.
//
// # Safety
//
// - `data` must be a pointer returned by `dterm_image_cache_upload` via `out_rgba`,
//   or null (which is a no-op).
// - `len` must be the exact length returned via `out_rgba_len`.
 void dterm_image_free_rgba(uint8_t *data, uintptr_t len) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Place an image at a terminal position.
//
// # Safety
//
// - `cache` must be a valid pointer returned by `dterm_image_cache_create`.
//
// # Arguments
//
// * `cache` - Image cache handle.
// * `handle` - Image handle from `dterm_image_cache_upload`.
// * `row` - Row position (negative for scrollback).
// * `col` - Column position.
// * `width_cells` - Width in terminal cells.
// * `height_cells` - Height in terminal cells.

void dterm_image_cache_place(struct DtermImageCache *cache,
                             uint64_t handle,
                             int64_t row,
                             uint16_t col,
                             uint16_t width_cells,
                             uint16_t height_cells)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Remove an image from the cache.
//
// This removes the image and all its placements.
// The caller is responsible for freeing the GPU texture.
//
// # Safety
//
// - `cache` must be a valid pointer returned by `dterm_image_cache_create`.
//
// # Arguments
//
// * `cache` - Image cache handle.
// * `handle` - Image handle from `dterm_image_cache_upload`.
//
// # Returns
//
// `true` if the image was found and removed, `false` otherwise.
 bool dterm_image_cache_remove(struct DtermImageCache *cache, uint64_t handle) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get the number of images in the cache.
//
// # Safety
//
// - `cache` must be a valid pointer returned by `dterm_image_cache_create`.
//
// # Returns
//
// Number of images in the cache.
 uintptr_t dterm_image_cache_image_count(const struct DtermImageCache *cache) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get the number of active placements.
//
// # Safety
//
// - `cache` must be a valid pointer returned by `dterm_image_cache_create`.
//
// # Returns
//
// Number of active placements.
 uintptr_t dterm_image_cache_placement_count(const struct DtermImageCache *cache) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Set the image memory budget.
//
// If the new budget is lower than current usage, images will be evicted.
//
// # Safety
//
// - `cache` must be a valid pointer returned by `dterm_image_cache_create`.
//
// # Arguments
//
// * `cache` - Image cache handle.
// * `bytes` - New memory budget in bytes.
 void dterm_image_cache_set_budget(struct DtermImageCache *cache, uintptr_t bytes) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get the current memory usage.
//
// # Safety
//
// - `cache` must be a valid pointer returned by `dterm_image_cache_create`.
//
// # Returns
//
// Current memory usage in bytes.
 uintptr_t dterm_image_cache_memory_used(const struct DtermImageCache *cache) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Clear all images and placements.
//
// # Safety
//
// - `cache` must be a valid pointer returned by `dterm_image_cache_create`.
 void dterm_image_cache_clear(struct DtermImageCache *cache) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Check if the image cache FFI is available.
 bool dterm_image_cache_available(void) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get the number of inline images in a terminal.
//
// # Safety
//
// - `terminal` must be a valid pointer to a `Terminal`.
//
// # Returns
//
// Number of stored inline images.
 uintptr_t dterm_terminal_inline_image_count(const struct Terminal *terminal) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get info about an inline image by index.
//
// # Safety
//
// - `terminal` must be a valid pointer to a `Terminal`.
// - `out_info` must be a valid pointer to a `DtermInlineImageInfo`.
//
// # Arguments
//
// * `terminal` - Terminal handle.
// * `index` - Image index (0-based).
// * `out_info` - Output pointer for image info.
//
// # Returns
//
// `true` if the image exists and info was written, `false` otherwise.

bool dterm_terminal_inline_image_info(const struct Terminal *terminal,
                                      uintptr_t index,
                                      struct DtermInlineImageInfo *out_info)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Get raw data for an inline image.
//
// # Safety
//
// - `terminal` must be a valid pointer to a `Terminal`.
// - `out_data` must be a valid pointer to receive a pointer to the data.
// - `out_len` must be a valid pointer to receive the data length.
//
// The returned data pointer is valid as long as the terminal exists and
// the image has not been evicted. Do NOT free the returned pointer.
//
// # Arguments
//
// * `terminal` - Terminal handle.
// * `index` - Image index (0-based).
// * `out_data` - Output pointer for image data.
// * `out_len` - Output pointer for data length.
//
// # Returns
//
// `true` if the image exists and data pointer was written, `false` otherwise.

bool dterm_terminal_inline_image_data(const struct Terminal *terminal,
                                      uintptr_t index,
                                      const uint8_t **out_data,
                                      uintptr_t *out_len)
;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Clear all inline images from a terminal.
//
// # Safety
//
// - `terminal` must be a valid pointer to a `Terminal`.
 void dterm_terminal_inline_image_clear(struct Terminal *terminal) ;
#endif

#if (defined(DTERM_GPU) && defined(DTERM_FFI))
// Check if inline image FFI is available.
 bool dterm_inline_image_available(void) ;
#endif

#endif  /* DTERM_H */
